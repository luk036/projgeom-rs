# 1 "src/hyp_object.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 512 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "build/.objs/projgeom-cpp/linux/arm64/release/include/projgeom/cxx/pch.hpp" 1
#pragma system_header

# 1 "/data/data/com.termux/files/home/github/rs/projgeom-rs/cpp_ai/include/projgeom/pch.hpp" 1


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 1 3
# 114 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config_site" 1 3
# 44 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config_site" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wmacro-redefined"






#pragma clang diagnostic pop
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 2 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 3
# 457 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/features.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/features.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/cdefs.h" 1 3 4
# 336 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/cdefs.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/android/versioning.h" 1 3 4
# 61 "/data/data/com.termux/files/usr/bin/../../usr/include/android/versioning.h" 3 4
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc23-extensions"


#pragma clang diagnostic pop
# 337 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/cdefs.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/android/api-level.h" 1 3 4
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/android/api-level.h" 3 4
extern "C" {
# 194 "/data/data/com.termux/files/usr/bin/../../usr/include/android/api-level.h" 3 4
int android_get_application_target_sdk_version() __attribute__((__availability__(android,strict,introduced=24 )));







# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/get_device_api_level_inlines.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/get_device_api_level_inlines.h" 3 4
extern "C" {


int __system_property_get(const char* _Nonnull __name, char* _Nonnull __value);
int atoi(const char* _Nonnull __s) __attribute__((__pure__));

static __inline__ int android_get_device_api_level() {
  char value[92] = { 0 };
  if (__system_property_get("ro.build.version.sdk", value) < 1) return -1;
  int api_level = atoi(value);
  return (api_level > 0) ? api_level : -1;
}

}
# 203 "/data/data/com.termux/files/usr/bin/../../usr/include/android/api-level.h" 2 3 4
# 220 "/data/data/com.termux/files/usr/bin/../../usr/include/android/api-level.h" 3 4
}
# 338 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/cdefs.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/android/ndk-version.h" 1 3 4
# 340 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/cdefs.h" 2 3 4
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/features.h" 2 3 4
# 458 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 2 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/integral_constant.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/integral_constant.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, _Tp __v>
struct integral_constant {
  static constexpr const _Tp value = __v;
  typedef _Tp value_type;
  typedef integral_constant type;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator value_type() const noexcept { return value; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr value_type operator()() const noexcept { return value; }

};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

template <bool _Val>
using _BoolConstant __attribute__((__nodebug__)) = integral_constant<bool, _Val>;


template <bool __b>
using bool_constant = integral_constant<bool, __b>;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/operation_traits.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/operation_traits.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


struct __equal_tag {};
struct __plus_tag {};
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/operation_traits.h" 3
template <class _CanonicalTag, class _Operation, class... _Args>
struct __desugars_to : false_type {};

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

struct __equal_to {
  template <class _T1, class _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(const _T1& __x, const _T2& __y) const {
    return __x == __y;
  }
};

template <class _Tp, class _Up>
struct __desugars_to<__equal_tag, __equal_to, _Tp, _Up> : true_type {};



template <class _T1 = void, class _T2 = _T1>
struct __less {};

template <>
struct __less<void, void> {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(const _Tp& __lhs, const _Up& __rhs) const {
    return __lhs < __rhs;
  }
};

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_floating_point.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_floating_point.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cv.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cv.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_const.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_const.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_const {
  using type __attribute__((__nodebug__)) = __remove_const(_Tp);
};

template <class _Tp>
using __remove_const_t = __remove_const(_Tp);
# 43 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_const.h" 3
template <class _Tp>
using remove_const_t = __remove_const_t<_Tp>;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cv.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_volatile.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_volatile.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_volatile {
  using type __attribute__((__nodebug__)) = __remove_volatile(_Tp);
};

template <class _Tp>
using __remove_volatile_t = __remove_volatile(_Tp);
# 43 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_volatile.h" 3
template <class _Tp>
using remove_volatile_t = __remove_volatile_t<_Tp>;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cv.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cv.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct remove_cv {
  using type __attribute__((__nodebug__)) = __remove_cv(_Tp);
};





template <class _Tp>
using __remove_cv_t = __remove_cv(_Tp);



template <class _Tp>
using remove_cv_t = __remove_cv_t<_Tp>;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_floating_point.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_floating_point.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};


template <class _Tp>
struct is_floating_point : public __libcpp_is_floating_point<__remove_cv_t<_Tp> > {};


template <class _Tp>
inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_integral.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_integral.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp> struct __libcpp_is_integral { enum { value = 0 }; };
template <> struct __libcpp_is_integral<bool> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<signed char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned char> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<wchar_t> { enum { value = 1 }; };


template <> struct __libcpp_is_integral<char8_t> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<char16_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char32_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long long> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<__int128_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<__uint128_t> { enum { value = 1 }; };





template <class _Tp>
struct is_integral : _BoolConstant<__is_integral(_Tp)> {};


template <class _Tp>
inline constexpr bool is_integral_v = __is_integral(_Tp);
# 72 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_integral.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_arithmetic.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_arithmetic.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value || is_floating_point<_Tp>::value> {};


template <class _Tp>
inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_signed : _BoolConstant<__is_signed(_Tp)> {};


template <class _Tp>
inline constexpr bool is_signed_v = __is_signed(_Tp);
# 57 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed.h" 3
}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed_integer.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed_integer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp> struct __libcpp_is_signed_integer : public false_type {};
template <> struct __libcpp_is_signed_integer<signed char> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed short> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed int> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long long> : public true_type {};

template <> struct __libcpp_is_signed_integer<__int128_t> : public true_type {};



}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unsigned_integer.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unsigned_integer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp> struct __libcpp_is_unsigned_integer : public false_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned char> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned short> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned int> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long long> : public true_type {};

template <> struct __libcpp_is_unsigned_integer<__uint128_t> : public true_type {};



}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept integral = is_integral_v<_Tp>;

template <class _Tp>
concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;

template <class _Tp>
concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;

template <class _Tp>
concept floating_point = is_floating_point_v<_Tp>;



template <class _Tp>
concept __libcpp_unsigned_integer = __libcpp_is_unsigned_integer<_Tp>::value;

template <class _Tp>
concept __libcpp_signed_integer = __libcpp_is_signed_integer<_Tp>::value;

template <class _Tp>
concept __libcpp_integer = __libcpp_unsigned_integer<_Tp> || __libcpp_signed_integer<_Tp>;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/convertible_to.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/convertible_to.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_convertible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_convertible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _T1, class _T2>
struct is_convertible : public integral_constant<bool, __is_convertible(_T1, _T2)> {};


template <class _From, class _To>
inline constexpr bool is_convertible_v = __is_convertible(_From, _To);


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/convertible_to.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/declval.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/declval.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



#pragma GCC diagnostic push
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/declval.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/declval.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
_Tp&& __declval(int);
template <class _Tp>
_Tp __declval(long);
#pragma GCC diagnostic pop

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) decltype(std::__declval<_Tp>(0)) declval() noexcept {
  static_assert(!__is_same(_Tp, _Tp),
                "std::declval can only be used in an unevaluated context. "
                "It's likely that your current usage is trying to extract a value from the function.");
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/convertible_to.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/convertible_to.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _From, class _To>
concept convertible_to = is_convertible_v<_From, _To> && requires { static_cast<_To>(std::declval<_From>()); };



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/destructible.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/destructible.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_const.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_const.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_const : _BoolConstant<__is_const(_Tp)> {};


template <class _Tp>
inline constexpr bool is_const_v = __is_const(_Tp);
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_const.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_reference.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_reference.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_lvalue_reference : _BoolConstant<__is_lvalue_reference(_Tp)> {};

template <class _Tp>
struct is_rvalue_reference : _BoolConstant<__is_rvalue_reference(_Tp)> {};

template <class _Tp>
struct is_reference : _BoolConstant<__is_reference(_Tp)> {};


template <class _Tp>
inline constexpr bool is_reference_v = __is_reference(_Tp);
template <class _Tp>
inline constexpr bool is_lvalue_reference_v = __is_lvalue_reference(_Tp);
template <class _Tp>
inline constexpr bool is_rvalue_reference_v = __is_rvalue_reference(_Tp);
# 73 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_reference.h" 3
}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_function : integral_constant<bool, __is_function(_Tp)> {};
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 3
template <class _Tp>
inline constexpr bool is_function_v = is_function<_Tp>::value;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_all_extents.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_all_extents.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 1 3
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/enable_if.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/enable_if.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <bool, class _Tp = void>
struct enable_if {};
template <class _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <bool _Bp, class _Tp = void>
using __enable_if_t __attribute__((__nodebug__)) = typename enable_if<_Bp, _Tp>::type;


template <bool _Bp, class _Tp = void>
using enable_if_t = typename enable_if<_Bp, _Tp>::type;


}}
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/version" 1 3
# 248 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/version" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__availability" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__availability" 3
# 249 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/version" 2 3
# 253 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/version" 3
# 41 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3
# 43 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 3



# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 1 3
# 84 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 3
# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_header_macro.h" 1 3
# 85 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3



# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 89 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_size_t.h" 1 3
# 18 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 94 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3
# 103 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 3
# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_wchar_t.h" 1 3
# 104 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_null.h" 1 3
# 109 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_nullptr_t.h" 1 3
# 114 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3
# 123 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 3
# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_max_align_t.h" 1 3
# 19 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 124 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_offsetof.h" 1 3
# 129 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3
# 47 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 2 3



typedef decltype(nullptr) nullptr_t;
# 43 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 2 3
# 54 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

using ::nullptr_t;
using ::ptrdiff_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));


using ::max_align_t __attribute__((__using_if_exists__));


}}


namespace std
{
enum class byte : unsigned char {};

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte operator|(byte __lhs, byte __rhs) noexcept {
  return static_cast<byte>(
      static_cast<unsigned char>(static_cast<unsigned int>(__lhs) | static_cast<unsigned int>(__rhs)));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte& operator|=(byte& __lhs, byte __rhs) noexcept {
  return __lhs = __lhs | __rhs;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte operator&(byte __lhs, byte __rhs) noexcept {
  return static_cast<byte>(
      static_cast<unsigned char>(static_cast<unsigned int>(__lhs) & static_cast<unsigned int>(__rhs)));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte& operator&=(byte& __lhs, byte __rhs) noexcept {
  return __lhs = __lhs & __rhs;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte operator^(byte __lhs, byte __rhs) noexcept {
  return static_cast<byte>(
      static_cast<unsigned char>(static_cast<unsigned int>(__lhs) ^ static_cast<unsigned int>(__rhs)));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte& operator^=(byte& __lhs, byte __rhs) noexcept {
  return __lhs = __lhs ^ __rhs;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte operator~(byte __b) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(~static_cast<unsigned int>(__b)));
}

template <class _Integer, __enable_if_t<is_integral<_Integer>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr byte& operator<<=(byte& __lhs, _Integer __shift) noexcept {
  return __lhs = __lhs << __shift;
}

template <class _Integer, __enable_if_t<is_integral<_Integer>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr byte operator<<(byte __lhs, _Integer __shift) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) << __shift));
}

template <class _Integer, __enable_if_t<is_integral<_Integer>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr byte& operator>>=(byte& __lhs, _Integer __shift) noexcept {
  return __lhs = __lhs >> __shift;
}

template <class _Integer, __enable_if_t<is_integral<_Integer>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr byte operator>>(byte __lhs, _Integer __shift) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) >> __shift));
}

template <class _Integer, __enable_if_t<is_integral<_Integer>::value, int> = 0>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Integer to_integer(byte __b) noexcept {
  return static_cast<_Integer>(__b);
}

}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_all_extents.h" 2 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_all_extents.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_all_extents {
  using type __attribute__((__nodebug__)) = __remove_all_extents(_Tp);
};

template <class _Tp>
using __remove_all_extents_t = __remove_all_extents(_Tp);
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_all_extents.h" 3
template <class _Tp>
using remove_all_extents_t = __remove_all_extents_t<_Tp>;


}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_destructible : _BoolConstant<__is_destructible(_Tp)> {};


template <class _Tp>
inline constexpr bool is_destructible_v = __is_destructible(_Tp);
# 95 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_enum.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_enum.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {};


template <class _Tp>
inline constexpr bool is_enum_v = __is_enum(_Tp);


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_pointer.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_pointer.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_function_pointer.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_function_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __libcpp_is_member_pointer {
  enum { __is_member = false, __is_func = false, __is_obj = false };
};
template <class _Tp, class _Up>
struct __libcpp_is_member_pointer<_Tp _Up::*> {
  enum {
    __is_member = true,
    __is_func = is_function<_Tp>::value,
    __is_obj = !__is_func,
  };
};



template <class _Tp>
struct is_member_function_pointer : _BoolConstant<__is_member_function_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_member_function_pointer_v = __is_member_function_pointer(_Tp);
# 60 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_function_pointer.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_pointer.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_member_pointer : _BoolConstant<__is_member_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_pointer.h" 3
}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_null_pointer.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_null_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __is_nullptr_t_impl : public false_type {};
template <>
struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp>
struct __is_nullptr_t : public __is_nullptr_t_impl<__remove_cv_t<_Tp> > {};


template <class _Tp>
struct is_null_pointer : public __is_nullptr_t_impl<__remove_cv_t<_Tp> > {};


template <class _Tp>
inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;



}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_pointer.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_pointer : _BoolConstant<__is_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_pointer_v = __is_pointer(_Tp);
# 63 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_pointer.h" 3
}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_scalar : _BoolConstant<__is_scalar(_Tp)> {};


template <class _Tp>
inline constexpr bool is_scalar_v = __is_scalar(_Tp);
# 67 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 3
}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 2 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <bool, class _Tp>
struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp> : public false_type {};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::declval<_Tp>().~_Tp()) > {};

template <class _Tp>
struct is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp> {};

template <class _Tp, size_t _Ns>
struct is_nothrow_destructible<_Tp[_Ns]> : public is_nothrow_destructible<_Tp> {};

template <class _Tp>
struct is_nothrow_destructible<_Tp&> : public true_type {};

template <class _Tp>
struct is_nothrow_destructible<_Tp&&> : public true_type {};
# 68 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 3
template <class _Tp>
inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Tp>::value;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/destructible.h" 2 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/destructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept destructible = is_nothrow_destructible_v<_Tp>;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_constructible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class... _Args>
struct is_constructible : public integral_constant<bool, __is_constructible(_Tp, _Args...)> {};


template <class _Tp, class... _Args>
inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class _Tp, class... _Args>
concept constructible_from = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;



template <class _Tp>
concept __default_initializable = requires { ::new _Tp; };

template <class _Tp>
concept default_initializable = constructible_from<_Tp> && requires { _Tp{}; } && __default_initializable<_Tp>;


template <class _Tp>
concept move_constructible = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;



template <class _Tp>
concept copy_constructible =
    move_constructible<_Tp> &&
    constructible_from<_Tp, _Tp&> && convertible_to<_Tp&, _Tp> &&
    constructible_from<_Tp, const _Tp&> && convertible_to<const _Tp&, _Tp> &&
    constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;




}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/copyable.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/copyable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_reference_with.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_reference_with.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/same_as.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/same_as.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_same.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_same.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Up>
struct is_same : _BoolConstant<__is_same(_Tp, _Up)> {};


template <class _Tp, class _Up>
inline constexpr bool is_same_v = __is_same(_Tp, _Up);
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_same.h" 3
template <class _Tp, class _Up>
using _IsSame = _BoolConstant<__is_same(_Tp, _Up)>;

template <class _Tp, class _Up>
using _IsNotSame = _BoolConstant<!__is_same(_Tp, _Up)>;

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/same_as.h" 2 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/same_as.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class _Up>
concept __same_as_impl = _IsSame<_Tp, _Up>::value;

template <class _Tp, class _Up>
concept same_as = __same_as_impl<_Tp, _Up> && __same_as_impl<_Up, _Tp>;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_reference_with.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/conditional.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/conditional.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <bool>
struct _IfImpl;

template <>
struct _IfImpl<true> {
  template <class _IfRes, class _ElseRes>
  using _Select __attribute__((__nodebug__)) = _IfRes;
};

template <>
struct _IfImpl<false> {
  template <class _IfRes, class _ElseRes>
  using _Select __attribute__((__nodebug__)) = _ElseRes;
};

template <bool _Cond, class _IfRes, class _ElseRes>
using _If __attribute__((__nodebug__)) = typename _IfImpl<_Cond>::template _Select<_IfRes, _ElseRes>;

template <bool _Bp, class _If, class _Then>
struct conditional {
  using type __attribute__((__nodebug__)) = _If;
};
template <class _If, class _Then>
struct conditional<false, _If, _Then> {
  using type __attribute__((__nodebug__)) = _Then;
};


template <bool _Bp, class _IfRes, class _ElseRes>
using conditional_t __attribute__((__nodebug__)) = typename conditional<_Bp, _IfRes, _ElseRes>::type;



template <bool _Bp, class _If, class _Then>
using __conditional_t __attribute__((__nodebug__)) = typename conditional<_Bp, _If, _Then>::type;

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_referenceable.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_referenceable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





struct __libcpp_is_referenceable_impl {
  template <class _Tp>
  static _Tp& __test(int);
  template <class _Tp>
  static false_type __test(...);
};

template <class _Tp>
struct __libcpp_is_referenceable
    : integral_constant<bool, _IsNotSame<decltype(__libcpp_is_referenceable_impl::__test<_Tp>(0)), false_type>::value> {
};


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_void.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_void.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_void : _BoolConstant<__is_void(_Tp)> {};


template <class _Tp>
inline constexpr bool is_void_v = __is_void(_Tp);
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_void.h" 3
}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_reference.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_reference.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_reference {
  using type __attribute__((__nodebug__)) = __remove_reference_t(_Tp);
};

template <class _Tp>
using __libcpp_remove_reference_t = __remove_reference_t(_Tp);
# 41 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_reference.h" 3
template <class _Tp>
using remove_reference_t = __libcpp_remove_reference_t<_Tp>;


}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __add_pointer_t = __add_pointer(_Tp);
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 3
template <class _Tp>
struct add_pointer {
  using type __attribute__((__nodebug__)) = __add_pointer_t<_Tp>;
};


template <class _Tp>
using add_pointer_t = __add_pointer_t<_Tp>;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_array.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_array.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_array.h" 3
template <class _Tp>
struct is_array : public false_type {};
template <class _Tp>
struct is_array<_Tp[]> : public true_type {};
template <class _Tp, size_t _Np>
struct is_array<_Tp[_Np]> : public true_type {};


template <class _Tp>
inline constexpr bool is_array_v = is_array<_Tp>::value;




}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_extent.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_extent.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_extent {
  using type __attribute__((__nodebug__)) = __remove_extent(_Tp);
};

template <class _Tp>
using __remove_extent_t = __remove_extent(_Tp);
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_extent.h" 3
template <class _Tp>
using remove_extent_t = __remove_extent_t<_Tp>;


}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 2 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
using __decay_t __attribute__((__nodebug__)) = __decay(_Tp);

template <class _Tp>
struct decay {
  using type __attribute__((__nodebug__)) = __decay_t<_Tp>;
};
# 67 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 3
template <class _Tp>
using decay_t = __decay_t<_Tp>;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cvref.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cvref.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cvref.h" 3
template <class _Tp>
using __remove_cvref_t __attribute__((__nodebug__)) = __remove_cvref(_Tp);


template <class _Tp, class _Up>
using __is_same_uncvref = _IsSame<__remove_cvref_t<_Tp>, __remove_cvref_t<_Up> >;


template <class _Tp>
struct remove_cvref {
  using type __attribute__((__nodebug__)) = __remove_cvref(_Tp);
};

template <class _Tp>
using remove_cvref_t = __remove_cvref_t<_Tp>;


}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/void_t.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/void_t.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class...>
using void_t = void;


template <class...>
using __void_t = void;

}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp, class _Up>
using __cond_type = decltype(false ? std::declval<_Tp>() : std::declval<_Up>());

template <class _Tp, class _Up, class = void>
struct __common_type3 {};


template <class _Tp, class _Up>
struct __common_type3<_Tp, _Up, void_t<__cond_type<const _Tp&, const _Up&>>> {
  using type = remove_cvref_t<__cond_type<const _Tp&, const _Up&>>;
};

template <class _Tp, class _Up, class = void>
struct __common_type2_imp : __common_type3<_Tp, _Up> {};






template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up, __void_t<decltype(true ? std::declval<_Tp>() : std::declval<_Up>())> > {
  typedef __attribute__((__nodebug__)) __decay_t<decltype(true ? std::declval<_Tp>() : std::declval<_Up>())> type;
};

template <class, class = void>
struct __common_type_impl {};

template <class... _Tp>
struct __common_types;
template <class... _Tp>
struct common_type;

template <class _Tp, class _Up>
struct __common_type_impl< __common_types<_Tp, _Up>, __void_t<typename common_type<_Tp, _Up>::type> > {
  typedef typename common_type<_Tp, _Up>::type type;
};

template <class _Tp, class _Up, class _Vp, class... _Rest>
struct __common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...>, __void_t<typename common_type<_Tp, _Up>::type> >
    : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type, _Vp, _Rest...> > {};



template <>
struct common_type<> {};



template <class _Tp>
struct common_type<_Tp> : public common_type<_Tp, _Tp> {};




template <class _Tp, class _Up>
struct common_type<_Tp, _Up>
    : conditional<_IsSame<_Tp, __decay_t<_Tp> >::value && _IsSame<_Up, __decay_t<_Up> >::value,
                  __common_type2_imp<_Tp, _Up>,
                  common_type<__decay_t<_Tp>, __decay_t<_Up> > >::type {};



template <class _Tp, class _Up, class _Vp, class... _Rest>
struct common_type<_Tp, _Up, _Vp, _Rest...>
    : __common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...> > {};


template <class... _Tp>
using common_type_t = typename common_type<_Tp...>::type;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_const.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_const.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct add_const {
  typedef __attribute__((__nodebug__)) const _Tp type;
};


template <class _Tp>
using add_const_t = typename add_const<_Tp>::type;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_cv.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_cv.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct add_cv {
  typedef __attribute__((__nodebug__)) const volatile _Tp type;
};


template <class _Tp>
using add_cv_t = typename add_cv<_Tp>::type;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_volatile.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_volatile.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct add_volatile {
  typedef __attribute__((__nodebug__)) volatile _Tp type;
};


template <class _Tp>
using add_volatile_t = typename add_volatile<_Tp>::type;


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _From, class _To>
struct __copy_cv {
  using type = _To;
};

template <class _From, class _To>
struct __copy_cv<const _From, _To> {
  using type = typename add_const<_To>::type;
};

template <class _From, class _To>
struct __copy_cv<volatile _From, _To> {
  using type = typename add_volatile<_To>::type;
};

template <class _From, class _To>
struct __copy_cv<const volatile _From, _To> {
  using type = typename add_cv<_To>::type;
};

template <class _From, class _To>
using __copy_cv_t = typename __copy_cv<_From, _To>::type;

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cvref.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cvref.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_lvalue_reference.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_lvalue_reference.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __add_lvalue_reference_t = __add_lvalue_reference(_Tp);
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_lvalue_reference.h" 3
template <class _Tp>
struct add_lvalue_reference {
  using type __attribute__((__nodebug__)) = __add_lvalue_reference_t<_Tp>;
};


template <class _Tp>
using add_lvalue_reference_t = __add_lvalue_reference_t<_Tp>;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cvref.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_rvalue_reference.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_rvalue_reference.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __add_rvalue_reference_t = __add_rvalue_reference(_Tp);
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_rvalue_reference.h" 3
template <class _Tp>
struct add_rvalue_reference {
  using type = __add_rvalue_reference_t<_Tp>;
};


template <class _Tp>
using add_rvalue_reference_t = __add_rvalue_reference_t<_Tp>;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cvref.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cvref.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _From, class _To>
struct __copy_cvref {
  using type = __copy_cv_t<_From, _To>;
};

template <class _From, class _To>
struct __copy_cvref<_From&, _To> {
  using type = __add_lvalue_reference_t<__copy_cv_t<_From, _To> >;
};

template <class _From, class _To>
struct __copy_cvref<_From&&, _To> {
  using type = __add_rvalue_reference_t<__copy_cv_t<_From, _To> >;
};

template <class _From, class _To>
using __copy_cvref_t = typename __copy_cvref<_From, _To>::type;

}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 2 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class _Xp, class _Yp>
using __cond_res = decltype(false ? std::declval<_Xp (&)()>()() : std::declval<_Yp (&)()>()());





template <class _Tp>
struct __xref {
  template <class _Up>
  using __apply = __copy_cvref_t<_Tp, _Up>;
};



template <class _Ap, class _Bp, class _Xp = remove_reference_t<_Ap>, class _Yp = remove_reference_t<_Bp>>
struct __common_ref;

template <class _Xp, class _Yp>
using __common_ref_t = typename __common_ref<_Xp, _Yp>::__type;

template <class _Xp, class _Yp>
using __cv_cond_res = __cond_res<__copy_cv_t<_Xp, _Yp>&, __copy_cv_t<_Yp, _Xp>&>;




template <class _Ap, class _Bp, class _Xp, class _Yp>
  requires
    requires { typename __cv_cond_res<_Xp, _Yp>; } &&
    is_reference_v<__cv_cond_res<_Xp, _Yp>>
struct __common_ref<_Ap&, _Bp&, _Xp, _Yp> {
  using __type = __cv_cond_res<_Xp, _Yp>;
};



template <class _Xp, class _Yp>
using __common_ref_C = remove_reference_t<__common_ref_t<_Xp&, _Yp&>>&&;




template <class _Ap, class _Bp, class _Xp, class _Yp>
  requires
    requires { typename __common_ref_C<_Xp, _Yp>; } &&
    is_convertible_v<_Ap&&, __common_ref_C<_Xp, _Yp>> &&
    is_convertible_v<_Bp&&, __common_ref_C<_Xp, _Yp>>
struct __common_ref<_Ap&&, _Bp&&, _Xp, _Yp> {
  using __type = __common_ref_C<_Xp, _Yp>;
};



template <class _Tp, class _Up>
using __common_ref_D = __common_ref_t<const _Tp&, _Up&>;




template <class _Ap, class _Bp, class _Xp, class _Yp>
  requires
    requires { typename __common_ref_D<_Xp, _Yp>; } &&
    is_convertible_v<_Ap&&, __common_ref_D<_Xp, _Yp>>
struct __common_ref<_Ap&&, _Bp&, _Xp, _Yp> {
  using __type = __common_ref_D<_Xp, _Yp>;
};




template <class _Ap, class _Bp, class _Xp, class _Yp>
struct __common_ref<_Ap&, _Bp&&, _Xp, _Yp> : __common_ref<_Bp&&, _Ap&> {};


template <class _Ap, class _Bp, class _Xp, class _Yp>
struct __common_ref {};



template <class...>
struct common_reference;

template <class... _Types>
using common_reference_t = typename common_reference<_Types...>::type;


template <>
struct common_reference<> {};


template <class _Tp>
struct common_reference<_Tp> {
  using type = _Tp;
};


template <class _Tp, class _Up>
struct __common_reference_sub_bullet3;
template <class _Tp, class _Up>
struct __common_reference_sub_bullet2 : __common_reference_sub_bullet3<_Tp, _Up> {};
template <class _Tp, class _Up>
struct __common_reference_sub_bullet1 : __common_reference_sub_bullet2<_Tp, _Up> {};



template <class _Tp, class _Up>
struct common_reference<_Tp, _Up> : __common_reference_sub_bullet1<_Tp, _Up> {};

template <class _Tp, class _Up>
  requires is_reference_v<_Tp> && is_reference_v<_Up> && requires { typename __common_ref_t<_Tp, _Up>; }
struct __common_reference_sub_bullet1<_Tp, _Up> {
  using type = __common_ref_t<_Tp, _Up>;
};



template <class, class, template <class> class, template <class> class>
struct basic_common_reference {};

template <class _Tp, class _Up>
using __basic_common_reference_t =
    typename basic_common_reference<remove_cvref_t<_Tp>,
                                    remove_cvref_t<_Up>,
                                    __xref<_Tp>::template __apply,
                                    __xref<_Up>::template __apply>::type;

template <class _Tp, class _Up>
  requires requires { typename __basic_common_reference_t<_Tp, _Up>; }
struct __common_reference_sub_bullet2<_Tp, _Up> {
  using type = __basic_common_reference_t<_Tp, _Up>;
};



template <class _Tp, class _Up>
  requires requires { typename __cond_res<_Tp, _Up>; }
struct __common_reference_sub_bullet3<_Tp, _Up> {
  using type = __cond_res<_Tp, _Up>;
};




template <class _Tp, class _Up>
struct __common_reference_sub_bullet3 : common_type<_Tp, _Up> {};



template <class _Tp, class _Up, class _Vp, class... _Rest>
  requires requires { typename common_reference_t<_Tp, _Up>; }
struct common_reference<_Tp, _Up, _Vp, _Rest...> : common_reference<common_reference_t<_Tp, _Up>, _Vp, _Rest...> {};


template <class...>
struct common_reference {};



}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_reference_with.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_reference_with.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class _Up>
concept common_reference_with =
    same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>> &&
    convertible_to<_Tp, common_reference_t<_Tp, _Up>> && convertible_to<_Up, common_reference_t<_Tp, _Up>>;



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_const_lvalue_ref.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_const_lvalue_ref.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
using __make_const_lvalue_ref = const __libcpp_remove_reference_t<_Tp>&;

}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/forward.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/forward.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp&&
forward([[_Clang::__lifetimebound__]] __libcpp_remove_reference_t<_Tp>& __t) noexcept {
  return static_cast<_Tp&&>(__t);
}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp&&
forward([[_Clang::__lifetimebound__]] __libcpp_remove_reference_t<_Tp>&& __t) noexcept {
  static_assert(!is_lvalue_reference<_Tp>::value, "cannot forward an rvalue as an lvalue");
  return static_cast<_Tp&&>(__t);
}

}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Lhs, class _Rhs>
concept assignable_from =
    is_lvalue_reference_v<_Lhs> &&
    common_reference_with<__make_const_lvalue_ref<_Lhs>, __make_const_lvalue_ref<_Rhs>> &&
    requires(_Lhs __lhs, _Rhs&& __rhs) {
      { __lhs = std::forward<_Rhs>(__rhs) } -> same_as<_Lhs>;
    };



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/copyable.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/movable.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/movable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/class_or_enum.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/class_or_enum.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_class.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_class.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_class : public integral_constant<bool, __is_class(_Tp)> {};


template <class _Tp>
inline constexpr bool is_class_v = __is_class(_Tp);


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/class_or_enum.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_union.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_union.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_union : public integral_constant<bool, __is_union(_Tp)> {};


template <class _Tp>
inline constexpr bool is_union_v = __is_union(_Tp);


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/class_or_enum.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/class_or_enum.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept __class_or_enum = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;



template <class _Tp>
concept __workaround_52970 = is_class_v<__remove_cvref_t<_Tp>> || is_union_v<__remove_cvref_t<_Tp>>;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/extent.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/extent.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp, size_t _Dim = 0>
struct extent : integral_constant<size_t, __array_extent(_Tp, _Dim)> {};


template <class _Tp, unsigned _Ip = 0>
inline constexpr size_t extent_v = __array_extent(_Tp, _Ip);
# 52 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/extent.h" 3
}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_assignable.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_nothrow_move_assignable
    : public integral_constant<bool,
                               __is_nothrow_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {
};


template <class _Tp>
inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Tp>::value;


}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_constructible.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template < class _Tp, class... _Args>
struct is_nothrow_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)> {};
# 65 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_constructible.h" 3
template <class _Tp, class... _Args>
inline constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Tp, _Args...>::value;


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class _Tp>
struct is_nothrow_move_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};
# 39 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 3
template <class _Tp>
inline constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Tp>::value;


}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_assignable.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Arg>
struct is_nothrow_assignable : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {
};


template <class _Tp, class _Arg>
inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_Tp, _Arg);


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/move.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/move.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_copy_constructible.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_copy_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_copy_constructible
    : public integral_constant<bool, __is_constructible(_Tp, __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {
};


template <class _Tp>
inline constexpr bool is_copy_constructible_v = is_copy_constructible<_Tp>::value;


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/move.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/move.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/move.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __libcpp_remove_reference_t<_Tp>&&
move([[_Clang::__lifetimebound__]] _Tp&& __t) noexcept {
  typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tp> _Up;
  return static_cast<_Up&&>(__t);
}

template <class _Tp>
using __move_if_noexcept_result_t =
    __conditional_t<!is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value, const _Tp&, _Tp&&>;

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __move_if_noexcept_result_t<_Tp>
move_if_noexcept([[_Clang::__lifetimebound__]] _Tp& __x) noexcept {
  return std::move(__x);
}

}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _T1, class _T2 = _T1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 exchange(_T1& __obj, _T2&& __new_value) noexcept(
    is_nothrow_move_constructible<_T1>::value && is_nothrow_assignable<_T1&, _T2>::value) {
  _T1 __old_value = std::move(__obj);
  __obj = std::forward<_T2>(__new_value);
  return __old_value;
}


}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_move_assignable.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_move_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_move_assignable
    : public integral_constant<bool, __is_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {};


template <class _Tp>
inline constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_move_constructible.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_move_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_move_constructible
    : public integral_constant<bool, __is_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};


template <class _Tp>
inline constexpr bool is_move_constructible_v = is_move_constructible<_Tp>::value;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_swappable.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_swappable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/nat.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/nat.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

struct __nat {

  __nat() = delete;
  __nat(const __nat&) = delete;
  __nat& operator=(const __nat&) = delete;
  ~__nat() = delete;

};

}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_swappable.h" 2 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_swappable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __is_swappable;
template <class _Tp>
struct __is_nothrow_swappable;


template <class _Tp>
using __swap_result_t = __enable_if_t<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>;





template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __swap_result_t<_Tp> swap(_Tp& __x, _Tp& __y)
    noexcept(is_nothrow_move_constructible<_Tp>::value&& is_nothrow_move_assignable<_Tp>::value);

template <class _Tp, size_t _Np, __enable_if_t<__is_swappable<_Tp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
    noexcept(__is_nothrow_swappable<_Tp>::value);

namespace __detail {


template <class _Tp, class _Up = _Tp, bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with {
  template <class _LHS, class _RHS>
  static decltype(swap(std::declval<_LHS>(), std::declval<_RHS>())) __test_swap(int);
  template <class, class>
  static __nat __test_swap(long);


  typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
  typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

  static const bool value = _IsNotSame<__swap1, __nat>::value && _IsNotSame<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))&& noexcept(
          swap(std::declval<_Up>(), std::declval<_Tp>()));



};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

}

template <class _Tp>
struct __is_swappable : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value> {};

template <class _Tp>
struct __is_nothrow_swappable : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value> {};



template <class _Tp, class _Up>
struct is_swappable_with
    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value> {};

template <class _Tp>
struct is_swappable
    : public __conditional_t<__libcpp_is_referenceable<_Tp>::value,
                             is_swappable_with<__add_lvalue_reference_t<_Tp>, __add_lvalue_reference_t<_Tp> >,
                             false_type> {};

template <class _Tp, class _Up>
struct is_nothrow_swappable_with
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value> {};

template <class _Tp>
struct is_nothrow_swappable
    : public __conditional_t<__libcpp_is_referenceable<_Tp>::value,
                             is_nothrow_swappable_with<__add_lvalue_reference_t<_Tp>, __add_lvalue_reference_t<_Tp> >,
                             false_type> {};

template <class _Tp, class _Up>
inline constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;

template <class _Tp>
inline constexpr bool is_swappable_v = is_swappable<_Tp>::value;

template <class _Tp, class _Up>
inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;

template <class _Tp>
inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;



}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 2 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
using __swap_result_t = __enable_if_t<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>;





template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __swap_result_t<_Tp> constexpr swap(_Tp& __x, _Tp& __y)
    noexcept(is_nothrow_move_constructible<_Tp>::value&& is_nothrow_move_assignable<_Tp>::value) {
  _Tp __t(std::move(__x));
  __x = std::move(__y);
  __y = std::move(__t);
}

template <class _Tp, size_t _Np, __enable_if_t<__is_swappable<_Tp>::value, int> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
    noexcept(__is_nothrow_swappable<_Tp>::value) {
  for (size_t __i = 0; __i != _Np; ++__i) {
    swap(__a[__i], __b[__i]);
  }
}

}}
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





namespace ranges {
namespace __swap {

template <class _Tp>
void swap(_Tp&, _Tp&) = delete;


template <class _Tp, class _Up>
concept __unqualified_swappable_with =
    (__class_or_enum<remove_cvref_t<_Tp>> || __class_or_enum<remove_cvref_t<_Up>>) &&
    requires(_Tp&& __t, _Up&& __u) {
        swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
    };


struct __fn;


template <class _Tp, class _Up, size_t _Size>
concept __swappable_arrays =
    !__unqualified_swappable_with<_Tp (&)[_Size], _Up (&)[_Size]> &&
    extent_v<_Tp> == extent_v<_Up> &&
    requires(_Tp (&__t)[_Size], _Up (&__u)[_Size], const __fn& __swap) {
        __swap(__t[0], __u[0]);
    };


template <class _Tp>
concept __exchangeable =
    !__unqualified_swappable_with<_Tp&, _Tp&> && move_constructible<_Tp> && assignable_from<_Tp&, _Tp>;

struct __fn {


  template <class _Tp, class _Up>
    requires __unqualified_swappable_with<_Tp, _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(swap(std::forward<_Tp>(__t), std::forward<_Up>(__u)))) {
    swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
  }


  template <class _Tp, class _Up, size_t _Size>
    requires __swappable_arrays<_Tp, _Up, _Size>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_Tp (&__t)[_Size], _Up (&__u)[_Size]) const
      noexcept(noexcept((*this)(*__t, *__u))) {

    for (size_t __i = 0; __i < _Size; ++__i) {
      (*this)(__t[__i], __u[__i]);
    }
  }


  template <__exchangeable _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_Tp& __x, _Tp& __y) const
      noexcept(is_nothrow_move_constructible_v<_Tp> && is_nothrow_move_assignable_v<_Tp>) {
    __y = std::exchange(__x, std::move(__y));
  }
};
}

inline namespace __cpo {
inline constexpr auto swap = __swap::__fn{};
}
}

template <class _Tp>
concept swappable = requires(_Tp& __a, _Tp& __b) { ranges::swap(__a, __b); };

template <class _Tp, class _Up>
concept swappable_with = common_reference_with<_Tp, _Up> && requires(_Tp&& __t, _Up&& __u) {
  ranges::swap(std::forward<_Tp>(__t), std::forward<_Tp>(__t));
  ranges::swap(std::forward<_Up>(__u), std::forward<_Up>(__u));
  ranges::swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
  ranges::swap(std::forward<_Up>(__u), std::forward<_Tp>(__t));
};



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/movable.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_object.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_object.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_object : _BoolConstant<__is_object(_Tp)> {};


template <class _Tp>
inline constexpr bool is_object_v = __is_object(_Tp);
# 50 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_object.h" 3
}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/movable.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/movable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept movable = is_object_v<_Tp> && move_constructible<_Tp> && assignable_from<_Tp&, _Tp> && swappable<_Tp>;



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/copyable.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/copyable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {






template <class _Tp>
concept copyable =
    copy_constructible<_Tp> &&
    movable<_Tp> &&
    assignable_from<_Tp&, _Tp&> &&
    assignable_from<_Tp&, const _Tp&> &&
    assignable_from<_Tp&, const _Tp>;




}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/equality_comparable.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/equality_comparable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/boolean_testable.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/boolean_testable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept __boolean_testable_impl = convertible_to<_Tp, bool>;

template <class _Tp>
concept __boolean_testable = __boolean_testable_impl<_Tp> && requires(_Tp&& __t) {
  { !std::forward<_Tp>(__t) } -> __boolean_testable_impl;
};



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/equality_comparable.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/equality_comparable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class _Up>
concept __weakly_equality_comparable_with =
    requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
      { __t == __u } -> __boolean_testable;
      { __t != __u } -> __boolean_testable;
      { __u == __t } -> __boolean_testable;
      { __u != __t } -> __boolean_testable;
    };

template <class _Tp>
concept equality_comparable = __weakly_equality_comparable_with<_Tp, _Tp>;


template <class _Tp, class _Up>
concept equality_comparable_with =
    equality_comparable<_Tp> && equality_comparable<_Up> &&
    common_reference_with<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>> &&
    equality_comparable<
        common_reference_t<
            __make_const_lvalue_ref<_Tp>,
            __make_const_lvalue_ref<_Up>>> &&
    __weakly_equality_comparable_with<_Tp, _Up>;




}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/totally_ordered.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/totally_ordered.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class _Up>
concept __partially_ordered_with = requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
  { __t < __u } -> __boolean_testable;
  { __t > __u } -> __boolean_testable;
  { __t <= __u } -> __boolean_testable;
  { __t >= __u } -> __boolean_testable;
  { __u < __t } -> __boolean_testable;
  { __u > __t } -> __boolean_testable;
  { __u <= __t } -> __boolean_testable;
  { __u >= __t } -> __boolean_testable;
};

template <class _Tp>
concept totally_ordered = equality_comparable<_Tp> && __partially_ordered_with<_Tp, _Tp>;


template <class _Tp, class _Up>
concept totally_ordered_with =
    totally_ordered<_Tp> && totally_ordered<_Up> &&
    equality_comparable_with<_Tp, _Up> &&
    totally_ordered<
        common_reference_t<
            __make_const_lvalue_ref<_Tp>,
            __make_const_lvalue_ref<_Up>>> &&
    __partially_ordered_with<_Tp, _Up>;




}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/pair.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/pair.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/tuple.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/tuple.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <size_t, class>
struct tuple_element;



template <class...>
class tuple;

template <class>
struct tuple_size;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&&) noexcept;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/pair.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/pair.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class, class>
struct pair;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) noexcept;


template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&&) noexcept;


}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/incrementable_traits.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/incrementable_traits.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_primary_template.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_primary_template.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_valid_expansion.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_valid_expansion.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <template <class...> class _Templ, class... _Args, class = _Templ<_Args...> >
true_type __sfinae_test_impl(int);
template <template <class...> class, class...>
false_type __sfinae_test_impl(...);

template <template <class...> class _Templ, class... _Args>
using _IsValidExpansion __attribute__((__nodebug__)) = decltype(std::__sfinae_test_impl<_Templ, _Args...>(0));

}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_primary_template.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_primary_template.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
using __test_for_primary_template = __enable_if_t<_IsSame<_Tp, typename _Tp::__primary_template>::value>;

template <class _Tp>
using __is_primary_template = _IsValidExpansion<__test_for_primary_template, _Tp>;

}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/incrementable_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/apply_cv.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/apply_cv.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_volatile.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_volatile.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_volatile : _BoolConstant<__is_volatile(_Tp)> {};


template <class _Tp>
inline constexpr bool is_volatile_v = __is_volatile(_Tp);
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_volatile.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/apply_cv.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/apply_cv.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp,
          bool = is_const<__libcpp_remove_reference_t<_Tp> >::value,
          bool = is_volatile<__libcpp_remove_reference_t<_Tp> >::value>
struct __apply_cv_impl {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, true, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, false, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = volatile _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, true, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const volatile _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, false, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, true, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, false, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = volatile _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, true, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const volatile _Up&;
};

template <class _Tp, class _Up>
using __apply_cv_t __attribute__((__nodebug__)) = typename __apply_cv_impl<_Tp>::template __apply<_Up>;

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 2 3




# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/type_list.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/type_list.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Hp, class _Tp>
struct __type_list {
  typedef _Hp _Head;
  typedef _Tp _Tail;
};

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)>
struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true> {
  typedef __attribute__((__nodebug__)) _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false> {
  typedef __attribute__((__nodebug__)) typename __find_first<_Tp, _Size>::type type;
};

}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __make_signed_t = __make_signed(_Tp);
# 77 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 3
template <class _Tp>
struct make_signed {
  using type __attribute__((__nodebug__)) = __make_signed_t<_Tp>;
};


template <class _Tp>
using make_signed_t = __make_signed_t<_Tp>;


}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/incrementable_traits.h" 2 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/incrementable_traits.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class>
struct incrementable_traits {};

template <class _Tp>
  requires is_object_v<_Tp>
struct incrementable_traits<_Tp*> {
  using difference_type = ptrdiff_t;
};

template <class _Ip>
struct incrementable_traits<const _Ip> : incrementable_traits<_Ip> {};

template <class _Tp>
concept __has_member_difference_type = requires { typename _Tp::difference_type; };

template <__has_member_difference_type _Tp>
struct incrementable_traits<_Tp> {
  using difference_type = typename _Tp::difference_type;
};

template <class _Tp>
concept __has_integral_minus = requires(const _Tp& __x, const _Tp& __y) {
  { __x - __y } -> integral;
};

template <__has_integral_minus _Tp>
  requires(!__has_member_difference_type<_Tp>)
struct incrementable_traits<_Tp> {
  using difference_type = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
};

template <class>
struct iterator_traits;




template <class _Ip>
using iter_difference_t =
    typename conditional_t<__is_primary_template<iterator_traits<remove_cvref_t<_Ip> > >::value,
                           incrementable_traits<remove_cvref_t<_Ip> >,
                           iterator_traits<remove_cvref_t<_Ip> > >::difference_type;



}}
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/readable_traits.h" 1 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/readable_traits.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class>
struct __cond_value_type {};

template <class _Tp>
  requires is_object_v<_Tp>
struct __cond_value_type<_Tp> {
  using value_type = remove_cv_t<_Tp>;
};

template <class _Tp>
concept __has_member_value_type = requires { typename _Tp::value_type; };

template <class _Tp>
concept __has_member_element_type = requires { typename _Tp::element_type; };

template <class>
struct indirectly_readable_traits {};

template <class _Ip>
  requires is_array_v<_Ip>
struct indirectly_readable_traits<_Ip> {
  using value_type = remove_cv_t<remove_extent_t<_Ip>>;
};

template <class _Ip>
struct indirectly_readable_traits<const _Ip> : indirectly_readable_traits<_Ip> {};

template <class _Tp>
struct indirectly_readable_traits<_Tp*> : __cond_value_type<_Tp> {};

template <__has_member_value_type _Tp>
struct indirectly_readable_traits<_Tp> : __cond_value_type<typename _Tp::value_type> {};

template <__has_member_element_type _Tp>
struct indirectly_readable_traits<_Tp> : __cond_value_type<typename _Tp::element_type> {};

template <__has_member_value_type _Tp>
  requires __has_member_element_type<_Tp>
struct indirectly_readable_traits<_Tp> {};

template <__has_member_value_type _Tp>
  requires __has_member_element_type<_Tp> &&
           same_as<remove_cv_t<typename _Tp::element_type>, remove_cv_t<typename _Tp::value_type>>
struct indirectly_readable_traits<_Tp> : __cond_value_type<typename _Tp::value_type> {};



}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/disjunction.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/disjunction.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <bool>
struct _OrImpl;

template <>
struct _OrImpl<true> {
  template <class _Res, class _First, class... _Rest>
  using _Result __attribute__((__nodebug__)) =
      typename _OrImpl<!bool(_First::value) && sizeof...(_Rest) != 0>::template _Result<_First, _Rest...>;
};

template <>
struct _OrImpl<false> {
  template <class _Res, class...>
  using _Result = _Res;
};







template <class... _Args>
using _Or __attribute__((__nodebug__)) = typename _OrImpl<sizeof...(_Args) != 0>::template _Result<false_type, _Args...>;



template <class... _Args>
struct disjunction : _Or<_Args...> {};

template <class... _Args>
inline constexpr bool disjunction_v = _Or<_Args...>::value;



}}
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __with_reference = _Tp&;

template <class _Tp>
concept __can_reference = requires { typename __with_reference<_Tp>; };

template <class _Tp>
concept __dereferenceable = requires(_Tp& __t) {
  { *__t } -> __can_reference;
};


template <__dereferenceable _Tp>
using iter_reference_t = decltype(*std::declval<_Tp&>());



template <class _Iter>
struct iterator_traits;

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

struct contiguous_iterator_tag : public random_access_iterator_tag {};


template <class _Iter>
struct __iter_traits_cache {
  using type = _If< __is_primary_template<iterator_traits<_Iter> >::value, _Iter, iterator_traits<_Iter> >;
};
template <class _Iter>
using _ITER_TRAITS = typename __iter_traits_cache<_Iter>::type;

struct __iter_concept_concept_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_concept;
};
struct __iter_concept_category_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_category;
};
struct __iter_concept_random_fallback {
  template <class _Iter>
  using _Apply = __enable_if_t< __is_primary_template<iterator_traits<_Iter> >::value, random_access_iterator_tag >;
};

template <class _Iter, class _Tester>
struct __test_iter_concept : _IsValidExpansion<_Tester::template _Apply, _Iter>, _Tester {};

template <class _Iter>
struct __iter_concept_cache {
  using type = _Or< __test_iter_concept<_Iter, __iter_concept_concept_test>,
                    __test_iter_concept<_Iter, __iter_concept_category_test>,
                    __test_iter_concept<_Iter, __iter_concept_random_fallback> >;
};

template <class _Iter>
using _ITER_CONCEPT = typename __iter_concept_cache<_Iter>::type::template _Apply<_Iter>;

template <class _Tp>
struct __has_iterator_typedefs {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type
  __test(__void_t<typename _Up::iterator_category>* = nullptr,
         __void_t<typename _Up::difference_type>* = nullptr,
         __void_t<typename _Up::value_type>* = nullptr,
         __void_t<typename _Up::reference>* = nullptr,
         __void_t<typename _Up::pointer>* = nullptr);

public:
  static const bool value = decltype(__test<_Tp>(nullptr, nullptr, nullptr, nullptr, nullptr))::value;
};

template <class _Tp>
struct __has_iterator_category {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type __test(typename _Up::iterator_category* = nullptr);

public:
  static const bool value = decltype(__test<_Tp>(nullptr))::value;
};

template <class _Tp>
struct __has_iterator_concept {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type __test(typename _Up::iterator_concept* = nullptr);

public:
  static const bool value = decltype(__test<_Tp>(nullptr))::value;
};






namespace __iterator_traits_detail {
template <class _Ip>
concept __cpp17_iterator = requires(_Ip __i) {
  { *__i } -> __can_reference;
  { ++__i } -> same_as<_Ip&>;
  { *__i++ } -> __can_reference;
} && copyable<_Ip>;

template <class _Ip>
concept __cpp17_input_iterator = __cpp17_iterator<_Ip> && equality_comparable<_Ip> && requires(_Ip __i) {
  typename incrementable_traits<_Ip>::difference_type;
  typename indirectly_readable_traits<_Ip>::value_type;
  typename common_reference_t<iter_reference_t<_Ip>&&, typename indirectly_readable_traits<_Ip>::value_type&>;
  typename common_reference_t<decltype(*__i++)&&, typename indirectly_readable_traits<_Ip>::value_type&>;
  requires signed_integral<typename incrementable_traits<_Ip>::difference_type>;
};

template <class _Ip>
concept __cpp17_forward_iterator =
    __cpp17_input_iterator<_Ip> && constructible_from<_Ip> && is_reference_v<iter_reference_t<_Ip>> &&
    same_as<remove_cvref_t<iter_reference_t<_Ip>>, typename indirectly_readable_traits<_Ip>::value_type> &&
    requires(_Ip __i) {
      { __i++ } -> convertible_to<_Ip const&>;
      { *__i++ } -> same_as<iter_reference_t<_Ip>>;
    };

template <class _Ip>
concept __cpp17_bidirectional_iterator = __cpp17_forward_iterator<_Ip> && requires(_Ip __i) {
  { --__i } -> same_as<_Ip&>;
  { __i-- } -> convertible_to<_Ip const&>;
  { *__i-- } -> same_as<iter_reference_t<_Ip>>;
};

template <class _Ip>
concept __cpp17_random_access_iterator =
    __cpp17_bidirectional_iterator<_Ip> && totally_ordered<_Ip> &&
    requires(_Ip __i, typename incrementable_traits<_Ip>::difference_type __n) {
      { __i += __n } -> same_as<_Ip&>;
      { __i -= __n } -> same_as<_Ip&>;
      { __i + __n } -> same_as<_Ip>;
      { __n + __i } -> same_as<_Ip>;
      { __i - __n } -> same_as<_Ip>;
      { __i - __i } -> same_as<decltype(__n)>;
      { __i[__n] } -> convertible_to<iter_reference_t<_Ip>>;
    };
}

template <class _Ip>
concept __has_member_reference = requires { typename _Ip::reference; };

template <class _Ip>
concept __has_member_pointer = requires { typename _Ip::pointer; };

template <class _Ip>
concept __has_member_iterator_category = requires { typename _Ip::iterator_category; };

template <class _Ip>
concept __specifies_members = requires {
  typename _Ip::value_type;
  typename _Ip::difference_type;
  requires __has_member_reference<_Ip>;
  requires __has_member_iterator_category<_Ip>;
};

template <class>
struct __iterator_traits_member_pointer_or_void {
  using type = void;
};

template <__has_member_pointer _Tp>
struct __iterator_traits_member_pointer_or_void<_Tp> {
  using type = typename _Tp::pointer;
};

template <class _Tp>
concept __cpp17_iterator_missing_members = !__specifies_members<_Tp> && __iterator_traits_detail::__cpp17_iterator<_Tp>;

template <class _Tp>
concept __cpp17_input_iterator_missing_members =
    __cpp17_iterator_missing_members<_Tp> && __iterator_traits_detail::__cpp17_input_iterator<_Tp>;


template <class>
struct __iterator_traits_member_pointer_or_arrow_or_void {
  using type = void;
};



template <__has_member_pointer _Ip>
struct __iterator_traits_member_pointer_or_arrow_or_void<_Ip> {
  using type = typename _Ip::pointer;
};



template <class _Ip>
  requires requires(_Ip& __i) { __i.operator->(); } && (!__has_member_pointer<_Ip>)
struct __iterator_traits_member_pointer_or_arrow_or_void<_Ip> {
  using type = decltype(std::declval<_Ip&>().operator->());
};


template <class _Ip>
struct __iterator_traits_member_reference {
  using type = iter_reference_t<_Ip>;
};



template <__has_member_reference _Ip>
struct __iterator_traits_member_reference<_Ip> {
  using type = typename _Ip::reference;
};



template <class _Ip>
struct __deduce_iterator_category {
  using type = input_iterator_tag;
};



template <__iterator_traits_detail::__cpp17_random_access_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = random_access_iterator_tag;
};



template <__iterator_traits_detail::__cpp17_bidirectional_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = bidirectional_iterator_tag;
};



template <__iterator_traits_detail::__cpp17_forward_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = forward_iterator_tag;
};

template <class _Ip>
struct __iterator_traits_iterator_category : __deduce_iterator_category<_Ip> {};




template <__has_member_iterator_category _Ip>
struct __iterator_traits_iterator_category<_Ip> {
  using type = typename _Ip::iterator_category;
};


template <class>
struct __iterator_traits_difference_type {
  using type = void;
};



template <class _Ip>
  requires requires { typename incrementable_traits<_Ip>::difference_type; }
struct __iterator_traits_difference_type<_Ip> {
  using type = typename incrementable_traits<_Ip>::difference_type;
};



template <class>
struct __iterator_traits {};




template <__specifies_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = typename _Ip::iterator_category;
  using value_type = typename _Ip::value_type;
  using difference_type = typename _Ip::difference_type;
  using pointer = typename __iterator_traits_member_pointer_or_void<_Ip>::type;
  using reference = typename _Ip::reference;
};




template <__cpp17_input_iterator_missing_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = typename __iterator_traits_iterator_category<_Ip>::type;
  using value_type = typename indirectly_readable_traits<_Ip>::value_type;
  using difference_type = typename incrementable_traits<_Ip>::difference_type;
  using pointer = typename __iterator_traits_member_pointer_or_arrow_or_void<_Ip>::type;
  using reference = typename __iterator_traits_member_reference<_Ip>::type;
};



template <__cpp17_iterator_missing_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = output_iterator_tag;
  using value_type = void;
  using difference_type = typename __iterator_traits_difference_type<_Ip>::type;
  using pointer = void;
  using reference = void;
};

template <class _Ip>
struct iterator_traits : __iterator_traits<_Ip> {
  using __primary_template = iterator_traits;
};
# 403 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Tp>

  requires is_object_v<_Tp>

struct iterator_traits<_Tp*> {
  typedef ptrdiff_t difference_type;
  typedef __remove_cv_t<_Tp> value_type;
  typedef _Tp* pointer;
  typedef _Tp& reference;
  typedef random_access_iterator_tag iterator_category;

  typedef contiguous_iterator_tag iterator_concept;

};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to : is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up> {
};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up, bool = __has_iterator_concept<_Tp>::value>
struct __has_iterator_concept_convertible_to : is_convertible<typename _Tp::iterator_concept, _Up> {};

template <class _Tp, class _Up>
struct __has_iterator_concept_convertible_to<_Tp, _Up, false> : false_type {};

template <class _Tp>
using __has_input_iterator_category = __has_iterator_category_convertible_to<_Tp, input_iterator_tag>;

template <class _Tp>
using __has_forward_iterator_category = __has_iterator_category_convertible_to<_Tp, forward_iterator_tag>;

template <class _Tp>
using __has_bidirectional_iterator_category = __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>;

template <class _Tp>
using __has_random_access_iterator_category = __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag>;
# 451 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Tp>
struct __libcpp_is_contiguous_iterator
    : _Or< __has_iterator_category_convertible_to<_Tp, contiguous_iterator_tag>,
           __has_iterator_concept_convertible_to<_Tp, contiguous_iterator_tag> > {};






template <class _Up>
struct __libcpp_is_contiguous_iterator<_Up*> : true_type {};

template <class _Iter>
class __wrap_iter;

template <class _Tp>
using __has_exactly_input_iterator_category =
    integral_constant<bool,
                      __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
                          !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value>;

template <class _Tp>
using __has_exactly_forward_iterator_category =
    integral_constant<bool,
                      __has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value &&
                          !__has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value>;

template <class _Tp>
using __has_exactly_bidirectional_iterator_category =
    integral_constant<bool,
                      __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value &&
                          !__has_iterator_category_convertible_to<_Tp, random_access_iterator_tag>::value>;

template <class _InputIterator>
using __iter_value_type = typename iterator_traits<_InputIterator>::value_type;

template <class _InputIterator>
using __iter_key_type = __remove_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>;

template <class _InputIterator>
using __iter_mapped_type = typename iterator_traits<_InputIterator>::value_type::second_type;

template <class _InputIterator>
using __iter_to_alloc_type =
    pair< typename add_const<typename iterator_traits<_InputIterator>::value_type::first_type>::type,
          typename iterator_traits<_InputIterator>::value_type::second_type>;

template <class _Iter>
using __iterator_category_type = typename iterator_traits<_Iter>::iterator_category;

template <class _Iter>
using __iterator_pointer_type = typename iterator_traits<_Iter>::pointer;

template <class _Iter>
using __iter_diff_t = typename iterator_traits<_Iter>::difference_type;

template <class _Iter>
using __iter_reference = typename iterator_traits<_Iter>::reference;
# 519 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Ip>
using iter_value_t =
    typename conditional_t<__is_primary_template<iterator_traits<remove_cvref_t<_Ip> > >::value,
                           indirectly_readable_traits<remove_cvref_t<_Ip> >,
                           iterator_traits<remove_cvref_t<_Ip> > >::value_type;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/addressof.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/addressof.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
inline constexpr __attribute__((__no_sanitize__("cfi"))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp* addressof(_Tp& __x) noexcept {
  return __builtin_addressof(__x);
}
# 55 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/addressof.h" 3
template <class _Tp>
_Tp* addressof(const _Tp&&) noexcept = delete;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/conjunction.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/conjunction.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class...>
using __expand_to_true = true_type;

template <class... _Pred>
__expand_to_true<__enable_if_t<_Pred::value>...> __and_helper(int);

template <class...>
false_type __and_helper(...);






template <class... _Pred>
using _And __attribute__((__nodebug__)) = decltype(std::__and_helper<_Pred...>(0));



template <class...>
struct conjunction : true_type {};

template <class _Arg>
struct conjunction<_Arg> : _Arg {};

template <class _Arg, class... _Args>
struct conjunction<_Arg, _Args...> : conditional_t<!bool(_Arg::value), _Arg, conjunction<_Args...>> {};

template <class... _Args>
inline constexpr bool conjunction_v = conjunction<_Args...>::value;



}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 2 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class = void>
struct __has_element_type : false_type {};

template <class _Tp>
struct __has_element_type<_Tp, __void_t<typename _Tp::element_type> > : true_type {};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type {};

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true> {
  typedef __attribute__((__nodebug__)) typename _Ptr::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true> {
  typedef __attribute__((__nodebug__)) typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false> {
  typedef __attribute__((__nodebug__)) _Tp type;
};

template <class _Tp, class = void>
struct __has_difference_type : false_type {};

template <class _Tp>
struct __has_difference_type<_Tp, __void_t<typename _Tp::difference_type> > : true_type {};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type {
  typedef __attribute__((__nodebug__)) ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true> {
  typedef __attribute__((__nodebug__)) typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind {
private:
  template <class _Xp>
  static false_type __test(...);
#pragma GCC diagnostic push
# 76 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 76 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template <class _Xp>
  static true_type __test(typename _Xp::template rebind<_Up>* = 0);
#pragma GCC diagnostic pop

public:
  static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind {

  typedef __attribute__((__nodebug__)) typename _Tp::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class... _Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true> {

  typedef __attribute__((__nodebug__)) typename _Sp<_Tp, _Args...>::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class... _Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false> {
  typedef _Sp<_Up, _Args...> type;
};

template <class _Ptr, class = void>
struct __pointer_traits_impl {};

template <class _Ptr>
struct __pointer_traits_impl<_Ptr, __void_t<typename __pointer_traits_element_type<_Ptr>::type> > {
  typedef _Ptr pointer;
  typedef typename __pointer_traits_element_type<pointer>::type element_type;
  typedef typename __pointer_traits_difference_type<pointer>::type difference_type;


  template <class _Up>
  using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;







private:
  struct __nat {};

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static pointer
  pointer_to(__conditional_t<is_void<element_type>::value, __nat, element_type>& __r) {
    return pointer::pointer_to(__r);
  }
};

template <class _Ptr>
struct pointer_traits : __pointer_traits_impl<_Ptr> {};

template <class _Tp>
struct pointer_traits<_Tp*> {
  typedef _Tp* pointer;
  typedef _Tp element_type;
  typedef ptrdiff_t difference_type;


  template <class _Up>
  using rebind = _Up*;







private:
  struct __nat {};

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static pointer
  pointer_to(__conditional_t<is_void<element_type>::value, __nat, element_type>& __r) noexcept {
    return std::addressof(__r);
  }
};


template <class _From, class _To>
using __rebind_pointer_t = typename pointer_traits<_From>::template rebind<_To>;







template <class _Pointer, class = void>
struct __to_address_helper;

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* __to_address(_Tp* __p) noexcept {
  static_assert(!is_function<_Tp>::value, "_Tp is a function type");
  return __p;
}

template <class _Pointer, class = void>
struct _HasToAddress : false_type {};

template <class _Pointer>
struct _HasToAddress<_Pointer, decltype((void)pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>())) >
    : true_type {};

template <class _Pointer, class = void>
struct _HasArrow : false_type {};

template <class _Pointer>
struct _HasArrow<_Pointer, decltype((void)std::declval<const _Pointer&>().operator->()) > : true_type {};

template <class _Pointer>
struct _IsFancyPointer {
  static const bool value = _HasArrow<_Pointer>::value || _HasToAddress<_Pointer>::value;
};


template <class _Pointer, __enable_if_t< _And<is_class<_Pointer>, _IsFancyPointer<_Pointer> >::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
    __decay_t<decltype(__to_address_helper<_Pointer>::__call(std::declval<const _Pointer&>()))>
    __to_address(const _Pointer& __p) noexcept {
  return __to_address_helper<_Pointer>::__call(__p);
}

template <class _Pointer, class>
struct __to_address_helper {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static decltype(std::__to_address(
      std::declval<const _Pointer&>().operator->()))
  __call(const _Pointer& __p) noexcept {
    return std::__to_address(__p.operator->());
  }
};

template <class _Pointer>
struct __to_address_helper<_Pointer,
                           decltype((void)pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>()))> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static decltype(pointer_traits<_Pointer>::to_address(
      std::declval<const _Pointer&>()))
  __call(const _Pointer& __p) noexcept {
    return pointer_traits<_Pointer>::to_address(__p);
  }
};


template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto to_address(_Tp* __p) noexcept {
  return std::__to_address(__p);
}

template <class _Pointer>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto to_address(const _Pointer& __p) noexcept
    -> decltype(std::__to_address(__p)) {
  return std::__to_address(__p);
}


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 3
template <class _Iter, bool = __libcpp_is_contiguous_iterator<_Iter>::value>
struct __unwrap_iter_impl {
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter __rewrap(_Iter, _Iter __iter) { return __iter; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter __unwrap(_Iter __i) noexcept { return __i; }
};





template <class _Iter>
struct __unwrap_iter_impl<_Iter, true> {
  using _ToAddressT = decltype(std::__to_address(std::declval<_Iter>()));

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter __rewrap(_Iter __orig_iter, _ToAddressT __unwrapped_iter) {
    return __orig_iter + (__unwrapped_iter - std::__to_address(__orig_iter));
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ToAddressT __unwrap(_Iter __i) noexcept {
    return std::__to_address(__i);
  }
};

template <class _Iter,
          class _Impl = __unwrap_iter_impl<_Iter>,
          __enable_if_t<is_copy_constructible<_Iter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(_Impl::__unwrap(std::declval<_Iter>()))
__unwrap_iter(_Iter __i) noexcept {
  return _Impl::__unwrap(__i);
}



template <class _Iter, __enable_if_t<!is_copy_constructible<_Iter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter __unwrap_iter(_Iter __i) noexcept {
  return __i;
}


template <class _OrigIter, class _Iter, class _Impl = __unwrap_iter_impl<_OrigIter> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _OrigIter __rewrap_iter(_OrigIter __orig_iter, _Iter __iter) noexcept {
  return _Impl::__rewrap(std::move(__orig_iter), std::move(__iter));
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/identity.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/identity.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/functional.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/functional.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class>
struct hash;

template <class>
class reference_wrapper;

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/identity.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/identity.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __is_identity : false_type {};

struct __identity {
  template <class _Tp>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp&& operator()(_Tp&& __t) const noexcept {
    return std::forward<_Tp>(__t);
  }

  using is_transparent = void;
};

template <>
struct __is_identity<__identity> : true_type {};
template <>
struct __is_identity<reference_wrapper<__identity> > : true_type {};
template <>
struct __is_identity<reference_wrapper<const __identity> > : true_type {};



struct identity {
  template <class _Tp>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp&& operator()(_Tp&& __t) const noexcept {
    return std::forward<_Tp>(__t);
  }

  using is_transparent = void;
};

template <>
struct __is_identity<identity> : true_type {};
template <>
struct __is_identity<reference_wrapper<identity> > : true_type {};
template <>
struct __is_identity<reference_wrapper<const identity> > : true_type {};



}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/invoke.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/invoke.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_base_of.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_base_of.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Bp, class _Dp>
struct is_base_of : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};


template <class _Bp, class _Dp>
inline constexpr bool is_base_of_v = __is_base_of(_Bp, _Dp);


}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_core_convertible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_core_convertible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {






template <class _Tp, class _Up, class = void>
struct __is_core_convertible : public false_type {};

template <class _Tp, class _Up>
struct __is_core_convertible<_Tp, _Up, decltype(static_cast<void (*)(_Up)>(0)(static_cast<_Tp (*)()>(0)()))>
    : public true_type {};

}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_object_pointer.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_object_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_member_object_pointer : _BoolConstant<__is_member_object_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_member_object_pointer_v = __is_member_object_pointer(_Tp);
# 44 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_object_pointer.h" 3
}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_reference_wrapper.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_reference_wrapper.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp>
struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp>
struct __is_reference_wrapper : public __is_reference_wrapper_impl<__remove_cv_t<_Tp> > {};

}}
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 2 3
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _DecayedFp>
struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value &&
                  (is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value)>;

template <class _Fp, class _A0, class _DecayFp = __decay_t<_Fp>, class _DecayA0 = __decay_t<_A0> >
using __enable_if_bullet2 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value &&
                  !(is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value) &&
                  !__is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value &&
                  (is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value)>;

template <class _Fp, class _A0, class _DecayFp = __decay_t<_Fp>, class _DecayA0 = __decay_t<_A0> >
using __enable_if_bullet5 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value &&
                  !(is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value) &&
                  !__is_reference_wrapper<_DecayA0>::value>;





template <class... _Args>
__nat __invoke(_Args&&... __args);




template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet1<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype((std::declval<_A0>().*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
    noexcept(noexcept((static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...)))
               { return (static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet2<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype((std::declval<_A0>().get().*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
    noexcept(noexcept((__a0.get().*__f)(static_cast<_Args&&>(__args)...)))
               { return (__a0.get().*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet3<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype(((*std::declval<_A0>()).*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
    noexcept(noexcept(((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...)))
               { return ((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...); }



template <class _Fp, class _A0, class = __enable_if_bullet4<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype(std::declval<_A0>().*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept(static_cast<_A0&&>(__a0).*__f))
               { return static_cast<_A0&&>(__a0).*__f; }

template <class _Fp, class _A0, class = __enable_if_bullet5<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype(std::declval<_A0>().get().*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept(__a0.get().*__f))
               { return __a0.get().*__f; }

template <class _Fp, class _A0, class = __enable_if_bullet6<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype((*std::declval<_A0>()).*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept((*static_cast<_A0&&>(__a0)).*__f))
               { return (*static_cast<_A0&&>(__a0)).*__f; }



template <class _Fp, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype(std::declval<_Fp>()(std::declval<_Args>()...))
__invoke(_Fp&& __f, _Args&&... __args)
    noexcept(noexcept(static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...)))
               { return static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...); }



template <class _Ret, class _Fp, class... _Args>
struct __invokable_r {
  template <class _XFp, class... _XArgs>
  static decltype(std::__invoke(std::declval<_XFp>(), std::declval<_XArgs>()...)) __try_call(int);
  template <class _XFp, class... _XArgs>
  static __nat __try_call(...);



  using _Result = decltype(__try_call<_Fp, _Args...>(0));

  using type = __conditional_t<_IsNotSame<_Result, __nat>::value,
                               __conditional_t<is_void<_Ret>::value, true_type, __is_core_convertible<_Result, _Ret> >,
                               false_type>;
  static const bool value = type::value;
};
template <class _Fp, class... _Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...> {
  typedef __nothrow_invokable_r_imp _ThisT;

  template <class _Tp>
  static void __test_noexcept(_Tp) noexcept;




  static const bool value =
      noexcept(_ThisT::__test_noexcept<_Ret>(std::__invoke(std::declval<_Fp>(), std::declval<_Args>()...)));

};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...> {



  static const bool value = noexcept(std::__invoke(std::declval<_Fp>(), std::declval<_Args>()...));

};

template <class _Ret, class _Fp, class... _Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<__invokable_r<_Ret, _Fp, _Args...>::value, is_void<_Ret>::value, _Ret, _Fp, _Args...>;

template <class _Fp, class... _Args>
using __nothrow_invokable = __nothrow_invokable_r_imp<__invokable<_Fp, _Args...>::value, true, void, _Fp, _Args...>;

template <class _Fp, class... _Args>
struct __invoke_of
    : public enable_if<__invokable<_Fp, _Args...>::value, typename __invokable_r<void, _Fp, _Args...>::_Result> {};

template <class _Ret, bool = is_void<_Ret>::value>
struct __invoke_void_return_wrapper {
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static _Ret __call(_Args&&... __args) {
    return std::__invoke(std::forward<_Args>(__args)...);
  }
};

template <class _Ret>
struct __invoke_void_return_wrapper<_Ret, true> {
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void __call(_Args&&... __args) {
    std::__invoke(std::forward<_Args>(__args)...);
  }
};





template <class _Fn, class... _Args>
struct is_invocable : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};

template <class _Ret, class _Fn, class... _Args>
struct is_invocable_r : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};

template <class _Fn, class... _Args>
inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;

template <class _Ret, class _Fn, class... _Args>
inline constexpr bool is_invocable_r_v = is_invocable_r<_Ret, _Fn, _Args...>::value;



template <class _Fn, class... _Args>
struct is_nothrow_invocable : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {
};

template <class _Ret, class _Fn, class... _Args>
struct is_nothrow_invocable_r
    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};

template <class _Fn, class... _Args>
inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _Args...>::value;

template <class _Ret, class _Fn, class... _Args>
inline constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;

template <class _Fn, class... _Args>
struct invoke_result : __invoke_of<_Fn, _Args...> {};

template <class _Fn, class... _Args>
using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/invoke.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/invoke.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Fn, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr invoke_result_t<_Fn, _Args...>
invoke(_Fn&& __f, _Args&&... __args) noexcept(is_nothrow_invocable_v<_Fn, _Args...>) {
  return std::__invoke(std::forward<_Fn>(__f), std::forward<_Args>(__args)...);
}




template <class _Result, class _Fn, class... _Args>
  requires is_invocable_r_v<_Result, _Fn, _Args...>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Result
invoke_r(_Fn&& __f, _Args&&... __args) noexcept(is_nothrow_invocable_r_v<_Result, _Fn, _Args...>) {
  if constexpr (is_void_v<_Result>) {
    static_cast<void>(std::invoke(std::forward<_Fn>(__f), std::forward<_Args>(__args)...));
  } else {



    static_assert(true,
                  "Returning from invoke_r would bind a temporary object to the reference return type, "
                  "which would result in a dangling reference.");
    return std::invoke(std::forward<_Fn>(__f), std::forward<_Args>(__args)...);
  }
}


}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/derived_from.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/derived_from.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Dp, class _Bp>
concept derived_from = is_base_of_v<_Bp, _Dp> && is_convertible_v<const volatile _Dp*, const volatile _Bp*>;



}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/invocable.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/invocable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Fn, class... _Args>
concept invocable = requires(_Fn&& __fn, _Args&&... __args) {
  std::invoke(std::forward<_Fn>(__fn), std::forward<_Args>(__args)...);
};



template <class _Fn, class... _Args>
concept regular_invocable = invocable<_Fn, _Args...>;



}}
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/predicate.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/predicate.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Fn, class... _Args>
concept predicate = regular_invocable<_Fn, _Args...> && __boolean_testable<invoke_result_t<_Fn, _Args...>>;



}}
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/regular.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/regular.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/semiregular.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/semiregular.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept semiregular = copyable<_Tp> && default_initializable<_Tp>;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/regular.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/regular.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept regular = semiregular<_Tp> && equality_comparable<_Tp>;



}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/relation.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/relation.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Rp, class _Tp, class _Up>
concept relation =
    predicate<_Rp, _Tp, _Tp> && predicate<_Rp, _Up, _Up> && predicate<_Rp, _Tp, _Up> && predicate<_Rp, _Up, _Tp>;



template <class _Rp, class _Tp, class _Up>
concept equivalence_relation = relation<_Rp, _Tp, _Up>;



template <class _Rp, class _Tp, class _Up>
concept strict_weak_order = relation<_Rp, _Tp, _Up>;



}}
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3






# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_move.h" 1 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_move.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_move.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





namespace ranges {
namespace __iter_move {

void iter_move();

template <class _Tp>
concept __unqualified_iter_move = __class_or_enum<remove_cvref_t<_Tp>> && requires(_Tp&& __t) {

  iter_move(std::forward<_Tp>(__t));
};

template <class _Tp>
concept __move_deref = !__unqualified_iter_move<_Tp> && requires(_Tp&& __t) {
  *__t;
  requires is_lvalue_reference_v<decltype(*__t)>;
};

template <class _Tp>
concept __just_deref = !__unqualified_iter_move<_Tp> && !__move_deref<_Tp> && requires(_Tp&& __t) {
  *__t;
  requires(!is_lvalue_reference_v<decltype(*__t)>);
};



struct __fn {

  template <class _Ip>
    requires __unqualified_iter_move<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) operator()(_Ip&& __i) const
      noexcept(noexcept(iter_move(std::forward<_Ip>(__i)))) {
    return iter_move(std::forward<_Ip>(__i));
  }


  template <class _Ip>
    requires __move_deref<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Ip&& __i) const
      noexcept(noexcept(std::move(*std::forward<_Ip>(__i)))) -> decltype(std::move(*std::forward<_Ip>(__i))) {
    return std::move(*std::forward<_Ip>(__i));
  }

  template <class _Ip>
    requires __just_deref<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Ip&& __i) const
      noexcept(noexcept(*std::forward<_Ip>(__i))) -> decltype(*std::forward<_Ip>(__i)) {
    return *std::forward<_Ip>(__i);
  }
};
}

inline namespace __cpo {
inline constexpr auto iter_move = __iter_move::__fn{};
}
}

template <__dereferenceable _Tp>
  requires requires(_Tp& __t) {
    { ranges::iter_move(__t) } -> __can_reference;
  }
using iter_rvalue_reference_t = decltype(ranges::iter_move(std::declval<_Tp&>()));



}}
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class _In>
concept __indirectly_readable_impl =
    requires(const _In __i) {
      typename iter_value_t<_In>;
      typename iter_reference_t<_In>;
      typename iter_rvalue_reference_t<_In>;
      { *__i } -> same_as<iter_reference_t<_In>>;
      { ranges::iter_move(__i) } -> same_as<iter_rvalue_reference_t<_In>>;
    } && common_reference_with<iter_reference_t<_In>&&, iter_value_t<_In>&> &&
    common_reference_with<iter_reference_t<_In>&&, iter_rvalue_reference_t<_In>&&> &&
    common_reference_with<iter_rvalue_reference_t<_In>&&, const iter_value_t<_In>&>;

template <class _In>
concept indirectly_readable = __indirectly_readable_impl<remove_cvref_t<_In>>;

template <indirectly_readable _Tp>
using iter_common_reference_t = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp>&>;


template <class _Out, class _Tp>
concept indirectly_writable = requires(_Out&& __o, _Tp&& __t) {
  *__o = std::forward<_Tp>(__t);
  *std::forward<_Out>(__o) = std::forward<_Tp>(__t);
  const_cast<const iter_reference_t<_Out>&&>(*__o) = std::forward<_Tp>(__t);
  const_cast<const iter_reference_t<_Out>&&>(*std::forward<_Out>(__o)) =
      std::forward<_Tp>(__t);
};


template <class _Tp>
concept __integer_like = integral<_Tp> && !same_as<_Tp, bool>;

template <class _Tp>
concept __signed_integer_like = signed_integral<_Tp>;

template <class _Ip>
concept weakly_incrementable =

    !same_as<_Ip, bool> &&
    movable<_Ip> && requires(_Ip __i) {
      typename iter_difference_t<_Ip>;
      requires __signed_integer_like<iter_difference_t<_Ip>>;
      { ++__i } -> same_as<_Ip&>;
      __i++;
    };


template <class _Ip>
concept incrementable = regular<_Ip> && weakly_incrementable<_Ip> && requires(_Ip __i) {
  { __i++ } -> same_as<_Ip>;
};


template <class _Ip>
concept input_or_output_iterator = requires(_Ip __i) {
  { *__i } -> __can_reference;
} && weakly_incrementable<_Ip>;


template <class _Sp, class _Ip>
concept sentinel_for = semiregular<_Sp> && input_or_output_iterator<_Ip> && __weakly_equality_comparable_with<_Sp, _Ip>;

template <class, class>
inline constexpr bool disable_sized_sentinel_for = false;

template <class _Sp, class _Ip>
concept sized_sentinel_for =
    sentinel_for<_Sp, _Ip> && !disable_sized_sentinel_for<remove_cv_t<_Sp>, remove_cv_t<_Ip>> &&
    requires(const _Ip& __i, const _Sp& __s) {
      { __s - __i } -> same_as<iter_difference_t<_Ip>>;
      { __i - __s } -> same_as<iter_difference_t<_Ip>>;
    };


template <class _Ip>
concept input_iterator = input_or_output_iterator<_Ip> && indirectly_readable<_Ip> && requires {
  typename _ITER_CONCEPT<_Ip>;
} && derived_from<_ITER_CONCEPT<_Ip>, input_iterator_tag>;


template <class _Ip, class _Tp>
concept output_iterator =
    input_or_output_iterator<_Ip> && indirectly_writable<_Ip, _Tp> && requires(_Ip __it, _Tp&& __t) {
      *__it++ = std::forward<_Tp>(__t);
    };


template <class _Ip>
concept forward_iterator =
    input_iterator<_Ip> && derived_from<_ITER_CONCEPT<_Ip>, forward_iterator_tag> && incrementable<_Ip> &&
    sentinel_for<_Ip, _Ip>;


template <class _Ip>
concept bidirectional_iterator =
    forward_iterator<_Ip> && derived_from<_ITER_CONCEPT<_Ip>, bidirectional_iterator_tag> && requires(_Ip __i) {
      { --__i } -> same_as<_Ip&>;
      { __i-- } -> same_as<_Ip>;
    };

template <class _Ip>
concept random_access_iterator =
    bidirectional_iterator<_Ip> && derived_from<_ITER_CONCEPT<_Ip>, random_access_iterator_tag> &&
    totally_ordered<_Ip> && sized_sentinel_for<_Ip, _Ip> &&
    requires(_Ip __i, const _Ip __j, const iter_difference_t<_Ip> __n) {
      { __i += __n } -> same_as<_Ip&>;
      { __j + __n } -> same_as<_Ip>;
      { __n + __j } -> same_as<_Ip>;
      { __i -= __n } -> same_as<_Ip&>;
      { __j - __n } -> same_as<_Ip>;
      { __j[__n] } -> same_as<iter_reference_t<_Ip>>;
    };

template <class _Ip>
concept contiguous_iterator =
    random_access_iterator<_Ip> && derived_from<_ITER_CONCEPT<_Ip>, contiguous_iterator_tag> &&
    is_lvalue_reference_v<iter_reference_t<_Ip>> && same_as<iter_value_t<_Ip>, remove_cvref_t<iter_reference_t<_Ip>>> &&
    requires(const _Ip& __i) {
      { std::to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_Ip>>>;
    };

template <class _Ip>
concept __has_arrow = input_iterator<_Ip> && (is_pointer_v<_Ip> || requires(_Ip __i) { __i.operator->(); });


template <class _Fp, class _It>
concept indirectly_unary_invocable =
    indirectly_readable<_It> && copy_constructible<_Fp> && invocable<_Fp&, iter_value_t<_It>&> &&
    invocable<_Fp&, iter_reference_t<_It>> && invocable<_Fp&, iter_common_reference_t<_It>> &&
    common_reference_with< invoke_result_t<_Fp&, iter_value_t<_It>&>, invoke_result_t<_Fp&, iter_reference_t<_It>>>;

template <class _Fp, class _It>
concept indirectly_regular_unary_invocable =
    indirectly_readable<_It> && copy_constructible<_Fp> && regular_invocable<_Fp&, iter_value_t<_It>&> &&
    regular_invocable<_Fp&, iter_reference_t<_It>> && regular_invocable<_Fp&, iter_common_reference_t<_It>> &&
    common_reference_with< invoke_result_t<_Fp&, iter_value_t<_It>&>, invoke_result_t<_Fp&, iter_reference_t<_It>>>;

template <class _Fp, class _It>
concept indirect_unary_predicate =
    indirectly_readable<_It> && copy_constructible<_Fp> && predicate<_Fp&, iter_value_t<_It>&> &&
    predicate<_Fp&, iter_reference_t<_It>> && predicate<_Fp&, iter_common_reference_t<_It>>;

template <class _Fp, class _It1, class _It2>
concept indirect_binary_predicate =
    indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fp> &&
    predicate<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
    predicate<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
    predicate<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
    predicate<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
    predicate<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

template <class _Fp, class _It1, class _It2 = _It1>
concept indirect_equivalence_relation =
    indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fp> &&
    equivalence_relation<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
    equivalence_relation<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
    equivalence_relation<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
    equivalence_relation<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
    equivalence_relation<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

template <class _Fp, class _It1, class _It2 = _It1>
concept indirect_strict_weak_order =
    indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fp> &&
    strict_weak_order<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
    strict_weak_order<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
    strict_weak_order<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
    strict_weak_order<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
    strict_weak_order<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

template <class _Fp, class... _Its>
  requires(indirectly_readable<_Its> && ...) && invocable<_Fp, iter_reference_t<_Its>...>
using indirect_result_t = invoke_result_t<_Fp, iter_reference_t<_Its>...>;

template <class _In, class _Out>
concept indirectly_movable = indirectly_readable<_In> && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;

template <class _In, class _Out>
concept indirectly_movable_storable =
    indirectly_movable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In>> && movable<iter_value_t<_In>> &&
    constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>> &&
    assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;

template <class _In, class _Out>
concept indirectly_copyable = indirectly_readable<_In> && indirectly_writable<_Out, iter_reference_t<_In>>;

template <class _In, class _Out>
concept indirectly_copyable_storable =
    indirectly_copyable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In>&> &&
    indirectly_writable<_Out, const iter_value_t<_In>&> && indirectly_writable<_Out, iter_value_t<_In>&&> &&
    indirectly_writable<_Out, const iter_value_t<_In>&&> && copyable<iter_value_t<_In>> &&
    constructible_from<iter_value_t<_In>, iter_reference_t<_In>> &&
    assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;






template <class _Tp>
using __has_random_access_iterator_category_or_concept

    = integral_constant<bool, random_access_iterator<_Tp>>;




}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/access.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/access.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/enable_borrowed_range.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/enable_borrowed_range.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {



template <class>
inline constexpr bool enable_borrowed_range = false;

}



}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/access.h" 2 3




# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/auto_cast.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/auto_cast.h" 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/access.h" 2 3
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/access.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {
template <class _Tp>
concept __can_borrow = is_lvalue_reference_v<_Tp> || enable_borrowed_range<remove_cvref_t<_Tp>>;
}



namespace ranges {
namespace __begin {
template <class _Tp>
concept __member_begin = __can_borrow<_Tp> && __workaround_52970<_Tp> && requires(_Tp&& __t) {
  { static_cast<::std::__decay_t<decltype((__t.begin()))> >(__t.begin()) } -> input_or_output_iterator;
};

void begin(auto&) = delete;
void begin(const auto&) = delete;

template <class _Tp>
concept __unqualified_begin =
    !__member_begin<_Tp> && __can_borrow<_Tp> && __class_or_enum<remove_cvref_t<_Tp>> && requires(_Tp&& __t) {
      { static_cast<::std::__decay_t<decltype((begin(__t)))> >(begin(__t)) } -> input_or_output_iterator;
    };

struct __fn {
  template <class _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp (&__t)[]) const noexcept
    requires(sizeof(_Tp) >= 0)
  {
    return __t + 0;
  }

  template <class _Tp, size_t _Np>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp (&__t)[_Np]) const noexcept
    requires(sizeof(_Tp) >= 0)
  {
    return __t + 0;
  }

  template <class _Tp>
    requires __member_begin<_Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((__t.begin()))> >(__t.begin()))) {
    return static_cast<::std::__decay_t<decltype((__t.begin()))> >(__t.begin());
  }

  template <class _Tp>
    requires __unqualified_begin<_Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((begin(__t)))> >(begin(__t)))) {
    return static_cast<::std::__decay_t<decltype((begin(__t)))> >(begin(__t));
  }

  void operator()(auto&&) const = delete;
};
}

inline namespace __cpo {
inline constexpr auto begin = __begin::__fn{};
}
}



namespace ranges {
template <class _Tp>
using iterator_t = decltype(ranges::begin(std::declval<_Tp&>()));
}



namespace ranges {
namespace __end {
template <class _Tp>
concept __member_end = __can_borrow<_Tp> && __workaround_52970<_Tp> && requires(_Tp&& __t) {
  typename iterator_t<_Tp>;
  { static_cast<::std::__decay_t<decltype((__t.end()))> >(__t.end()) } -> sentinel_for<iterator_t<_Tp>>;
};

void end(auto&) = delete;
void end(const auto&) = delete;

template <class _Tp>
concept __unqualified_end =
    !__member_end<_Tp> && __can_borrow<_Tp> && __class_or_enum<remove_cvref_t<_Tp>> && requires(_Tp&& __t) {
      typename iterator_t<_Tp>;
      { static_cast<::std::__decay_t<decltype((end(__t)))> >(end(__t)) } -> sentinel_for<iterator_t<_Tp>>;
    };

struct __fn {
  template <class _Tp, size_t _Np>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp (&__t)[_Np]) const noexcept
    requires(sizeof(_Tp) >= 0)
  {
    return __t + _Np;
  }

  template <class _Tp>
    requires __member_end<_Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((__t.end()))> >(__t.end()))) {
    return static_cast<::std::__decay_t<decltype((__t.end()))> >(__t.end());
  }

  template <class _Tp>
    requires __unqualified_end<_Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((end(__t)))> >(end(__t)))) {
    return static_cast<::std::__decay_t<decltype((end(__t)))> >(end(__t));
  }

  void operator()(auto&&) const = delete;
};
}

inline namespace __cpo {
inline constexpr auto end = __end::__fn{};
}
}



namespace ranges {
namespace __cbegin {
struct __fn {
  template <class _Tp>
    requires is_lvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t))))
          -> decltype(ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t))) {
    return ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t));
  }

  template <class _Tp>
    requires is_rvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::begin(static_cast<const _Tp&&>(__t))))
          -> decltype(ranges::begin(static_cast<const _Tp&&>(__t))) {
    return ranges::begin(static_cast<const _Tp&&>(__t));
  }
};
}

inline namespace __cpo {
inline constexpr auto cbegin = __cbegin::__fn{};
}
}



namespace ranges {
namespace __cend {
struct __fn {
  template <class _Tp>
    requires is_lvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t))))
          -> decltype(ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t))) {
    return ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t));
  }

  template <class _Tp>
    requires is_rvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::end(static_cast<const _Tp&&>(__t))))
          -> decltype(ranges::end(static_cast<const _Tp&&>(__t))) {
    return ranges::end(static_cast<const _Tp&&>(__t));
  }
};
}

inline namespace __cpo {
inline constexpr auto cend = __cend::__fn{};
}
}



}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/data.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/data.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_pointer.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_pointer {
  using type __attribute__((__nodebug__)) = __remove_pointer(_Tp);
};

template <class _Tp>
using __remove_pointer_t = __remove_pointer(_Tp);
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_pointer.h" 3
template <class _Tp>
using remove_pointer_t = __remove_pointer_t<_Tp>;


}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/data.h" 2 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/data.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





namespace ranges {
namespace __data {
template <class _Tp>
concept __ptr_to_object = is_pointer_v<_Tp> && is_object_v<remove_pointer_t<_Tp>>;

template <class _Tp>
concept __member_data = __can_borrow<_Tp> && __workaround_52970<_Tp> && requires(_Tp&& __t) {
  { static_cast<::std::__decay_t<decltype((__t.data()))> >(__t.data()) } -> __ptr_to_object;
};

template <class _Tp>
concept __ranges_begin_invocable = !__member_data<_Tp> && __can_borrow<_Tp> && requires(_Tp&& __t) {
  { ranges::begin(__t) } -> contiguous_iterator;
};

struct __fn {
  template <__member_data _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const noexcept(noexcept(__t.data())) {
    return __t.data();
  }

  template <__ranges_begin_invocable _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(std::to_address(ranges::begin(__t)))) {
    return std::to_address(ranges::begin(__t));
  }
};
}

inline namespace __cpo {
inline constexpr auto data = __data::__fn{};
}
}



namespace ranges {
namespace __cdata {
struct __fn {
  template <class _Tp>
    requires is_lvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t))))
          -> decltype(ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t))) {
    return ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t));
  }

  template <class _Tp>
    requires is_rvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::data(static_cast<const _Tp&&>(__t))))
          -> decltype(ranges::data(static_cast<const _Tp&&>(__t))) {
    return ranges::data(static_cast<const _Tp&&>(__t));
  }
};
}

inline namespace __cpo {
inline constexpr auto cdata = __cdata::__fn{};
}
}



}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/enable_view.h" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/enable_view.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {

struct view_base {};

template <class _Derived>
  requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
class view_interface;

template <class _Op, class _Yp>
  requires is_convertible_v<_Op*, view_interface<_Yp>*>
void __is_derived_from_view_interface(const _Op*, const view_interface<_Yp>*);

template <class _Tp>
inline constexpr bool enable_view = derived_from<_Tp, view_base> || requires {
  ranges::__is_derived_from_view_interface((_Tp*)nullptr, (_Tp*)nullptr);
};

}



}}
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/size.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/size.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_unsigned.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_unsigned.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unsigned.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unsigned.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_unsigned : _BoolConstant<__is_unsigned(_Tp)> {};


template <class _Tp>
inline constexpr bool is_unsigned_v = __is_unsigned(_Tp);
# 57 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unsigned.h" 3
}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_unsigned.h" 2 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_unsigned.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __make_unsigned_t = __make_unsigned(_Tp);
# 79 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_unsigned.h" 3
template <class _Tp>
struct make_unsigned {
  using type __attribute__((__nodebug__)) = __make_unsigned_t<_Tp>;
};


template <class _Tp>
using make_unsigned_t = __make_unsigned_t<_Tp>;



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __make_unsigned_t<_Tp> __to_unsigned_like(_Tp __x) noexcept {
  return static_cast<__make_unsigned_t<_Tp> >(__x);
}


template <class _Tp, class _Up>
using __copy_unsigned_t = __conditional_t<is_unsigned<_Tp>::value, __make_unsigned_t<_Up>, _Up>;

}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/size.h" 2 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/size.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {
template <class>
inline constexpr bool disable_sized_range = false;
}



namespace ranges {
namespace __size {
void size(auto&) = delete;
void size(const auto&) = delete;

template <class _Tp>
concept __size_enabled = !disable_sized_range<remove_cvref_t<_Tp>>;

template <class _Tp>
concept __member_size = __size_enabled<_Tp> && __workaround_52970<_Tp> && requires(_Tp&& __t) {
  { static_cast<::std::__decay_t<decltype((__t.size()))> >(__t.size()) } -> __integer_like;
};

template <class _Tp>
concept __unqualified_size =
    __size_enabled<_Tp> && !__member_size<_Tp> && __class_or_enum<remove_cvref_t<_Tp>> && requires(_Tp&& __t) {
      { static_cast<::std::__decay_t<decltype((size(__t)))> >(size(__t)) } -> __integer_like;
    };

template <class _Tp>
concept __difference =
    !__member_size<_Tp> && !__unqualified_size<_Tp> && __class_or_enum<remove_cvref_t<_Tp>> && requires(_Tp&& __t) {
      { ranges::begin(__t) } -> forward_iterator;
      { ranges::end(__t) } -> sized_sentinel_for<decltype(ranges::begin(std::declval<_Tp>()))>;
    };

struct __fn {

  template <class _Tp, size_t _Sz>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t operator()(_Tp (&&)[_Sz]) const noexcept {
    return _Sz;
  }


  template <class _Tp, size_t _Sz>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t operator()(_Tp (&)[_Sz]) const noexcept {
    return _Sz;
  }


  template <__member_size _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __integer_like auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((__t.size()))> >(__t.size()))) {
    return static_cast<::std::__decay_t<decltype((__t.size()))> >(__t.size());
  }


  template <__unqualified_size _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __integer_like auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((size(__t)))> >(size(__t)))) {
    return static_cast<::std::__decay_t<decltype((size(__t)))> >(size(__t));
  }


  template <__difference _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t))))
          -> decltype(std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t))) {
    return std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t));
  }
};

}

inline namespace __cpo {
inline constexpr auto size = __size::__fn{};
}
}



namespace ranges {
namespace __ssize {
struct __fn {
  template <class _Tp>
    requires requires(_Tp&& __t) { ranges::size(__t); }
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr integral auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::size(__t))) {
    using _Signed = make_signed_t<decltype(ranges::size(__t))>;
    if constexpr (sizeof(ptrdiff_t) > sizeof(_Signed))
      return static_cast<ptrdiff_t>(ranges::size(__t));
    else
      return static_cast<_Signed>(ranges::size(__t));
  }
};
}

inline namespace __cpo {
inline constexpr auto ssize = __ssize::__fn{};
}
}



}}
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 2 3





# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/initializer_list" 1 3
# 50 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/initializer_list" 3


namespace std
{



template <class _Ep>
class initializer_list {
  const _Ep* __begin_;
  size_t __size_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr initializer_list(const _Ep* __b, size_t __s) noexcept
      : __begin_(__b),
        __size_(__s) {}

public:
  typedef _Ep value_type;
  typedef const _Ep& reference;
  typedef const _Ep& const_reference;
  typedef size_t size_type;

  typedef const _Ep* iterator;
  typedef const _Ep* const_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr initializer_list() noexcept : __begin_(nullptr), __size_(0) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t size() const noexcept { return __size_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Ep* begin() const noexcept { return __begin_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Ep* end() const noexcept { return __begin_ + __size_; }
};

template <class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Ep* begin(initializer_list<_Ep> __il) noexcept {
  return __il.begin();
}

template <class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Ep* end(initializer_list<_Ep> __il) noexcept {
  return __il.end();
}



}
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 2 3
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {



template <class _Tp>
concept range = requires(_Tp& __t) {
  ranges::begin(__t);
  ranges::end(__t);
};

template <class _Tp>
concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;

template <class _Range>
concept borrowed_range =
    range<_Range> && (is_lvalue_reference_v<_Range> || enable_borrowed_range<remove_cvref_t<_Range>>);



template <range _Rp>
using sentinel_t = decltype(ranges::end(std::declval<_Rp&>()));

template <range _Rp>
using range_difference_t = iter_difference_t<iterator_t<_Rp>>;

template <range _Rp>
using range_value_t = iter_value_t<iterator_t<_Rp>>;

template <range _Rp>
using range_reference_t = iter_reference_t<iterator_t<_Rp>>;

template <range _Rp>
using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Rp>>;

template <range _Rp>
using range_common_reference_t = iter_common_reference_t<iterator_t<_Rp>>;


template <class _Tp>
concept sized_range = range<_Tp> && requires(_Tp& __t) { ranges::size(__t); };

template <sized_range _Rp>
using range_size_t = decltype(ranges::size(std::declval<_Rp&>()));
# 93 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 3
template <class _Tp>
concept view = range<_Tp> && movable<_Tp> && enable_view<_Tp>;

template <class _Range>
concept __simple_view =
    view<_Range> && range<const _Range> && same_as<iterator_t<_Range>, iterator_t<const _Range>> &&
    same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;


template <class _Rp, class _Tp>
concept output_range = range<_Rp> && output_iterator<iterator_t<_Rp>, _Tp>;

template <class _Tp>
concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;

template <class _Tp>
concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;

template <class _Tp>
concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;

template <class _Tp>
concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
  { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;
};

template <class _Tp>
concept common_range = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;

template <class _Tp>
inline constexpr bool __is_std_initializer_list = false;

template <class _Ep>
inline constexpr bool __is_std_initializer_list<initializer_list<_Ep>> = true;

template <class _Tp>
concept viewable_range =
    range<_Tp> &&
    ((view<remove_cvref_t<_Tp>> && constructible_from<remove_cvref_t<_Tp>, _Tp>) ||
     (!view<remove_cvref_t<_Tp>> &&
      (is_lvalue_reference_v<_Tp> ||
       (movable<remove_reference_t<_Tp>> && !__is_std_initializer_list<remove_cvref_t<_Tp>>))));

}



}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 2 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag) {
  typename iterator_traits<_InputIter>::difference_type __r(0);
  for (; __first != __last; ++__first)
    ++__r;
  return __r;
}

template <class _RandIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag) {
  return __last - __first;
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last) {
  return std::__distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}





namespace ranges {
namespace __distance {

struct __fn {
  template <class _Ip, sentinel_for<_Ip> _Sp>
    requires(!sized_sentinel_for<_Sp, _Ip>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iter_difference_t<_Ip> operator()(_Ip __first, _Sp __last) const {
    iter_difference_t<_Ip> __n = 0;
    while (__first != __last) {
      ++__first;
      ++__n;
    }
    return __n;
  }

  template <class _Ip, sized_sentinel_for<decay_t<_Ip>> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iter_difference_t<_Ip> operator()(_Ip&& __first, _Sp __last) const {
    if constexpr (sized_sentinel_for<_Sp, __remove_cvref_t<_Ip>>) {
      return __last - __first;
    } else {
      return __last - decay_t<_Ip>(__first);
    }
  }

  template <range _Rp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr range_difference_t<_Rp> operator()(_Rp&& __r) const {
    if constexpr (sized_range<_Rp>) {
      return static_cast<range_difference_t<_Rp>>(ranges::size(__r));
    } else {
      return operator()(ranges::begin(__r), ranges::end(__r));
    }
  }
};

}

inline namespace __cpo {
inline constexpr auto distance = __distance::__fn{};
}
}



}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assert" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assert" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assertion_handler" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assertion_handler" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__verbose_abort" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__verbose_abort" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



[[noreturn]] __attribute__((__visibility__("default")))
    __attribute__((__format__(__printf__, 1, 2))) void __libcpp_verbose_abort(const char* __format, ...);
# 51 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__verbose_abort" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assertion_handler" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assertion_handler" 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assert" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assert" 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/access.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/access.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* begin(_Tp (&__array)[_Np]) noexcept {
  return __array;
}

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* end(_Tp (&__array)[_Np]) noexcept {
  return __array + _Np;
}



template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto begin(_Cp& __c) -> decltype(__c.begin()) {
  return __c.begin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto begin(const _Cp& __c) -> decltype(__c.begin()) {
  return __c.begin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto end(_Cp& __c) -> decltype(__c.end()) {
  return __c.end();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto end(const _Cp& __c) -> decltype(__c.end()) {
  return __c.end();
}



template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto cbegin(const _Cp& __c) noexcept(noexcept(std::begin(__c)))
    -> decltype(std::begin(__c)) {
  return std::begin(__c);
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto cend(const _Cp& __c) noexcept(noexcept(std::end(__c))) -> decltype(std::end(__c)) {
  return std::end(__c);
}
# 93 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/access.h" 3
}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/voidify.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/voidify.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <typename _Tp>
__attribute__((__always_inline__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void* __voidify(_Tp& __from) {

  return const_cast<void*>(static_cast<const volatile void*>(std::addressof(__from)));
}

}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 2 3





# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 1 3
# 91 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__exception/exception.h" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__exception/exception.h" 3


namespace std {
# 72 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__exception/exception.h" 3
class __attribute__((__visibility__("default"))) exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) exception() noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) exception(const exception&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) exception& operator=(const exception&) noexcept = default;

  virtual ~exception() noexcept;
  virtual const char* what() const noexcept;
};

class __attribute__((__visibility__("default"))) bad_exception : public exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_exception() noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_exception(const bad_exception&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_exception& operator=(const bad_exception&) noexcept = default;
  ~bad_exception() noexcept override;
  const char* what() const noexcept override;
};


}
# 92 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 2 3
# 105 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
# 119 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
namespace std
{


struct __attribute__((__visibility__("default"))) nothrow_t {
  explicit nothrow_t() = default;
};
extern __attribute__((__visibility__("default"))) const nothrow_t nothrow;

class __attribute__((__visibility__("default"))) bad_alloc : public exception {
public:
  bad_alloc() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_alloc(const bad_alloc&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_alloc& operator=(const bad_alloc&) noexcept = default;
  ~bad_alloc() noexcept override;
  const char* what() const noexcept override;
};

class __attribute__((__visibility__("default"))) bad_array_new_length : public bad_alloc {
public:
  bad_array_new_length() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_array_new_length(const bad_array_new_length&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_array_new_length& operator=(const bad_array_new_length&) noexcept = default;
  ~bad_array_new_length() noexcept override;
  const char* what() const noexcept override;
};

typedef void (*new_handler)();
__attribute__((__visibility__("default"))) new_handler set_new_handler(new_handler) noexcept;
__attribute__((__visibility__("default"))) new_handler get_new_handler() noexcept;
# 170 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
[[noreturn]] __attribute__((__visibility__("default"))) void __throw_bad_alloc();

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_bad_array_new_length() {

  throw bad_array_new_length();



}



enum class align_val_t : size_t {};
# 191 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
struct destroying_delete_t {
  explicit destroying_delete_t() = default;
};
inline constexpr destroying_delete_t destroying_delete{};


}
# 207 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new(std::size_t __sz) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new(std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete(void* __p) noexcept;
__attribute__((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete(void* __p, std::size_t __sz) noexcept;


[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new[](std::size_t __sz) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new[](std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete[](void* __p) noexcept;
__attribute__((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::size_t __sz) noexcept;



[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new(std::size_t __sz, std::align_val_t) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete(void* __p, std::align_val_t) noexcept;
__attribute__((__visibility__("default"))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete(void* __p, std::size_t __sz, std::align_val_t) noexcept;


[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new[](std::size_t __sz, std::align_val_t) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t) noexcept;
__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::size_t __sz, std::align_val_t) noexcept;



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void* operator new(std::size_t, void* __p) noexcept {
  return __p;
}
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void* operator new[](std::size_t, void* __p) noexcept {
  return __p;
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void operator delete(void*, void*) noexcept {}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void operator delete[](void*, void*) noexcept {}



 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool __is_overaligned_for_new(size_t __align) noexcept {

  return __align > 16UL;



}

template <class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void* __libcpp_operator_new(_Args... __args) {

  return __builtin_operator_new(__args...);



}

template <class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __libcpp_operator_delete(_Args... __args) {

  __builtin_operator_delete(__args...);



}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void* __libcpp_allocate(size_t __size, size_t __align) {

  if (__is_overaligned_for_new(__align)) {
    const align_val_t __align_val = static_cast<align_val_t>(__align);
    return __libcpp_operator_new(__size, __align_val);
  }


  (void)__align;
  return __libcpp_operator_new(__size);
}

template <class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __do_deallocate_handle_size(void* __ptr, size_t __size, _Args... __args) {




  return std::__libcpp_operator_delete(__ptr, __size, __args...);

}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) {




  if (__is_overaligned_for_new(__align)) {
    const align_val_t __align_val = static_cast<align_val_t>(__align);
    return __do_deallocate_handle_size(__ptr, __size, __align_val);
  } else {
    return __do_deallocate_handle_size(__ptr, __size);
  }

}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __libcpp_deallocate_unsized(void* __ptr, size_t __align) {




  if (__is_overaligned_for_new(__align)) {
    const align_val_t __align_val = static_cast<align_val_t>(__align);
    return __libcpp_operator_delete(__ptr, __align_val);
  } else {
    return __libcpp_operator_delete(__ptr);
  }

}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* __launder(_Tp* __p) noexcept {
  static_assert(!(is_function<_Tp>::value), "can't launder functions");
  static_assert(!(is_same<void, __remove_cv_t<_Tp> >::value), "can't launder cv-void");
  return __builtin_launder(__p);
}


template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* launder(_Tp* __p) noexcept {
  return std::__launder(__p);
}






inline constexpr size_t hardware_destructive_interference_size = 256;
inline constexpr size_t hardware_constructive_interference_size = 64;





}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 2 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class... _Args, class = decltype(::new(std::declval<void*>()) _Tp(std::declval<_Args>()...))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* construct_at(_Tp* __location, _Args&&... __args) {
  ((void)0);
  return ::new (std::__voidify(*__location)) _Tp(std::forward<_Args>(__args)...);
}



template <class _Tp, class... _Args, class = decltype(::new(std::declval<void*>()) _Tp(std::declval<_Args>()...))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* __construct_at(_Tp* __location, _Args&&... __args) {

  return std::construct_at(__location, std::forward<_Args>(__args)...);




}






template <class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator __destroy(_ForwardIterator, _ForwardIterator);

template <class _Tp, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __destroy_at(_Tp* __loc) {
  ((void)0);
  __loc->~_Tp();
}


template <class _Tp, __enable_if_t<is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __destroy_at(_Tp* __loc) {
  ((void)0);
  std::__destroy(std::begin(*__loc), std::end(*__loc));
}


template <class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
__destroy(_ForwardIterator __first, _ForwardIterator __last) {
  for (; __first != __last; ++__first)
    std::__destroy_at(std::addressof(*__first));
  return __first;
}

template <class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _BidirectionalIterator
__reverse_destroy(_BidirectionalIterator __first, _BidirectionalIterator __last) {
  while (__last != __first) {
    --__last;
    std::__destroy_at(std::addressof(*__last));
  }
  return __last;
}



template <class _Tp, enable_if_t<!is_array_v<_Tp>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void destroy_at(_Tp* __loc) {
  std::__destroy_at(__loc);
}


template <class _Tp, enable_if_t<is_array_v<_Tp>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void destroy_at(_Tp* __loc) {
  std::__destroy_at(__loc);
}


template <class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void destroy(_ForwardIterator __first, _ForwardIterator __last) {
  (void)std::__destroy(std::move(__first), std::move(__last));
}

template <class _ForwardIterator, class _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {
  for (; __n > 0; (void)++__first, --__n)
    std::__destroy_at(std::addressof(*__first));
  return __first;
}



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/datasizeof.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/datasizeof.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_final.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_final.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};


template <class _Tp>
struct is_final : public integral_constant<bool, __is_final(_Tp)> {};



template <class _Tp>
inline constexpr bool is_final_v = __is_final(_Tp);


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/datasizeof.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/datasizeof.h" 3








 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __libcpp_datasizeof {

  static const size_t value = __datasizeof(_Tp);
# 61 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/datasizeof.h" 3
};

}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdint" 1 3
# 145 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdint" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdint.h" 1 3
# 110 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdint.h" 3
# 124 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdint.h" 3
# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/stdint.h" 1 3
# 56 "/data/data/com.termux/files/usr/lib/clang/21/include/stdint.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/stdint.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/stdint.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/wchar_limits.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/stdint.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/stdint.h" 2 3 4

typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;

typedef long __int64_t;
typedef unsigned long __uint64_t;






typedef long __intptr_t;
typedef unsigned long __uintptr_t;





typedef __int8_t int8_t;
typedef __uint8_t uint8_t;

typedef __int16_t int16_t;
typedef __uint16_t uint16_t;

typedef __int32_t int32_t;
typedef __uint32_t uint32_t;

typedef __int64_t int64_t;
typedef __uint64_t uint64_t;

typedef __intptr_t intptr_t;
typedef __uintptr_t uintptr_t;

typedef int8_t int_least8_t;
typedef uint8_t uint_least8_t;

typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;

typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;

typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;

typedef int8_t int_fast8_t;
typedef uint8_t uint_fast8_t;

typedef int64_t int_fast64_t;
typedef uint64_t uint_fast64_t;


typedef int64_t int_fast16_t;
typedef uint64_t uint_fast16_t;
typedef int64_t int_fast32_t;
typedef uint64_t uint_fast32_t;







typedef uint64_t uintmax_t;
typedef int64_t intmax_t;
# 57 "/data/data/com.termux/files/usr/lib/clang/21/include/stdint.h" 2 3
# 125 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdint.h" 2 3
# 146 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdint" 2 3
# 157 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdint" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

using ::int8_t __attribute__((__using_if_exists__));
using ::int16_t __attribute__((__using_if_exists__));
using ::int32_t __attribute__((__using_if_exists__));
using ::int64_t __attribute__((__using_if_exists__));

using ::uint8_t __attribute__((__using_if_exists__));
using ::uint16_t __attribute__((__using_if_exists__));
using ::uint32_t __attribute__((__using_if_exists__));
using ::uint64_t __attribute__((__using_if_exists__));

using ::int_least8_t __attribute__((__using_if_exists__));
using ::int_least16_t __attribute__((__using_if_exists__));
using ::int_least32_t __attribute__((__using_if_exists__));
using ::int_least64_t __attribute__((__using_if_exists__));

using ::uint_least8_t __attribute__((__using_if_exists__));
using ::uint_least16_t __attribute__((__using_if_exists__));
using ::uint_least32_t __attribute__((__using_if_exists__));
using ::uint_least64_t __attribute__((__using_if_exists__));

using ::int_fast8_t __attribute__((__using_if_exists__));
using ::int_fast16_t __attribute__((__using_if_exists__));
using ::int_fast32_t __attribute__((__using_if_exists__));
using ::int_fast64_t __attribute__((__using_if_exists__));

using ::uint_fast8_t __attribute__((__using_if_exists__));
using ::uint_fast16_t __attribute__((__using_if_exists__));
using ::uint_fast32_t __attribute__((__using_if_exists__));
using ::uint_fast64_t __attribute__((__using_if_exists__));

using ::intptr_t __attribute__((__using_if_exists__));
using ::uintptr_t __attribute__((__using_if_exists__));

using ::intmax_t __attribute__((__using_if_exists__));
using ::uintmax_t __attribute__((__using_if_exists__));

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {};


template <class _Tp>
inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);



template <class _Tp>
inline constexpr bool __is_cheap_to_copy = is_trivially_copyable_v<_Tp> && sizeof(_Tp) <= sizeof(std::intmax_t);


}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {







template <class _From, class _To>
struct __is_always_bitcastable {
  using _UnqualFrom = __remove_cv_t<_From>;
  using _UnqualTo = __remove_cv_t<_To>;


  static const bool value =

      (is_same<_UnqualFrom, _UnqualTo>::value && is_trivially_copyable<_UnqualFrom>::value) ||
# 74 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 3
      (
        sizeof(_From) == sizeof(_To) &&
        is_integral<_From>::value &&
        is_integral<_To>::value &&
        !is_same<_UnqualTo, bool>::value
      );

};

}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_assignable.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Up>
struct is_assignable : _BoolConstant<__is_assignable(_Tp, _Up)> {};


template <class _Tp, class _Arg>
inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Arg);


}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_constant_evaluated.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_constant_evaluated.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr bool is_constant_evaluated() noexcept {
  return __builtin_is_constant_evaluated();
}


__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr bool __libcpp_is_constant_evaluated() noexcept {
  return __builtin_is_constant_evaluated();
}

}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_equality_comparable.h" 1 3
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_equality_comparable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Up, class = void>
struct __is_equality_comparable : false_type {};

template <class _Tp, class _Up>
struct __is_equality_comparable<_Tp, _Up, __void_t<decltype(std::declval<_Tp>() == std::declval<_Up>())> > : true_type {
};
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_equality_comparable.h" 3
template <class _Tp, class _Up, class = void>
struct __libcpp_is_trivially_equality_comparable_impl : false_type {};

template <class _Tp>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp, _Tp>

    : integral_constant<bool, __is_trivially_equality_comparable(_Tp) && __is_equality_comparable<_Tp, _Tp>::value> {
};





template <class _Tp, class _Up>
struct __libcpp_is_trivially_equality_comparable_impl<
    _Tp,
    _Up,
    __enable_if_t<is_integral<_Tp>::value && is_integral<_Up>::value && !is_same<_Tp, _Up>::value &&
                  is_signed<_Tp>::value == is_signed<_Up>::value && sizeof(_Tp) == sizeof(_Up)> > : true_type {};

template <class _Tp>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp*, _Tp*> : true_type {};


template <class _Tp, class _Up>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp*, _Up*>
    : integral_constant<
          bool,
          __is_equality_comparable<_Tp*, _Up*>::value &&
              (is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value || is_void<_Tp>::value || is_void<_Up>::value)> {
};

template <class _Tp, class _Up>
using __libcpp_is_trivially_equality_comparable =
    __libcpp_is_trivially_equality_comparable_impl<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >;

}}
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 3
template <class _Tp, class _Up>
struct __libcpp_is_trivially_lexicographically_comparable
    : integral_constant<bool,
                        is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value && sizeof(_Tp) == 1 &&
                            is_unsigned<_Tp>::value> {};

}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/is_pointer_in_range.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/is_pointer_in_range.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Up, class = void>
struct __is_less_than_comparable : false_type {};

template <class _Tp, class _Up>
struct __is_less_than_comparable<_Tp, _Up, __void_t<decltype(std::declval<_Tp>() < std::declval<_Up>())> > : true_type {
};

template <class _Tp, class _Up, __enable_if_t<__is_less_than_comparable<const _Tp*, const _Up*>::value, int> = 0>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("address"))) bool __is_pointer_in_range(
    const _Tp* __begin, const _Tp* __end, const _Up* __ptr) {
  if (__libcpp_is_constant_evaluated()) {
    ((void)0);



    if (!__builtin_constant_p(__begin <= __ptr && __ptr < __end))
      return false;
  }


  return !__less<>()(__ptr, __begin) && __less<>()(__ptr, __end);
}

template <class _Tp, class _Up, __enable_if_t<!__is_less_than_comparable<const _Tp*, const _Up*>::value, int> = 0>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("address"))) bool __is_pointer_in_range(
    const _Tp* __begin, const _Tp* __end, const _Up* __ptr) {
  if (__libcpp_is_constant_evaluated())
    return false;

  return reinterpret_cast<const char*>(__begin) <= reinterpret_cast<const char*>(__ptr) &&
         reinterpret_cast<const char*>(__ptr) < reinterpret_cast<const char*>(__end);
}

}}
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



enum class __element_count : size_t {};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t __constexpr_strlen(const char* __str) {
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 3
  return __builtin_strlen(__str);
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int
__constexpr_memcmp(const _Tp* __lhs, const _Up* __rhs, __element_count __n) {
  static_assert(__libcpp_is_trivially_lexicographically_comparable<_Tp, _Up>::value,
                "_Tp and _Up have to be trivially lexicographically comparable");

  auto __count = static_cast<size_t>(__n);

  if (__libcpp_is_constant_evaluated()) {

    if (sizeof(_Tp) == 1 && !is_same<_Tp, bool>::value)
      return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp));


    while (__count != 0) {
      if (*__lhs < *__rhs)
        return -1;
      if (*__rhs < *__lhs)
        return 1;

      --__count;
      ++__lhs;
      ++__rhs;
    }
    return 0;
  } else {
    return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp));
  }
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
__constexpr_memcmp_equal(const _Tp* __lhs, const _Up* __rhs, __element_count __n) {
  static_assert(__libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                "_Tp and _Up have to be trivially equality comparable");

  auto __count = static_cast<size_t>(__n);

  if (__libcpp_is_constant_evaluated()) {

    if (sizeof(_Tp) == 1 && is_integral<_Tp>::value && !is_same<_Tp, bool>::value)
      return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp)) == 0;

    while (__count != 0) {
      if (*__lhs != *__rhs)
        return false;

      --__count;
      ++__lhs;
      ++__rhs;
    }
    return true;
  } else {
    return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp)) == 0;
  }
}

template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* __constexpr_memchr(_Tp* __str, _Up __value, size_t __count) {
  static_assert(sizeof(_Tp) == 1 && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                "Calling memchr on non-trivially equality comparable types is unsafe.");

  if (__libcpp_is_constant_evaluated()) {


    if constexpr (is_same_v<remove_cv_t<_Tp>, char> && is_same_v<remove_cv_t<_Up>, char>)
      return __builtin_char_memchr(__str, __value, __count);


    for (; __count; --__count) {
      if (*__str == __value)
        return __str;
      ++__str;
    }
    return nullptr;
  } else {
    char __value_buffer = 0;
    __builtin_memcpy(&__value_buffer, &__value, sizeof(char));
    return static_cast<_Tp*>(__builtin_memchr(__str, __value_buffer, __count));
  }
}
# 150 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 3
template <class _Tp, class _Up, __enable_if_t<is_assignable<_Tp&, _Up const&>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up const& __src) {
  __dest = __src;
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                               is_assignable<_Tp&, _Up&&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up& __src) {
  __dest =
      static_cast<_Up&&>(__src);
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                              !is_assignable<_Tp&, _Up&&>::value &&
                                               is_constructible<_Tp, _Up const&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up const& __src) {


  std::__construct_at(std::addressof(__dest), __src);
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                              !is_assignable<_Tp&, _Up&&>::value &&
                                              !is_constructible<_Tp, _Up const&>::value &&
                                               is_constructible<_Tp, _Up&&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up& __src) {


  std::__construct_at(
      std::addressof(__dest),
      static_cast<_Up&&>(__src));
  return __dest;
}

template <class _Tp, class _Up, __enable_if_t<__is_always_bitcastable<_Up, _Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp*
__constexpr_memmove(_Tp* __dest, _Up* __src, __element_count __n) {
  size_t __count = static_cast<size_t>(__n);
  if (__libcpp_is_constant_evaluated()) {

    if (is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value) {
      ::__builtin_memmove(__dest, __src, __count * sizeof(_Tp));
      return __dest;
    }

    if (std::__is_pointer_in_range(__src, __src + __count, __dest)) {
      for (; __count > 0; --__count)
        std::__assign_trivially_copyable(__dest[__count - 1], __src[__count - 1]);
    } else {
      for (size_t __i = 0; __i != __count; ++__i)
        std::__assign_trivially_copyable(__dest[__i], __src[__i]);
    }
  } else if (__count > 0) {
    ::__builtin_memmove(__dest, __src, (__count - 1) * sizeof(_Tp) + __libcpp_datasizeof<_Tp>::value);
  }
  return __dest;
}

}}
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __equal_iter_impl(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate& __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return true;
}

template <class _Tp,
          class _Up,
          class _BinaryPredicate,
          __enable_if_t<__desugars_to<__equal_tag, _BinaryPredicate, _Tp, _Up>::value && !is_volatile<_Tp>::value &&
                            !is_volatile<_Up>::value && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                        int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
__equal_iter_impl(_Tp* __first1, _Tp* __last1, _Up* __first2, _BinaryPredicate&) {
  return std::__constexpr_memcmp_equal(__first1, __first2, __element_count(__last1 - __first1));
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) {
  return std::__equal_iter_impl(
      std::__unwrap_iter(__first1), std::__unwrap_iter(__last1), std::__unwrap_iter(__first2), __pred);
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
  return std::equal(__first1, __last1, __first2, __equal_to());
}


template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
__equal(_InputIterator1 __first1,
        _InputIterator1 __last1,
        _InputIterator2 __first2,
        _InputIterator2 __last2,
        _BinaryPredicate __pred,
        input_iterator_tag,
        input_iterator_tag) {
  for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return __first1 == __last1 && __first2 == __last2;
}

template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Pred, class _Proj1, class _Proj2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __equal_impl(
    _Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2, _Pred& __comp, _Proj1& __proj1, _Proj2& __proj2) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (!std::__invoke(__comp, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
      return false;
    ++__first1;
    ++__first2;
  }
  return __first1 == __last1 && __first2 == __last2;
}

template <class _Tp,
          class _Up,
          class _Pred,
          class _Proj1,
          class _Proj2,
          __enable_if_t<__desugars_to<__equal_tag, _Pred, _Tp, _Up>::value && __is_identity<_Proj1>::value &&
                            __is_identity<_Proj2>::value && !is_volatile<_Tp>::value && !is_volatile<_Up>::value &&
                            __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                        int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
__equal_impl(_Tp* __first1, _Tp* __last1, _Up* __first2, _Up*, _Pred&, _Proj1&, _Proj2&) {
  return std::__constexpr_memcmp_equal(__first1, __first2, __element_count(__last1 - __first1));
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
__equal(_RandomAccessIterator1 __first1,
        _RandomAccessIterator1 __last1,
        _RandomAccessIterator2 __first2,
        _RandomAccessIterator2 __last2,
        _BinaryPredicate __pred,
        random_access_iterator_tag,
        random_access_iterator_tag) {
  if (std::distance(__first1, __last1) != std::distance(__first2, __last2))
    return false;
  __identity __proj;
  return std::__equal_impl(
      std::__unwrap_iter(__first1),
      std::__unwrap_iter(__last1),
      std::__unwrap_iter(__first2),
      std::__unwrap_iter(__last2),
      __pred,
      __proj,
      __proj);
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
equal(_InputIterator1 __first1,
      _InputIterator1 __last1,
      _InputIterator2 __first2,
      _InputIterator2 __last2,
      _BinaryPredicate __pred) {
  return std::__equal<_BinaryPredicate&>(
      __first1,
      __last1,
      __first2,
      __last2,
      __pred,
      typename iterator_traits<_InputIterator1>::iterator_category(),
      typename iterator_traits<_InputIterator2>::iterator_category());
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::__equal(
      __first1,
      __last1,
      __first2,
      __last2,
      __equal_to(),
      typename iterator_traits<_InputIterator1>::iterator_category(),
      typename iterator_traits<_InputIterator2>::iterator_category());
}


}}
# 115 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/fill_n.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/fill_n.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/convert_to_integral.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/convert_to_integral.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/underlying_type.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/underlying_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, bool = is_enum<_Tp>::value>
struct __underlying_type_impl;

template <class _Tp>
struct __underlying_type_impl<_Tp, false> {};

template <class _Tp>
struct __underlying_type_impl<_Tp, true> {
  typedef __underlying_type(_Tp) type;
};

template <class _Tp>
struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {};


template <class _Tp>
using underlying_type_t = typename underlying_type<_Tp>::type;


}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/convert_to_integral.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/convert_to_integral.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int __convert_to_integral(int __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unsigned __convert_to_integral(unsigned __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr long __convert_to_integral(long __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unsigned long __convert_to_integral(unsigned long __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr long long __convert_to_integral(long long __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unsigned long long __convert_to_integral(unsigned long long __val) {
  return __val;
}

template <typename _Fp, __enable_if_t<is_floating_point<_Fp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr long long __convert_to_integral(_Fp __val) {
  return __val;
}


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __int128_t __convert_to_integral(__int128_t __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __uint128_t __convert_to_integral(__uint128_t __val) { return __val; }


template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type {
  typedef typename underlying_type<_Tp>::type type;
  typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) {
  return __val;
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/fill_n.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/fill_n.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value) {
  for (; __n > 0; ++__first, (void)--__n)
    *__first = __value;
  return __first;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value) {
  return std::__fill_n(__first, std::__convert_to_integral(__n), __value);
}

}}
# 116 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp_ref_type.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp_ref_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Compare>
struct __debug_less {
  _Compare& __comp_;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __debug_less(_Compare& __c) : __comp_(__c) {}

  template <class _Tp, class _Up>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const _Tp& __x, const _Up& __y) {
    bool __r = __comp_(__x, __y);
    if (__r)
      __do_compare_assert(0, __y, __x);
    return __r;
  }

  template <class _Tp, class _Up>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(_Tp& __x, _Up& __y) {
    bool __r = __comp_(__x, __y);
    if (__r)
      __do_compare_assert(0, __y, __x);
    return __r;
  }

  template <class _LHS, class _RHS>
  constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) decltype((void)std::declval<_Compare&>()(
      std::declval<_LHS&>(), std::declval<_RHS&>()))
  __do_compare_assert(int, _LHS& __l, _RHS& __r) {
    ((void)0);
    (void)__l;
    (void)__r;
  }

  template <class _LHS, class _RHS>
  constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __do_compare_assert(long, _LHS&, _RHS&) {}
};






template <class _Comp>
using __comp_ref_type = _Comp&;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Compare, class _InputIterator1, class _InputIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __lexicographical_compare(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _Compare __comp) {
  for (; __first2 != __last2; ++__first1, (void)++__first2) {
    if (__first1 == __last1 || __comp(*__first1, *__first2))
      return true;
    if (__comp(*__first2, *__first1))
      return false;
  }
  return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool lexicographical_compare(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _Compare __comp) {
  return std::__lexicographical_compare<__comp_ref_type<_Compare> >(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool lexicographical_compare(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::lexicographical_compare(__first1, __last1, __first2, __last2, __less<>());
}

}}
# 117 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min_element.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min_element.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_callable.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_callable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Func, class... _Args, class = decltype(std::declval<_Func>()(std::declval<_Args>()...))>
true_type __is_callable_helper(int);
template <class...>
false_type __is_callable_helper(...);

template <class _Func, class... _Args>
struct __is_callable : decltype(std::__is_callable_helper<_Func, _Args...>(0)) {};

}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min_element.h" 2 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min_element.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min_element.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Comp, class _Iter, class _Sent, class _Proj>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter
__min_element(_Iter __first, _Sent __last, _Comp __comp, _Proj& __proj) {
  if (__first == __last)
    return __first;

  _Iter __i = __first;
  while (++__i != __last)
    if (std::__invoke(__comp, std::__invoke(__proj, *__i), std::__invoke(__proj, *__first)))
      __first = __i;

  return __first;
}

template <class _Comp, class _Iter, class _Sent>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter __min_element(_Iter __first, _Sent __last, _Comp __comp) {
  auto __proj = __identity();
  return std::__min_element<_Comp>(std::move(__first), std::move(__last), __comp, __proj);
}

template <class _ForwardIterator, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  static_assert(
      __has_forward_iterator_category<_ForwardIterator>::value, "std::min_element requires a ForwardIterator");
  static_assert(
      __is_callable<_Compare, decltype(*__first), decltype(*__first)>::value, "The comparator has to be callable");

  return std::__min_element<__comp_ref_type<_Compare> >(std::move(__first), std::move(__last), __comp);
}

template <class _ForwardIterator>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::min_element(__first, __last, __less<>());
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp&
min([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp&
min([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b) {
  return std::min(__a, __b, __less<>());
}



template <class _Tp, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp
min(initializer_list<_Tp> __t, _Compare __comp) {
  return *std::__min_element<__comp_ref_type<_Compare> >(__t.begin(), __t.end(), __comp);
}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp min(initializer_list<_Tp> __t) {
  return *std::min_element(__t.begin(), __t.end(), __less<>());
}



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/three_way_comp_ref_type.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/three_way_comp_ref_type.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/ordering.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/ordering.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




enum class _OrdResult : signed char { __less = -1, __equiv = 0, __greater = 1 };

enum class _NCmpResult : signed char { __unordered = -127 };

class partial_ordering;
class weak_ordering;
class strong_ordering;

template <class _Tp, class... _Args>
inline constexpr bool __one_of_v = (is_same_v<_Tp, _Args> || ...);

struct _CmpUnspecifiedParam {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _CmpUnspecifiedParam(int _CmpUnspecifiedParam::*) noexcept {}

  template <class _Tp, class = enable_if_t<!__one_of_v<_Tp, int, partial_ordering, weak_ordering, strong_ordering>>>
  _CmpUnspecifiedParam(_Tp) = delete;
};

class partial_ordering {
  using _ValueT = signed char;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit constexpr partial_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit constexpr partial_ordering(_NCmpResult __v) noexcept : __value_(_ValueT(__v)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __is_ordered() const noexcept {
    return __value_ != _ValueT(_NCmpResult::__unordered);
  }

public:

  static const partial_ordering less;
  static const partial_ordering equivalent;
  static const partial_ordering greater;
  static const partial_ordering unordered;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(partial_ordering, partial_ordering) noexcept = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ < 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ <= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ > 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ >= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 < __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 <= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 > __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 >= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr partial_ordering
  operator<=>(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr partial_ordering
  operator<=>(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v < 0 ? partial_ordering::greater : (__v > 0 ? partial_ordering::less : __v);
  }

private:
  _ValueT __value_;
};

inline constexpr partial_ordering partial_ordering::less(_OrdResult::__less);
inline constexpr partial_ordering partial_ordering::equivalent(_OrdResult::__equiv);
inline constexpr partial_ordering partial_ordering::greater(_OrdResult::__greater);
inline constexpr partial_ordering partial_ordering::unordered(_NCmpResult ::__unordered);

class weak_ordering {
  using _ValueT = signed char;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit constexpr weak_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}

public:
  static const weak_ordering less;
  static const weak_ordering equivalent;
  static const weak_ordering greater;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator partial_ordering() const noexcept {
    return __value_ == 0 ? partial_ordering::equivalent
                         : (__value_ < 0 ? partial_ordering::less : partial_ordering::greater);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(weak_ordering, weak_ordering) noexcept = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ < 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ <= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ > 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ >= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 < __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 <= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 > __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 >= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr weak_ordering operator<=>(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr weak_ordering operator<=>(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return __v < 0 ? weak_ordering::greater : (__v > 0 ? weak_ordering::less : __v);
  }

private:
  _ValueT __value_;
};

inline constexpr weak_ordering weak_ordering::less(_OrdResult::__less);
inline constexpr weak_ordering weak_ordering::equivalent(_OrdResult::__equiv);
inline constexpr weak_ordering weak_ordering::greater(_OrdResult::__greater);

class strong_ordering {
  using _ValueT = signed char;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit constexpr strong_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}

public:
  static const strong_ordering less;
  static const strong_ordering equal;
  static const strong_ordering equivalent;
  static const strong_ordering greater;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator partial_ordering() const noexcept {
    return __value_ == 0 ? partial_ordering::equivalent
                         : (__value_ < 0 ? partial_ordering::less : partial_ordering::greater);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator weak_ordering() const noexcept {
    return __value_ == 0 ? weak_ordering::equivalent : (__value_ < 0 ? weak_ordering::less : weak_ordering::greater);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(strong_ordering, strong_ordering) noexcept = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ < 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ <= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ > 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ >= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 < __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 <= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 > __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 >= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr strong_ordering
  operator<=>(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr strong_ordering
  operator<=>(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return __v < 0 ? strong_ordering::greater : (__v > 0 ? strong_ordering::less : __v);
  }

private:
  _ValueT __value_;
};

inline constexpr strong_ordering strong_ordering::less(_OrdResult::__less);
inline constexpr strong_ordering strong_ordering::equal(_OrdResult::__equiv);
inline constexpr strong_ordering strong_ordering::equivalent(_OrdResult::__equiv);
inline constexpr strong_ordering strong_ordering::greater(_OrdResult::__greater);




template <class _Tp>
concept __comparison_category = __one_of_v<_Tp, partial_ordering, weak_ordering, strong_ordering>;



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/three_way_comp_ref_type.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/three_way_comp_ref_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Comp>
struct __debug_three_way_comp {
  _Comp& __comp_;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __debug_three_way_comp(_Comp& __c) : __comp_(__c) {}

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(const _Tp& __x, const _Up& __y) {
    auto __r = __comp_(__x, __y);
    if constexpr (__comparison_category<decltype(__comp_(__x, __y))>)
      __do_compare_assert(__y, __x, __r);
    return __r;
  }

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp& __x, _Up& __y) {
    auto __r = __comp_(__x, __y);
    if constexpr (__comparison_category<decltype(__comp_(__x, __y))>)
      __do_compare_assert(__y, __x, __r);
    return __r;
  }

  template <class _LHS, class _RHS, class _Order>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __do_compare_assert(_LHS& __l, _RHS& __r, _Order __o) {
    _Order __expected = __o;
    if (__o == _Order::less)
      __expected = _Order::greater;
    if (__o == _Order::greater)
      __expected = _Order::less;
    ((void)0);

    (void)__l;
    (void)__r;
  }
};






template <class _Comp>
using __three_way_comp_ref_type = _Comp&;




}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/three_way_comparable.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/three_way_comparable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/common_comparison_category.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/common_comparison_category.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace __comp_detail {

enum _ClassifyCompCategory : unsigned { _None, _PartialOrd, _WeakOrd, _StrongOrd, _CCC_Size };

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ClassifyCompCategory __type_to_enum() noexcept {
  if (is_same_v<_Tp, partial_ordering>)
    return _PartialOrd;
  if (is_same_v<_Tp, weak_ordering>)
    return _WeakOrd;
  if (is_same_v<_Tp, strong_ordering>)
    return _StrongOrd;
  return _None;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ClassifyCompCategory
__compute_comp_type(const _ClassifyCompCategory (&__types)[_Size]) {
  int __seen[_CCC_Size] = {};
  for (auto __type : __types)
    ++__seen[__type];
  if (__seen[_None])
    return _None;
  if (__seen[_PartialOrd])
    return _PartialOrd;
  if (__seen[_WeakOrd])
    return _WeakOrd;
  return _StrongOrd;
}

template <class... _Ts, bool _False = false>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto __get_comp_type() {
  using _CCC = _ClassifyCompCategory;
  constexpr _CCC __type_kinds[] = {_StrongOrd, __type_to_enum<_Ts>()...};
  constexpr _CCC __cat = __comp_detail::__compute_comp_type(__type_kinds);
  if constexpr (__cat == _None)
    return void();
  else if constexpr (__cat == _PartialOrd)
    return partial_ordering::equivalent;
  else if constexpr (__cat == _WeakOrd)
    return weak_ordering::equivalent;
  else if constexpr (__cat == _StrongOrd)
    return strong_ordering::equivalent;
  else
    static_assert(_False, "unhandled case");
}
}


template <class... _Ts>
struct common_comparison_category {
  using type = decltype(__comp_detail::__get_comp_type<_Ts...>());
};

template <class... _Ts>
using common_comparison_category_t = typename common_comparison_category<_Ts...>::type;



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/three_way_comparable.h" 2 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/three_way_comparable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp, class _Cat>
concept __compares_as = same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;

template <class _Tp, class _Cat = partial_ordering>
concept three_way_comparable =
    __weakly_equality_comparable_with<_Tp, _Tp> && __partially_ordered_with<_Tp, _Tp> &&
    requires(__make_const_lvalue_ref<_Tp> __a, __make_const_lvalue_ref<_Tp> __b) {
      { __a <=> __b } -> __compares_as<_Cat>;
    };

template <class _Tp, class _Up, class _Cat = partial_ordering>
concept three_way_comparable_with =
    three_way_comparable<_Tp, _Cat> && three_way_comparable<_Up, _Cat> &&
    common_reference_with<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>> &&
    three_way_comparable<common_reference_t<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>>, _Cat> &&
    __weakly_equality_comparable_with<_Tp, _Up> && __partially_ordered_with<_Tp, _Up> &&
    requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
      { __t <=> __u } -> __compares_as<_Cat>;
      { __u <=> __t } -> __compares_as<_Cat>;
    };



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



struct compare_three_way {
  template <class _T1, class _T2>
    requires three_way_comparable_with<_T1, _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) <=> std::forward<_T2>(__u))) {
    return std::forward<_T1>(__t) <=> std::forward<_T2>(__u);
  }

  using is_transparent = void;
};



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _InputIterator1, class _InputIterator2, class _Cmp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto __lexicographical_compare_three_way_fast_path(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Cmp& __comp)
    -> decltype(__comp(*__first1, *__first2)) {
  static_assert(
      signed_integral<__iter_diff_t<_InputIterator1>>, "Using a non-integral difference_type is undefined behavior.");
  static_assert(
      signed_integral<__iter_diff_t<_InputIterator2>>, "Using a non-integral difference_type is undefined behavior.");

  using _Len1 = __iter_diff_t<_InputIterator1>;
  using _Len2 = __iter_diff_t<_InputIterator2>;
  using _Common = common_type_t<_Len1, _Len2>;

  _Len1 __len1 = __last1 - __first1;
  _Len2 __len2 = __last2 - __first2;
  _Common __min_len = std::min<_Common>(__len1, __len2);

  for (_Common __i = 0; __i < __min_len; ++__i) {
    auto __c = __comp(*__first1, *__first2);
    if (__c != 0) {
      return __c;
    }
    ++__first1;
    ++__first2;
  }

  return __len1 <=> __len2;
}


template <class _InputIterator1, class _InputIterator2, class _Cmp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto __lexicographical_compare_three_way_slow_path(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Cmp& __comp)
    -> decltype(__comp(*__first1, *__first2)) {
  while (true) {
    bool __exhausted1 = __first1 == __last1;
    bool __exhausted2 = __first2 == __last2;

    if (__exhausted1 || __exhausted2) {
      if (!__exhausted1)
        return strong_ordering::greater;
      if (!__exhausted2)
        return strong_ordering::less;
      return strong_ordering::equal;
    }

    auto __c = __comp(*__first1, *__first2);
    if (__c != 0) {
      return __c;
    }

    ++__first1;
    ++__first2;
  }
}

template <class _InputIterator1, class _InputIterator2, class _Cmp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto lexicographical_compare_three_way(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Cmp __comp)
    -> decltype(__comp(*__first1, *__first2)) {
  static_assert(__comparison_category<decltype(__comp(*__first1, *__first2))>,
                "The comparator passed to lexicographical_compare_three_way must return a comparison category type.");
  static_assert(std::is_copy_constructible_v<_InputIterator1>, "Iterators must be copy constructible.");
  static_assert(std::is_copy_constructible_v<_InputIterator2>, "Iterators must be copy constructible.");
  __three_way_comp_ref_type<_Cmp> __wrapped_comp_ref(__comp);
  if constexpr (__has_random_access_iterator_category<_InputIterator1>::value &&
                __has_random_access_iterator_category<_InputIterator2>::value) {
    return std::__lexicographical_compare_three_way_fast_path(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __wrapped_comp_ref);
  } else {

    return std::__lexicographical_compare_three_way_slow_path(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __wrapped_comp_ref);
  }
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto lexicographical_compare_three_way(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::lexicographical_compare_three_way(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), std::compare_three_way());
}



}}
# 118 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iter_swap.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iter_swap.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)

    noexcept(noexcept(swap(*std::declval<_ForwardIterator1>(), *std::declval<_ForwardIterator2>()))) {
  swap(*__a, *__b);
}

}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/ranges_iterator_concept.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/ranges_iterator_concept.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/ranges_iterator_concept.h" 2 3



 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

namespace ranges {

template <class _IterMaybeQualified>
consteval auto __get_iterator_concept() {
  using _Iter = __remove_cvref_t<_IterMaybeQualified>;

  if constexpr (contiguous_iterator<_Iter>)
    return contiguous_iterator_tag();
  else if constexpr (random_access_iterator<_Iter>)
    return random_access_iterator_tag();
  else if constexpr (bidirectional_iterator<_Iter>)
    return bidirectional_iterator_tag();
  else if constexpr (forward_iterator<_Iter>)
    return forward_iterator_tag();
  else if constexpr (input_iterator<_Iter>)
    return input_iterator_tag();
}

template <class _Iter>
using __iterator_concept = decltype(__get_iterator_concept<_Iter>());

}
}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 1 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/unreachable.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/unreachable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

[[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline void __libcpp_unreachable() {
  ((void)0);
  __builtin_unreachable();
}



[[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline void unreachable() { __libcpp_unreachable(); }



}}
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/limits" 1 3
# 112 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/limits" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 116 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/limits" 2 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

enum float_round_style {
  round_indeterminate = -1,
  round_toward_zero = 0,
  round_to_nearest = 1,
  round_toward_infinity = 2,
  round_toward_neg_infinity = 3
};

enum __attribute__((__deprecated__)) float_denorm_style {
  denorm_indeterminate = -1,
  denorm_absent = 0,
  denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits {
protected:
  typedef _Tp type;

  static constexpr const bool is_specialized = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return type(); }

  static constexpr const int digits = 0;
  static constexpr const int digits10 = 0;
  static constexpr const int max_digits10 = 0;
  static constexpr const bool is_signed = false;
  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 0;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return type(); }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_absent;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return type(); }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = false;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min {
  static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};

template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false> {
  static constexpr const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true> {
protected:
  typedef _Tp type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = type(-1) < type(0);
  static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
  static constexpr const int digits10 = digits * 3 / 10;
  static constexpr const int max_digits10 = 0;
  static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
  static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return __min; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return __max; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return min(); }

  static constexpr const bool is_integer = true;
  static constexpr const bool is_exact = true;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return type(0); }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_absent;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return type(0); }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = !std::is_signed<_Tp>::value;




  static constexpr const bool traps = false;

  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true> {
protected:
  typedef bool type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = false;
  static constexpr const int digits = 1;
  static constexpr const int digits10 = 0;
  static constexpr const int max_digits10 = 0;
  static constexpr const type __min = false;
  static constexpr const type __max = true;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return __min; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return __max; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return min(); }

  static constexpr const bool is_integer = true;
  static constexpr const bool is_exact = true;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return type(0); }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_absent;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return type(0); }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true> {
protected:
  typedef float type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 24;
  static constexpr const int digits10 = 6;
  static constexpr const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return 1.17549435e-38F; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return 3.40282347e+38F; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return -max(); }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return 1.19209290e-7F; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return 0.5F; }

  static constexpr const int min_exponent = (-125);
  static constexpr const int min_exponent10 = (-37);
  static constexpr const int max_exponent = 128;
  static constexpr const int max_exponent10 = 38;

  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_present;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return __builtin_huge_valf(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return __builtin_nanf(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return __builtin_nansf(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return 1.40129846e-45F; }

  static constexpr const bool is_iec559 = true;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;

  static constexpr const bool tinyness_before = true;



  static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true> {
protected:
  typedef double type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 53;
  static constexpr const int digits10 = 15;
  static constexpr const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return 2.2250738585072014e-308; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return 1.7976931348623157e+308; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return -max(); }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return 2.2204460492503131e-16; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return 0.5; }

  static constexpr const int min_exponent = (-1021);
  static constexpr const int min_exponent10 = (-307);
  static constexpr const int max_exponent = 1024;
  static constexpr const int max_exponent10 = 308;

  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_present;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return __builtin_huge_val(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return __builtin_nan(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return __builtin_nans(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return 4.9406564584124654e-324; }

  static constexpr const bool is_iec559 = true;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;

  static constexpr const bool tinyness_before = true;



  static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true> {
protected:
  typedef long double type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 113;
  static constexpr const int digits10 = 33;
  static constexpr const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return 1.18973149535723176508575932662800702e+4932L; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return -max(); }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return 1.92592994438723585305597794258492732e-34L; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return 0.5L; }

  static constexpr const int min_exponent = (-16381);
  static constexpr const int min_exponent10 = (-4931);
  static constexpr const int max_exponent = 16384;
  static constexpr const int max_exponent10 = 4932;

  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_present;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return __builtin_huge_vall(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return __builtin_nanl(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return __builtin_nansl(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return 6.47517511943802511092443895822764655e-4966L; }




  static constexpr const bool is_iec559 = true;

  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;

  static constexpr const bool tinyness_before = true;



  static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class numeric_limits : private __libcpp_numeric_limits<_Tp> {
  typedef __libcpp_numeric_limits<_Tp> __base;
  typedef typename __base::type type;

public:
  static constexpr const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return __base::min(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return __base::max(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return __base::lowest(); }

  static constexpr const int digits = __base::digits;
  static constexpr const int digits10 = __base::digits10;
  static constexpr const int max_digits10 = __base::max_digits10;
  static constexpr const bool is_signed = __base::is_signed;
  static constexpr const bool is_integer = __base::is_integer;
  static constexpr const bool is_exact = __base::is_exact;
  static constexpr const int radix = __base::radix;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return __base::epsilon(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return __base::round_error(); }

  static constexpr const int min_exponent = __base::min_exponent;
  static constexpr const int min_exponent10 = __base::min_exponent10;
  static constexpr const int max_exponent = __base::max_exponent;
  static constexpr const int max_exponent10 = __base::max_exponent10;

  static constexpr const bool has_infinity = __base::has_infinity;
  static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
  static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
#pragma GCC diagnostic push
# 466 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 466 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = __base::has_denorm;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = __base::has_denorm_loss;
#pragma GCC diagnostic pop
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return __base::infinity(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return __base::quiet_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return __base::signaling_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return __base::denorm_min(); }

  static constexpr const bool is_iec559 = __base::is_iec559;
  static constexpr const bool is_bounded = __base::is_bounded;
  static constexpr const bool is_modulo = __base::is_modulo;

  static constexpr const bool traps = __base::traps;
  static constexpr const bool tinyness_before = __base::tinyness_before;
  static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class numeric_limits<const _Tp> : public numeric_limits<_Tp> {};

template <class _Tp>
class numeric_limits<volatile _Tp> : public numeric_limits<_Tp> {};

template <class _Tp>
class numeric_limits<const volatile _Tp> : public numeric_limits<_Tp> {};

}}
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 2 3
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__advance(_InputIter& __i, typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag) {
  for (; __n > 0; --__n)
    ++__i;
}

template <class _BiDirIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__advance(_BiDirIter& __i, typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag) {
  if (__n >= 0)
    for (; __n > 0; --__n)
      ++__i;
  else
    for (; __n < 0; ++__n)
      --__i;
}

template <class _RandIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__advance(_RandIter& __i, typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag) {
  __i += __n;
}

template < class _InputIter,
           class _Distance,
           class _IntegralDistance = decltype(std::__convert_to_integral(std::declval<_Distance>())),
           __enable_if_t<is_integral<_IntegralDistance>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void advance(_InputIter& __i, _Distance __orig_n) {
  typedef typename iterator_traits<_InputIter>::difference_type _Difference;
  _Difference __n = static_cast<_Difference>(std::__convert_to_integral(__orig_n));

  ((void)0);

  std::__advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}





namespace ranges {
namespace __advance {

struct __fn {
private:
  template <class _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr void __advance_forward(_Ip& __i, iter_difference_t<_Ip> __n) {
    while (__n > 0) {
      --__n;
      ++__i;
    }
  }

  template <class _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr void __advance_backward(_Ip& __i, iter_difference_t<_Ip> __n) {
    while (__n < 0) {
      ++__n;
      --__i;
    }
  }

public:

  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_Ip& __i, iter_difference_t<_Ip> __n) const {

    ((void)0);



    if constexpr (random_access_iterator<_Ip>) {
      __i += __n;
      return;
    } else if constexpr (bidirectional_iterator<_Ip>) {

      __advance_forward(__i, __n);

      __advance_backward(__i, __n);
      return;
    } else {

      __advance_forward(__i, __n);
      return;
    }
  }



  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_Ip& __i, _Sp __bound_sentinel) const {

    if constexpr (assignable_from<_Ip&, _Sp>) {
      __i = std::move(__bound_sentinel);
    }


    else if constexpr (sized_sentinel_for<_Sp, _Ip>) {
      (*this)(__i, __bound_sentinel - __i);
    }

    else {
      while (__i != __bound_sentinel) {
        ++__i;
      }
    }
  }







  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iter_difference_t<_Ip>
  operator()(_Ip& __i, iter_difference_t<_Ip> __n, _Sp __bound_sentinel) const {

    ((void)0);


    if constexpr (sized_sentinel_for<_Sp, _Ip>) {


      auto __magnitude_geq = [](auto __a, auto __b) { return __a == 0 ? __b == 0 : __a > 0 ? __a >= __b : __a <= __b; };
      if (const auto __m = __bound_sentinel - __i; __magnitude_geq(__n, __m)) {
        (*this)(__i, __bound_sentinel);
        return __n - __m;
      }


      (*this)(__i, __n);
      return 0;
    } else {


      while (__i != __bound_sentinel && __n > 0) {
        ++__i;
        --__n;
      }


      if constexpr (bidirectional_iterator<_Ip> && same_as<_Ip, _Sp>) {
        while (__i != __bound_sentinel && __n < 0) {
          --__i;
          ++__n;
        }
      }
      return __n;
    }

    __libcpp_unreachable();
  }
};

}

inline namespace __cpo {
inline constexpr auto advance = __advance::__fn{};
}
}



}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_swap.h" 1 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_swap.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_swap.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





namespace ranges {
namespace __iter_swap {
template <class _I1, class _I2>
void iter_swap(_I1, _I2) = delete;

template <class _T1, class _T2>
concept __unqualified_iter_swap =
    (__class_or_enum<remove_cvref_t<_T1>> || __class_or_enum<remove_cvref_t<_T2>>)&&requires(_T1&& __x, _T2&& __y) {

      iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y));
    };

template <class _T1, class _T2>
concept __readable_swappable =
    indirectly_readable<_T1> && indirectly_readable<_T2> &&
    swappable_with<iter_reference_t<_T1>, iter_reference_t<_T2>>;

struct __fn {

  template <class _T1, class _T2>
    requires __unqualified_iter_swap<_T1, _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y)))) {
    (void)iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y));
  }


  template <class _T1, class _T2>
    requires(!__unqualified_iter_swap<_T1, _T2>) && __readable_swappable<_T1, _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(ranges::swap(*std::forward<_T1>(__x), *std::forward<_T2>(__y)))) {
    ranges::swap(*std::forward<_T1>(__x), *std::forward<_T2>(__y));
  }

  template <class _T1, class _T2>
    requires(!__unqualified_iter_swap<_T1, _T2> &&
             !__readable_swappable<_T1, _T2>) &&
            indirectly_movable_storable<_T1, _T2> &&
            indirectly_movable_storable<_T2, _T1>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(iter_value_t<_T2>(ranges::iter_move(__y))) &&
               noexcept(*__y = ranges::iter_move(__x)) &&
               noexcept(*std::forward<_T1>(__x) = std::declval<iter_value_t<_T2>>())) {
    iter_value_t<_T2> __old(ranges::iter_move(__y));
    *__y = ranges::iter_move(__x);
    *std::forward<_T1>(__x) = std::move(__old);
  }
};
}

inline namespace __cpo {
inline constexpr auto iter_swap = __iter_swap::__fn{};
}
}

template <class _I1, class _I2 = _I1>
concept indirectly_swappable =
    indirectly_readable<_I1> && indirectly_readable<_I2> && requires(const _I1 __i1, const _I2 __i2) {
      ranges::iter_swap(__i1, __i1);
      ranges::iter_swap(__i2, __i2);
      ranges::iter_swap(__i1, __i2);
      ranges::iter_swap(__i2, __i1);
    };



}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/next.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/next.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _InputIter
next(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {


  ((void)0);


  std::advance(__x, __n);
  return __x;
}





namespace ranges {
namespace __next {

struct __fn {
  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x) const {
    ++__x;
    return __x;
  }

  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n) const {
    ranges::advance(__x, __n);
    return __x;
  }

  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x, _Sp __bound_sentinel) const {
    ranges::advance(__x, __bound_sentinel);
    return __x;
  }

  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n, _Sp __bound_sentinel) const {
    ranges::advance(__x, __n, __bound_sentinel);
    return __x;
  }
};

}

inline namespace __cpo {
inline constexpr auto next = __next::__fn{};
}
}



}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/prev.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/prev.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _InputIter
prev(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {


  ((void)0);

  std::advance(__x, -__n);
  return __x;
}





namespace ranges {
namespace __prev {

struct __fn {
  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x) const {
    --__x;
    return __x;
  }

  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n) const {
    ranges::advance(__x, -__n);
    return __x;
  }

  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n, _Ip __bound_iter) const {
    ranges::advance(__x, -__n, __bound_iter);
    return __x;
  }
};

}

inline namespace __cpo {
inline constexpr auto prev = __prev::__fn{};
}
}



}}
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _AlgPolicy>
struct _IterOps;


struct _RangeAlgPolicy {};

template <>
struct _IterOps<_RangeAlgPolicy> {
  template <class _Iter>
  using __value_type = iter_value_t<_Iter>;

  template <class _Iter>
  using __iterator_category = ranges::__iterator_concept<_Iter>;

  template <class _Iter>
  using __difference_type = iter_difference_t<_Iter>;

  static constexpr auto advance = ranges::advance;
  static constexpr auto distance = ranges::distance;
  static constexpr auto __iter_move = ranges::iter_move;
  static constexpr auto iter_swap = ranges::iter_swap;
  static constexpr auto next = ranges::next;
  static constexpr auto prev = ranges::prev;
  static constexpr auto __advance_to = ranges::advance;
};



struct _ClassicAlgPolicy {};

template <>
struct _IterOps<_ClassicAlgPolicy> {
  template <class _Iter>
  using __value_type = typename iterator_traits<_Iter>::value_type;

  template <class _Iter>
  using __iterator_category = typename iterator_traits<_Iter>::iterator_category;

  template <class _Iter>
  using __difference_type = typename iterator_traits<_Iter>::difference_type;


  template <class _Iter, class _Distance>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void advance(_Iter& __iter, _Distance __count) {
    std::advance(__iter, __count);
  }


  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static typename iterator_traits<_Iter>::difference_type
  distance(_Iter __first, _Iter __last) {
    return std::distance(__first, __last);
  }

  template <class _Iter>
  using __deref_t = decltype(*std::declval<_Iter&>());

  template <class _Iter>
  using __move_t = decltype(std::move(*std::declval<_Iter&>()));

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void __validate_iter_reference() {
    static_assert(
        is_same<__deref_t<_Iter>, typename iterator_traits<__remove_cvref_t<_Iter> >::reference>::value,
        "It looks like your iterator's `iterator_traits<It>::reference` does not match the return type of "
        "dereferencing the iterator, i.e., calling `*it`. This is undefined behavior according to [input.iterators] "
        "and can lead to dangling reference issues at runtime, so we are flagging this.");
  }


  template <class _Iter, __enable_if_t<is_reference<__deref_t<_Iter> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static


      __move_t<_Iter>
      __iter_move(_Iter&& __i) {
    __validate_iter_reference<_Iter>();

    return std::move(*std::forward<_Iter>(__i));
  }

  template <class _Iter, __enable_if_t<!is_reference<__deref_t<_Iter> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static



      __deref_t<_Iter>
      __iter_move(_Iter&& __i) {
    __validate_iter_reference<_Iter>();

    return *std::forward<_Iter>(__i);
  }


  template <class _Iter1, class _Iter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void iter_swap(_Iter1&& __a, _Iter2&& __b) {
    std::iter_swap(std::forward<_Iter1>(__a), std::forward<_Iter2>(__b));
  }


  template <class _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr _Iterator next(_Iterator, _Iterator __last) {
    return __last;
  }

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr __remove_cvref_t<_Iter>
  next(_Iter&& __it, typename iterator_traits<__remove_cvref_t<_Iter> >::difference_type __n = 1) {
    return std::next(std::forward<_Iter>(__it), __n);
  }


  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr __remove_cvref_t<_Iter>
  prev(_Iter&& __iter, typename iterator_traits<__remove_cvref_t<_Iter> >::difference_type __n = 1) {
    return std::prev(std::forward<_Iter>(__iter), __n);
  }

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr void __advance_to(_Iter& __first, _Iter __last) {
    __first = __last;
  }
};

}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/synth_three_way.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/synth_three_way.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/synth_three_way.h" 3
template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto __synth_three_way(const _Tp& __t, const _Up& __u)
  requires requires {
    { __t < __u } -> __boolean_testable;
    { __u < __t } -> __boolean_testable;
  }
{
  if constexpr (three_way_comparable_with<_Tp, _Up>) {
    return __t <=> __u;
  } else {
    if (__t < __u)
      return weak_ordering::less;
    if (__u < __t)
      return weak_ordering::greater;
    return weak_ordering::equivalent;
  }
}

template <class _Tp, class _Up = _Tp>
using __synth_three_way_result = decltype(std::__synth_three_way(std::declval<_Tp&>(), std::declval<_Up&>()));



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/different_from.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/different_from.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp, class _Up>
concept __different_from = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/array.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/array.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, size_t _Size>
struct array;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& get(array<_Tp, _Size>&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp& get(const array<_Tp, _Size>&) noexcept;


template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp&& get(array<_Tp, _Size>&&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp&& get(const array<_Tp, _Size>&&) noexcept;


template <class>
struct __is_std_array : false_type {};

template <class _Tp, size_t _Size>
struct __is_std_array<array<_Tp, _Size> > : true_type {};

}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/subrange.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/subrange.h" 3




 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

namespace ranges {

enum class subrange_kind : bool { unsized, sized };

template <input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent, subrange_kind _Kind>
  requires(_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _Iter>)
class subrange;

template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires((_Index == 0 && copyable<_Iter>) || _Index == 1)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto get(const subrange<_Iter, _Sent, _Kind>&);

template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires(_Index < 2)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto get(subrange<_Iter, _Sent, _Kind>&&);

}

using ranges::get;

}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/pair_like.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/pair_like.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/complex.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/complex.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
class complex;
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/complex.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like.h" 2 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct __tuple_like_impl : false_type {};

template <class... _Tp>
struct __tuple_like_impl<tuple<_Tp...> > : true_type {};

template <class _T1, class _T2>
struct __tuple_like_impl<pair<_T1, _T2> > : true_type {};

template <class _Tp, size_t _Size>
struct __tuple_like_impl<array<_Tp, _Size> > : true_type {};

template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct __tuple_like_impl<ranges::subrange<_Ip, _Sp, _Kp> > : true_type {};
# 51 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like.h" 3
template <class _Tp>
concept __tuple_like = __tuple_like_impl<remove_cvref_t<_Tp>>::value;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/pair_like.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_size.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_size.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_types.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_types.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class... _Tp>
struct __tuple_types {};

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_size.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_size.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct tuple_size;


template <class _Tp, class...>
using __enable_if_tuple_size_imp = _Tp;

template <class _Tp>
struct tuple_size<__enable_if_tuple_size_imp< const _Tp,
                                                                   __enable_if_t<!is_volatile<_Tp>::value>,
                                                                   integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct tuple_size<__enable_if_tuple_size_imp< volatile _Tp,
                                                                   __enable_if_t<!is_const<_Tp>::value>,
                                                                   integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct
    tuple_size<__enable_if_tuple_size_imp< const volatile _Tp, integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
# 60 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_size.h" 3
template <class... _Tp>
struct tuple_size<tuple<_Tp...> > : public integral_constant<size_t, sizeof...(_Tp)> {};

template <class... _Tp>
struct tuple_size<__tuple_types<_Tp...> > : public integral_constant<size_t, sizeof...(_Tp)> {};



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/pair_like.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/pair_like.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
concept __pair_like = __tuple_like<_Tp> && tuple_size<remove_cvref_t<_Tp>>::value == 2;



}}
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/sfinae_helpers.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/sfinae_helpers.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/make_tuple_types.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/make_tuple_types.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_element.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_element.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_indices.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_indices.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/integer_sequence.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/integer_sequence.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <size_t...>
struct __tuple_indices;

template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};


template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template __to_tuple_indices<_Sp>;
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/integer_sequence.h" 3
template <class _Tp, _Tp... _Ip>
struct integer_sequence {
  typedef _Tp value_type;
  static_assert(is_integral<_Tp>::value, "std::integer_sequence can only be instantiated with an integral type");
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t size() noexcept { return sizeof...(_Ip); }
};

template <size_t... _Ip>
using index_sequence = integer_sequence<size_t, _Ip...>;



template <class _Tp, _Tp _Ep>
using make_integer_sequence __attribute__((__nodebug__)) = __make_integer_seq<integer_sequence, _Tp, _Ep>;
# 72 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/integer_sequence.h" 3
template <size_t _Np>
using make_index_sequence = make_integer_sequence<size_t, _Np>;

template <class... _Tp>
using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;



template <size_t... _Index, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __for_each_index_sequence(index_sequence<_Index...>, _Function __func) {
  (__func.template operator()<_Index>(), ...);
}




}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_indices.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_indices.h" 3




 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <size_t...>
struct __tuple_indices {};

template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices {
  static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
  typedef __make_indices_imp<_Ep, _Sp> type;
};

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_element.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_element.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <size_t _Ip, class _Tp>
struct tuple_element;

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, const _Tp> {
  typedef __attribute__((__nodebug__)) typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, volatile _Tp> {
  typedef __attribute__((__nodebug__)) typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, const volatile _Tp> {
  typedef __attribute__((__nodebug__)) typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};
# 72 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_element.h" 3
template <size_t _Ip, class... _Types>
struct tuple_element<_Ip, __tuple_types<_Types...> > {
  static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
  typedef __attribute__((__nodebug__)) __type_pack_element<_Ip, _Types...> type;
};


template <size_t _Ip, class... _Tp>
using tuple_element_t __attribute__((__nodebug__)) = typename tuple_element<_Ip, _Tp...>::type;




}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/make_tuple_types.h" 2 3
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/make_tuple_types.h" 3




 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {






template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;

template <template <class...> class _Tuple, class... _Types, size_t... _Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {

  template <class _Tp>
  using __apply_quals __attribute__((__nodebug__)) = __tuple_types<__apply_cv_t<_Tp, __type_pack_element<_Idx, _Types...>>...>;
};

template <class _Vt, size_t _Np, size_t... _Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t>
  using __value_type = _Vt;
  template <class _Tp>
  using __apply_quals = __tuple_types<__apply_cv_t<_Tp, __value_type<_Idx>>...>;
};

template <class _Tp,
          size_t _Ep = tuple_size<__libcpp_remove_reference_t<_Tp> >::value,
          size_t _Sp = 0,
          bool _SameSize = (_Ep == tuple_size<__libcpp_remove_reference_t<_Tp> >::value)>
struct __make_tuple_types {
  static_assert(_Sp <= _Ep, "__make_tuple_types input error");
  using _RawTp = __remove_cv_t<__libcpp_remove_reference_t<_Tp> >;
  using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
  using type = typename _Maker::template __apply_quals<_Tp>;
};

template <class... _Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __attribute__((__nodebug__)) __tuple_types<_Types...> type;
};

template <class... _Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __attribute__((__nodebug__)) __tuple_types<_Types...> type;
};

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/sfinae_helpers.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like_ext.h" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like_ext.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __tuple_like_ext : false_type {};

template <class _Tp>
struct __tuple_like_ext<const _Tp> : public __tuple_like_ext<_Tp> {};
template <class _Tp>
struct __tuple_like_ext<volatile _Tp> : public __tuple_like_ext<_Tp> {};
template <class _Tp>
struct __tuple_like_ext<const volatile _Tp> : public __tuple_like_ext<_Tp> {};


template <class... _Tp>
struct __tuple_like_ext<tuple<_Tp...> > : true_type {};


template <class _T1, class _T2>
struct __tuple_like_ext<pair<_T1, _T2> > : true_type {};

template <class _Tp, size_t _Size>
struct __tuple_like_ext<array<_Tp, _Size> > : true_type {};

template <class... _Tp>
struct __tuple_like_ext<__tuple_types<_Tp...> > : true_type {};

}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/sfinae_helpers.h" 2 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/sfinae_helpers.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <bool... _Preds>
struct __all_dummy;

template <bool... _Pred>
struct __all : _IsSame<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>> {};

struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait, class... _LArgs, class... _RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
      -> __all<__enable_if_t<_Trait<_LArgs, _RArgs>::value, bool>{true}...>;
  template <template <class...> class>
  static auto __do_test(...) -> false_type;

  template <class _FromArgs, class _ToArgs>
  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
};



template <class _Tp,
          class _Up,
          bool = __tuple_like_ext<__libcpp_remove_reference_t<_Tp> >::value,
          bool = __tuple_like_ext<_Up>::value>
struct __tuple_constructible : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible< typename __make_tuple_types<_Tp>::type,
                                                   typename __make_tuple_types<_Up>::type > {};

template <size_t _Ip, class... _Tp>
struct tuple_element<_Ip, tuple<_Tp...> > {
  typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};

struct __attribute__((__visibility__("default"))) __check_tuple_constructor_fail {
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_explicit_default() { return false; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_implicit_default() { return false; }
  template <class...>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_explicit() {
    return false;
  }
  template <class...>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_implicit() {
    return false;
  }
  template <class...>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_assign() {
    return false;
  }
};




template <bool _CanCopy, bool _CanMove>
struct __sfinae_ctor_base {};
template <>
struct __sfinae_ctor_base<false, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base&&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<true, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base(__sfinae_ctor_base&&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<false, true> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base&&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};

template <bool _CanCopy, bool _CanMove>
struct __sfinae_assign_base {};
template <>
struct __sfinae_assign_base<false, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base&&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<true, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base&&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<false, true> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base&&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = default;
};


}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_copy_assignable.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_copy_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_copy_assignable
    : public integral_constant<
          bool,
          __is_assignable(__add_lvalue_reference_t<_Tp>, __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};


template <class _Tp>
inline constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;


}}
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_default_constructible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_default_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_default_constructible : public integral_constant<bool, __is_constructible(_Tp)> {};


template <class _Tp>
inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);


}}
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_implicitly_default_constructible.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_implicitly_default_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {






template <class _Tp>
void __test_implicit_default_constructible(_Tp);

template <class _Tp, class = void, class = typename is_default_constructible<_Tp>::type>
struct __is_implicitly_default_constructible : false_type {};

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp,
                                             decltype(std::__test_implicit_default_constructible<_Tp const&>({})),
                                             true_type> : true_type {};

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp,
                                             decltype(std::__test_implicit_default_constructible<_Tp const&>({})),
                                             false_type> : false_type {};


}}
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_copy_assignable.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_copy_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_nothrow_copy_assignable
    : public integral_constant<bool,
                               __is_nothrow_assignable(__add_lvalue_reference_t<_Tp>,
                                                       __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};


template <class _Tp>
inline constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Tp>::value;


}}
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 3
template <class _Tp>
struct is_nothrow_copy_constructible
    : public integral_constant<
          bool,
          __is_nothrow_constructible(_Tp, typename add_lvalue_reference<typename add_const<_Tp>::type>::type)> {};




template <class _Tp>
inline constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Tp>::value;


}}
# 41 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_default_constructible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_default_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_nothrow_default_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp)> {};


template <class _Tp>
inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Tp);


}}
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3





# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/unwrap_ref.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/unwrap_ref.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __unwrap_reference {
  typedef __attribute__((__nodebug__)) _Tp type;
};

template <class _Tp>
struct __unwrap_reference<reference_wrapper<_Tp> > {
  typedef __attribute__((__nodebug__)) _Tp& type;
};


template <class _Tp>
struct unwrap_reference : __unwrap_reference<_Tp> {};

template <class _Tp>
using unwrap_reference_t = typename unwrap_reference<_Tp>::type;

template <class _Tp>
struct unwrap_ref_decay : unwrap_reference<__decay_t<_Tp> > {};

template <class _Tp>
using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;


template <class _Tp>
struct __unwrap_ref_decay

    : unwrap_ref_decay<_Tp>



{
};

}}
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/piecewise_construct.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/piecewise_construct.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

struct piecewise_construct_t {
  explicit piecewise_construct_t() = default;
};


inline constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();




}}
# 52 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 56 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 60 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class, class>
struct __non_trivially_copyable_base {
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __non_trivially_copyable_base() noexcept {}
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
  __non_trivially_copyable_base(__non_trivially_copyable_base const&) noexcept {}
};


template <class _Tp>
struct __is_specialization_of_subrange : false_type {};

template <class _Iter, class _Sent, ranges::subrange_kind _Kind>
struct __is_specialization_of_subrange<ranges::subrange<_Iter, _Sent, _Kind>> : true_type {};


template <class _T1, class _T2>
struct pair



{
  using first_type = _T1;
  using second_type = _T2;

  _T1 first;
  _T2 second;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) pair(pair const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) pair(pair&&) = default;
# 121 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3
  struct _CheckArgs {
    template <int&...>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_implicit_default() {
      return __is_implicitly_default_constructible<_T1>::value && __is_implicitly_default_constructible<_T2>::value;
    }

    template <int&...>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_default() {
      return is_default_constructible<_T1>::value && is_default_constructible<_T2>::value;
    }

    template <class _U1, class _U2>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __is_pair_constructible() {
      return is_constructible<first_type, _U1>::value && is_constructible<second_type, _U2>::value;
    }

    template <class _U1, class _U2>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __is_implicit() {
      return is_convertible<_U1, first_type>::value && is_convertible<_U2, second_type>::value;
    }
  };

  template <bool _MaybeEnable>
  using _CheckArgsDep __attribute__((__nodebug__)) =
      typename conditional< _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;

  template <bool _Dummy = true, __enable_if_t<_CheckArgsDep<_Dummy>::__enable_default(), int> = 0>
  explicit(!_CheckArgsDep<_Dummy>::__enable_implicit_default()) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair()
      noexcept(is_nothrow_default_constructible<first_type>::value&& is_nothrow_default_constructible<second_type>::value)

      : first(), second() {}

  template <bool _Dummy = true,
            __enable_if_t<_CheckArgsDep<_Dummy>::template __is_pair_constructible<_T1 const&, _T2 const&>(), int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      !_CheckArgsDep<_Dummy>::template __is_implicit<_T1 const&, _T2 const&>()) pair(_T1 const& __t1, _T2 const& __t2)
      noexcept(is_nothrow_copy_constructible<first_type>::value&& is_nothrow_copy_constructible<second_type>::value)
      : first(__t1), second(__t2) {}

  template <

      class _U1 = _T1,
      class _U2 = _T2,




      __enable_if_t<_CheckArgs::template __is_pair_constructible<_U1, _U2>(), int> = 0 >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_CheckArgs::template __is_implicit<_U1, _U2>())
      pair(_U1&& __u1, _U2&& __u2)
          noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

      : first(std::forward<_U1>(__u1)), second(std::forward<_U2>(__u2)) {
  }


  template <class _U1, class _U2, __enable_if_t<_CheckArgs::template __is_pair_constructible<_U1&, _U2&>(), int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_CheckArgs::template __is_implicit<_U1&, _U2&>())
      pair(pair<_U1, _U2>& __p) noexcept((is_nothrow_constructible<first_type, _U1&>::value &&
                                          is_nothrow_constructible<second_type, _U2&>::value))
      : first(__p.first), second(__p.second) {}


  template <class _U1,
            class _U2,
            __enable_if_t<_CheckArgs::template __is_pair_constructible<_U1 const&, _U2 const&>(), int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      !_CheckArgs::template __is_implicit<_U1 const&, _U2 const&>()) pair(pair<_U1, _U2> const& __p)
      noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

      : first(__p.first), second(__p.second) {}

  template <class _U1, class _U2, __enable_if_t<_CheckArgs::template __is_pair_constructible<_U1, _U2>(), int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_CheckArgs::template __is_implicit<_U1, _U2>())
      pair(pair<_U1, _U2>&& __p)
          noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

      : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second)) {}


  template <class _U1,
            class _U2,
            __enable_if_t<_CheckArgs::template __is_pair_constructible<const _U1&&, const _U2&&>(), int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_CheckArgs::template __is_implicit<const _U1&&, const _U2&&>())
      pair(const pair<_U1, _U2>&& __p) noexcept(is_nothrow_constructible<first_type, const _U1&&>::value &&
                                                is_nothrow_constructible<second_type, const _U2&&>::value)
      : first(std::move(__p.first)), second(std::move(__p.second)) {}




  template <class _PairLike>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr bool __pair_like_explicit_wknd() {
    if constexpr (__pair_like<_PairLike>) {
      return !is_convertible_v<decltype(std::get<0>(std::declval<_PairLike&&>())), first_type> ||
             !is_convertible_v<decltype(std::get<1>(std::declval<_PairLike&&>())), second_type>;
    }
    return false;
  }

  template <__pair_like _PairLike>
    requires(!__is_specialization_of_subrange<remove_cvref_t<_PairLike>>::value &&
             is_constructible_v<first_type, decltype(std::get<0>(std::declval<_PairLike &&>()))> &&
             is_constructible_v<second_type, decltype(std::get<1>(std::declval<_PairLike &&>()))>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(__pair_like_explicit_wknd<_PairLike>()) pair(_PairLike&& __p)
      : first(std::get<0>(std::forward<_PairLike>(__p))), second(std::get<1>(std::forward<_PairLike>(__p))) {}


  template <class... _Args1, class... _Args2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args) noexcept(is_nothrow_constructible<first_type, _Args1...>::value&& is_nothrow_constructible<second_type, _Args2...>::value)

      : pair(__pc,
             __first_args,
             __second_args,
             typename __make_tuple_indices<sizeof...(_Args1)>::type(),
             typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair&
  operator=(__conditional_t< is_copy_assignable<first_type>::value && is_copy_assignable<second_type>::value,
                             pair,
                             __nat> const& __p)
      noexcept(is_nothrow_copy_assignable<first_type>::value&& is_nothrow_copy_assignable<second_type>::value) {
    first = __p.first;
    second = __p.second;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair& operator=(
      __conditional_t< is_move_assignable<first_type>::value && is_move_assignable<second_type>::value, pair, __nat>&&
          __p)
      noexcept(is_nothrow_move_assignable<first_type>::value&& is_nothrow_move_assignable<second_type>::value) {
    first = std::forward<first_type>(__p.first);
    second = std::forward<second_type>(__p.second);
    return *this;
  }

  template <
      class _U1,
      class _U2,
      __enable_if_t<is_assignable<first_type&, _U1 const&>::value && is_assignable<second_type&, _U2 const&>::value,
                    int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair& operator=(pair<_U1, _U2> const& __p) {
    first = __p.first;
    second = __p.second;
    return *this;
  }

  template <class _U1,
            class _U2,
            __enable_if_t<is_assignable<first_type&, _U1>::value && is_assignable<second_type&, _U2>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair& operator=(pair<_U1, _U2>&& __p) {
    first = std::forward<_U1>(__p.first);
    second = std::forward<_U2>(__p.second);
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const pair& operator=(pair const& __p) const
      noexcept(is_nothrow_copy_assignable_v<const first_type> && is_nothrow_copy_assignable_v<const second_type>)
    requires(is_copy_assignable_v<const first_type> && is_copy_assignable_v<const second_type>)
  {
    first = __p.first;
    second = __p.second;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const pair& operator=(pair&& __p) const
      noexcept(is_nothrow_assignable_v<const first_type&, first_type> &&
               is_nothrow_assignable_v<const second_type&, second_type>)
    requires(is_assignable_v<const first_type&, first_type> && is_assignable_v<const second_type&, second_type>)
  {
    first = std::forward<first_type>(__p.first);
    second = std::forward<second_type>(__p.second);
    return *this;
  }

  template <class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const pair& operator=(const pair<_U1, _U2>& __p) const
    requires(is_assignable_v<const first_type&, const _U1&> && is_assignable_v<const second_type&, const _U2&>)
  {
    first = __p.first;
    second = __p.second;
    return *this;
  }

  template <class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const pair& operator=(pair<_U1, _U2>&& __p) const
    requires(is_assignable_v<const first_type&, _U1> && is_assignable_v<const second_type&, _U2>)
  {
    first = std::forward<_U1>(__p.first);
    second = std::forward<_U2>(__p.second);
    return *this;
  }

  template <__pair_like _PairLike>
    requires(__different_from<_PairLike, pair> && !__is_specialization_of_subrange<remove_cvref_t<_PairLike>>::value &&
             is_assignable_v<first_type&, decltype(std::get<0>(std::declval<_PairLike>()))> &&
             is_assignable_v<second_type&, decltype(std::get<1>(std::declval<_PairLike>()))>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair& operator=(_PairLike&& __p) {
    first = std::get<0>(std::forward<_PairLike>(__p));
    second = std::get<1>(std::forward<_PairLike>(__p));
    return *this;
  }

  template <__pair_like _PairLike>
    requires(__different_from<_PairLike, pair> && !__is_specialization_of_subrange<remove_cvref_t<_PairLike>>::value &&
             is_assignable_v<first_type const&, decltype(std::get<0>(std::declval<_PairLike>()))> &&
             is_assignable_v<second_type const&, decltype(std::get<1>(std::declval<_PairLike>()))>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair const& operator=(_PairLike&& __p) const {
    first = std::get<0>(std::forward<_PairLike>(__p));
    second = std::get<1>(std::forward<_PairLike>(__p));
    return *this;
  }
# 426 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(pair& __p)
      noexcept(__is_nothrow_swappable<first_type>::value&& __is_nothrow_swappable<second_type>::value) {
    using std::swap;
    swap(first, __p.first);
    swap(second, __p.second);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(const pair& __p) const
      noexcept(__is_nothrow_swappable<const first_type>::value && __is_nothrow_swappable<const second_type>::value) {
    using std::swap;
    swap(first, __p.first);
    swap(second, __p.second);
  }


private:

  template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  pair(piecewise_construct_t,
       tuple<_Args1...>& __first_args,
       tuple<_Args2...>& __second_args,
       __tuple_indices<_I1...>,
       __tuple_indices<_I2...>);

};


template <class _T1, class _T2>
pair(_T1, _T2) -> pair<_T1, _T2>;




template <class _T1, class _T2, class _U1, class _U2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y) {
  return __x.first == __y.first && __x.second == __y.second;
}



template <class _T1, class _T2, class _U1, class _U2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr common_comparison_category_t< __synth_three_way_result<_T1, _U1>,
                                                              __synth_three_way_result<_T2, _U2> >
operator<=>(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y) {
  if (auto __c = std::__synth_three_way(__x.first, __y.first); __c != 0) {
    return __c;
  }
  return std::__synth_three_way(__x.second, __y.second);
}
# 514 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3
template <class _T1, class _T2, class _U1, class _U2, template <class> class _TQual, template <class> class _UQual>
  requires requires {
    typename pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>, common_reference_t<_TQual<_T2>, _UQual<_U2>>>;
  }
struct basic_common_reference<pair<_T1, _T2>, pair<_U1, _U2>, _TQual, _UQual> {
  using type = pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>, common_reference_t<_TQual<_T2>, _UQual<_U2>>>;
};

template <class _T1, class _T2, class _U1, class _U2>
  requires requires { typename pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>; }
struct common_type<pair<_T1, _T2>, pair<_U1, _U2>> {
  using type = pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>;
};


template <class _T1, class _T2, __enable_if_t<__is_swappable<_T1>::value && __is_swappable<_T2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value&& __is_nothrow_swappable<_T2>::value) {
  __x.swap(__y);
}


template <class _T1, class _T2>
  requires(__is_swappable<const _T1>::value && __is_swappable<const _T2>::value)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
swap(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}


template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
    pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
    make_pair(_T1&& __t1, _T2&& __t2) {
  return pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>(
      std::forward<_T1>(__t1), std::forward<_T2>(__t2));
}

template <class _T1, class _T2>
struct tuple_size<pair<_T1, _T2> > : public integral_constant<size_t, 2> {};

template <size_t _Ip, class _T1, class _T2>
struct tuple_element<_Ip, pair<_T1, _T2> > {
  static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};

template <class _T1, class _T2>
struct tuple_element<0, pair<_T1, _T2> > {
  using type __attribute__((__nodebug__)) = _T1;
};

template <class _T1, class _T2>
struct tuple_element<1, pair<_T1, _T2> > {
  using type __attribute__((__nodebug__)) = _T2;
};

template <size_t _Ip>
struct __get_pair;

template <>
struct __get_pair<0> {
  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1& get(pair<_T1, _T2>& __p) noexcept {
    return __p.first;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _T1& get(const pair<_T1, _T2>& __p) noexcept {
    return __p.first;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1&& get(pair<_T1, _T2>&& __p) noexcept {
    return std::forward<_T1>(__p.first);
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _T1&& get(const pair<_T1, _T2>&& __p) noexcept {
    return std::forward<const _T1>(__p.first);
  }
};

template <>
struct __get_pair<1> {
  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T2& get(pair<_T1, _T2>& __p) noexcept {
    return __p.second;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _T2& get(const pair<_T1, _T2>& __p) noexcept {
    return __p.second;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T2&& get(pair<_T1, _T2>&& __p) noexcept {
    return std::forward<_T2>(__p.second);
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _T2&& get(const pair<_T1, _T2>&& __p) noexcept {
    return std::forward<const _T2>(__p.second);
  }
};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) noexcept {
  return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) noexcept {
  return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) noexcept {
  return __get_pair<_Ip>::get(std::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) noexcept {
  return __get_pair<_Ip>::get(std::move(__p));
}


template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1& get(pair<_T1, _T2>& __p) noexcept {
  return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 const& get(pair<_T1, _T2> const& __p) noexcept {
  return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1&& get(pair<_T1, _T2>&& __p) noexcept {
  return __get_pair<0>::get(std::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 const&& get(pair<_T1, _T2> const&& __p) noexcept {
  return __get_pair<0>::get(std::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1& get(pair<_T2, _T1>& __p) noexcept {
  return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 const& get(pair<_T2, _T1> const& __p) noexcept {
  return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1&& get(pair<_T2, _T1>&& __p) noexcept {
  return __get_pair<1>::get(std::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 const&& get(pair<_T2, _T1> const&& __p) noexcept {
  return __get_pair<1>::get(std::move(__p));
}



}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2, class _Sentinel2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2, _Sentinel2 __last2) {
  while (__first1 != __last1 && __first2 != __last2) {
    _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
    ++__first1;
    ++__first2;
  }

  return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}


template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2) {
  while (__first1 != __last1) {
    _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
    ++__first1;
    ++__first2;
  }

  return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  return std::__swap_ranges<_ClassicAlgPolicy>(std::move(__first1), std::move(__last1), std::move(__first2)).second;
}

}}
# 119 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way_result.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way_result.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class, class, class>
struct __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __compare_three_way_result {};

template <class _Tp, class _Up>
struct __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __compare_three_way_result<
    _Tp,
    _Up,
    decltype(std::declval<__make_const_lvalue_ref<_Tp>>() <=> std::declval<__make_const_lvalue_ref<_Up>>(), void())> {
  using type = decltype(std::declval<__make_const_lvalue_ref<_Tp>>() <=> std::declval<__make_const_lvalue_ref<_Up>>());
};

template <class _Tp, class _Up = _Tp>
struct compare_three_way_result : __compare_three_way_result<_Tp, _Up, void> {};

template <class _Tp, class _Up = _Tp>
using compare_three_way_result_t = typename compare_three_way_result<_Tp, _Up>::type;



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Category, class _Tp, class _Distance = ptrdiff_t, class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__((__deprecated__)) iterator {
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
  typedef _Category iterator_category;
};

}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3




# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/segmented_iterator.h" 1 3
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/segmented_iterator.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Iterator>
struct __segmented_iterator_traits;
# 68 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/segmented_iterator.h" 3
template <class _Tp, size_t = 0>
struct __has_specialization : false_type {};

template <class _Tp>
struct __has_specialization<_Tp, sizeof(_Tp) * 0> : true_type {};

template <class _Iterator>
using __is_segmented_iterator = __has_specialization<__segmented_iterator_traits<_Iterator> >;

}}
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 1 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/dangling.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/dangling.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {
struct dangling {
  dangling() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr dangling(auto&&...) noexcept {}
};

template <range _Rp>
using borrowed_iterator_t = _If<borrowed_range<_Rp>, iterator_t<_Rp>, dangling>;


}



}}
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/view_interface.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/view_interface.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/empty.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/empty.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





namespace ranges {
namespace __empty {
template <class _Tp>
concept __member_empty = __workaround_52970<_Tp> && requires(_Tp&& __t) { bool(__t.empty()); };

template <class _Tp>
concept __can_invoke_size = !__member_empty<_Tp> && requires(_Tp&& __t) { ranges::size(__t); };

template <class _Tp>
concept __can_compare_begin_end = !__member_empty<_Tp> && !__can_invoke_size<_Tp> && requires(_Tp&& __t) {
  bool(ranges::begin(__t) == ranges::end(__t));
  { ranges::begin(__t) } -> forward_iterator;
};

struct __fn {
  template <__member_empty _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(_Tp&& __t) const noexcept(noexcept(bool(__t.empty()))) {
    return bool(__t.empty());
  }

  template <__can_invoke_size _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(_Tp&& __t) const noexcept(noexcept(ranges::size(__t))) {
    return ranges::size(__t) == 0;
  }

  template <__can_compare_begin_end _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(_Tp&& __t) const
      noexcept(noexcept(bool(ranges::begin(__t) == ranges::end(__t)))) {
    return ranges::begin(__t) == ranges::end(__t);
  }
};
}

inline namespace __cpo {
inline constexpr auto empty = __empty::__fn{};
}
}



}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/view_interface.h" 2 3
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/view_interface.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {

template <class _Derived>
  requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
class view_interface {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Derived& __derived() noexcept {
    static_assert(sizeof(_Derived) && derived_from<_Derived, view_interface> && view<_Derived>);
    return static_cast<_Derived&>(*this);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Derived const& __derived() const noexcept {
    static_assert(sizeof(_Derived) && derived_from<_Derived, view_interface> && view<_Derived>);
    return static_cast<_Derived const&>(*this);
  }

public:
  template <class _D2 = _Derived>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty()
    requires forward_range<_D2>
  {
    return ranges::begin(__derived()) == ranges::end(__derived());
  }

  template <class _D2 = _Derived>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty() const
    requires forward_range<const _D2>
  {
    return ranges::begin(__derived()) == ranges::end(__derived());
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit operator bool()
    requires requires(_D2& __t) { ranges::empty(__t); }
  {
    return !ranges::empty(__derived());
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit operator bool() const
    requires requires(const _D2& __t) { ranges::empty(__t); }
  {
    return !ranges::empty(__derived());
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto data()
    requires contiguous_iterator<iterator_t<_D2>>
  {
    return std::to_address(ranges::begin(__derived()));
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto data() const
    requires range<const _D2> && contiguous_iterator<iterator_t<const _D2>>
  {
    return std::to_address(ranges::begin(__derived()));
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto size()
    requires forward_range<_D2> && sized_sentinel_for<sentinel_t<_D2>, iterator_t<_D2>>
  {
    return std::__to_unsigned_like(ranges::end(__derived()) - ranges::begin(__derived()));
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto size() const
    requires forward_range<const _D2> && sized_sentinel_for<sentinel_t<const _D2>, iterator_t<const _D2>>
  {
    return std::__to_unsigned_like(ranges::end(__derived()) - ranges::begin(__derived()));
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) front()
    requires forward_range<_D2>
  {
    ((void)0);

    return *ranges::begin(__derived());
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) front() const
    requires forward_range<const _D2>
  {
    ((void)0);

    return *ranges::begin(__derived());
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) back()
    requires bidirectional_range<_D2> && common_range<_D2>
  {
    ((void)0);

    return *ranges::prev(ranges::end(__derived()));
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) back() const
    requires bidirectional_range<const _D2> && common_range<const _D2>
  {
    ((void)0);

    return *ranges::prev(ranges::end(__derived()));
  }

  template <random_access_range _RARange = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) operator[](range_difference_t<_RARange> __index) {
    return ranges::begin(__derived())[__index];
  }

  template <random_access_range _RARange = const _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) operator[](range_difference_t<_RARange> __index) const {
    return ranges::begin(__derived())[__index];
  }
};

}



}}
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 2 3
# 46 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 50 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {
template <class _From, class _To>
concept __uses_nonqualification_pointer_conversion =
    is_pointer_v<_From> && is_pointer_v<_To> &&
    !convertible_to<remove_pointer_t<_From> (*)[], remove_pointer_t<_To> (*)[]>;

template <class _From, class _To>
concept __convertible_to_non_slicing =
    convertible_to<_From, _To> && !__uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>;

template <class _Pair, class _Iter, class _Sent>
concept __pair_like_convertible_from =
    !range<_Pair> && __pair_like<_Pair> && constructible_from<_Pair, _Iter, _Sent> &&
    __convertible_to_non_slicing<_Iter, tuple_element_t<0, _Pair>> && convertible_to<_Sent, tuple_element_t<1, _Pair>>;

template <input_or_output_iterator _Iter,
          sentinel_for<_Iter> _Sent = _Iter,
          subrange_kind _Kind = sized_sentinel_for<_Sent, _Iter> ? subrange_kind::sized : subrange_kind::unsized>
  requires(_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _Iter>)
class subrange : public view_interface<subrange<_Iter, _Sent, _Kind>> {
public:

  static constexpr bool _StoreSize = (_Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _Iter>);

private:
  static constexpr bool _MustProvideSizeAtConstruction = !_StoreSize;
  struct _Empty {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Empty(auto) noexcept {}
  };
  using _Size = conditional_t<_StoreSize, make_unsigned_t<iter_difference_t<_Iter>>, _Empty>;
  [[__no_unique_address__]] _Iter __begin_ = _Iter();
  [[__no_unique_address__]] _Sent __end_ = _Sent();
  [[__no_unique_address__]] _Size __size_ = 0;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) subrange()
    requires default_initializable<_Iter>
  = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange(__convertible_to_non_slicing<_Iter> auto __iter, _Sent __sent)
    requires _MustProvideSizeAtConstruction
      : __begin_(std::move(__iter)), __end_(std::move(__sent)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange(
      __convertible_to_non_slicing<_Iter> auto __iter, _Sent __sent, make_unsigned_t<iter_difference_t<_Iter>> __n)
    requires(_Kind == subrange_kind::sized)
      : __begin_(std::move(__iter)), __end_(std::move(__sent)), __size_(__n) {
    if constexpr (sized_sentinel_for<_Sent, _Iter>)
      ((void)0);

  }

  template <__different_from<subrange> _Range>
    requires borrowed_range<_Range> && __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
             convertible_to<sentinel_t<_Range>, _Sent>
             __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange(_Range&& __range)
               requires(!_StoreSize)
      : subrange(ranges::begin(__range), ranges::end(__range)) {}

  template <__different_from<subrange> _Range>
    requires borrowed_range<_Range> && __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
             convertible_to<sentinel_t<_Range>, _Sent>
             __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange(_Range&& __range)
               requires _StoreSize && sized_range<_Range>
      : subrange(__range, ranges::size(__range)) {}

  template <borrowed_range _Range>
    requires __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
             convertible_to<sentinel_t<_Range>, _Sent>
             __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange(_Range&& __range, make_unsigned_t<iter_difference_t<_Iter>> __n)
               requires(_Kind == subrange_kind::sized)
      : subrange(ranges::begin(__range), ranges::end(__range), __n) {}

  template <__different_from<subrange> _Pair>
    requires __pair_like_convertible_from<_Pair, const _Iter&, const _Sent&>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator _Pair() const {
    return _Pair(__begin_, __end_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter begin() const
    requires copyable<_Iter>
  {
    return __begin_;
  }

  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter begin()
    requires(!copyable<_Iter>)
  {
    return std::move(__begin_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Sent end() const { return __end_; }

  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty() const { return __begin_ == __end_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr make_unsigned_t<iter_difference_t<_Iter>> size() const
    requires(_Kind == subrange_kind::sized)
  {
    if constexpr (_StoreSize)
      return __size_;
    else
      return std::__to_unsigned_like(__end_ - __begin_);
  }

  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange next(iter_difference_t<_Iter> __n = 1) const&
    requires forward_iterator<_Iter>
  {
    auto __tmp = *this;
    __tmp.advance(__n);
    return __tmp;
  }

  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange next(iter_difference_t<_Iter> __n = 1) && {
    advance(__n);
    return std::move(*this);
  }

  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange prev(iter_difference_t<_Iter> __n = 1) const
    requires bidirectional_iterator<_Iter>
  {
    auto __tmp = *this;
    __tmp.advance(-__n);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange& advance(iter_difference_t<_Iter> __n) {
    if constexpr (bidirectional_iterator<_Iter>) {
      if (__n < 0) {
        ranges::advance(__begin_, __n);
        if constexpr (_StoreSize)
          __size_ += std::__to_unsigned_like(-__n);
        return *this;
      }
    }

    auto __d = __n - ranges::advance(__begin_, __n, __end_);
    if constexpr (_StoreSize)
      __size_ -= std::__to_unsigned_like(__d);
    return *this;
  }
};

template <input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent>
subrange(_Iter, _Sent) -> subrange<_Iter, _Sent>;

template <input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent>
subrange(_Iter, _Sent, make_unsigned_t<iter_difference_t<_Iter>>) -> subrange<_Iter, _Sent, subrange_kind::sized>;

template <borrowed_range _Range>
subrange(_Range&&)
    -> subrange<iterator_t<_Range>,
                sentinel_t<_Range>,
                (sized_range<_Range> || sized_sentinel_for<sentinel_t<_Range>, iterator_t<_Range>>)
                    ? subrange_kind::sized
                    : subrange_kind::unsized>;

template <borrowed_range _Range>
subrange(_Range&&, make_unsigned_t<range_difference_t<_Range>>)
    -> subrange<iterator_t<_Range>, sentinel_t<_Range>, subrange_kind::sized>;

template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires((_Index == 0 && copyable<_Iter>) || _Index == 1)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto get(const subrange<_Iter, _Sent, _Kind>& __subrange) {
  if constexpr (_Index == 0)
    return __subrange.begin();
  else
    return __subrange.end();
}

template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires(_Index < 2)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto get(subrange<_Iter, _Sent, _Kind>&& __subrange) {
  if constexpr (_Index == 0)
    return __subrange.begin();
  else
    return __subrange.end();
}

template <class _Ip, class _Sp, subrange_kind _Kp>
inline constexpr bool enable_borrowed_range<subrange<_Ip, _Sp, _Kp>> = true;

template <range _Rp>
using borrowed_subrange_t = _If<borrowed_range<_Rp>, subrange<iterator_t<_Rp>>, dangling>;
}



using ranges::get;



template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_size<ranges::subrange<_Ip, _Sp, _Kp>> : integral_constant<size_t, 2> {};

template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<0, ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Ip;
};

template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<1, ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Sp;
};

template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<0, const ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Ip;
};

template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<1, const ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Sp;
};



}}
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

#pragma GCC diagnostic push
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Iter>
class reverse_iterator

    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>

{
#pragma GCC diagnostic pop

private:

  _Iter __t_;



  static_assert(__has_bidirectional_iterator_category<_Iter>::value || bidirectional_iterator<_Iter>,
                "reverse_iterator<It> requires It to be a bidirectional iterator.");


protected:
  _Iter current;

public:
  using iterator_type = _Iter;

  using iterator_category =
      _If<__has_random_access_iterator_category<_Iter>::value,
          random_access_iterator_tag,
          typename iterator_traits<_Iter>::iterator_category>;
  using pointer = typename iterator_traits<_Iter>::pointer;

  using iterator_concept = _If<random_access_iterator<_Iter>, random_access_iterator_tag, bidirectional_iterator_tag>;
  using value_type = iter_value_t<_Iter>;
  using difference_type = iter_difference_t<_Iter>;
  using reference = iter_reference_t<_Iter>;







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator() : __t_(), current() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit reverse_iterator(_Iter __x) : __t_(__x), current(__x) {}

  template <class _Up, __enable_if_t<!is_same<_Up, _Iter>::value && is_convertible<_Up const&, _Iter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator(const reverse_iterator<_Up>& __u)
      : __t_(__u.base()), current(__u.base()) {}

  template <class _Up,
            __enable_if_t<!is_same<_Up, _Iter>::value && is_convertible<_Up const&, _Iter>::value &&
                              is_assignable<_Iter&, _Up const&>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator& operator=(const reverse_iterator<_Up>& __u) {
    __t_ = current = __u.base();
    return *this;
  }
# 129 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter base() const { return current; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator*() const {
    _Iter __tmp = current;
    return *--__tmp;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer operator->() const
    requires is_pointer_v<_Iter> || requires(const _Iter __i) { __i.operator->(); }
  {
    if constexpr (is_pointer_v<_Iter>) {
      return std::prev(current);
    } else {
      return std::prev(current).operator->();
    }
  }




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator& operator++() {
    --current;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator operator++(int) {
    reverse_iterator __tmp(*this);
    --current;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator& operator--() {
    ++current;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator operator--(int) {
    reverse_iterator __tmp(*this);
    ++current;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator operator+(difference_type __n) const {
    return reverse_iterator(current - __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator operator-(difference_type __n) const {
    return reverse_iterator(current + __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator[](difference_type __n) const {
    return *(*this + __n);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr iter_rvalue_reference_t<_Iter> iter_move(const reverse_iterator& __i) noexcept(
      is_nothrow_copy_constructible_v<_Iter>&& noexcept(ranges::iter_move(--std::declval<_Iter&>()))) {
    auto __tmp = __i.base();
    return ranges::iter_move(--__tmp);
  }

  template <indirectly_swappable<_Iter> _Iter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr void
  iter_swap(const reverse_iterator& __x, const reverse_iterator<_Iter2>& __y) noexcept(
      is_nothrow_copy_constructible_v<_Iter> &&
      is_nothrow_copy_constructible_v<_Iter2>&& noexcept(
          ranges::iter_swap(--std::declval<_Iter&>(), --std::declval<_Iter2&>()))) {
    auto __xtmp = __x.base();
    auto __ytmp = __y.base();
    ranges::iter_swap(--__xtmp, --__ytmp);
  }

};

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() == __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() > __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() != __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() < __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() <= __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() >= __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() >= __y.base();
}


template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr compare_three_way_result_t<_Iter1, _Iter2>
operator<=>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y) {
  return __y.base() <=> __x.base();
}



template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    -> decltype(__y.base() - __x.base()) {
  return __y.base() - __x.base();
}
# 300 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x) {
  return reverse_iterator<_Iter>(__x.base() - __n);
}


template <class _Iter1, class _Iter2>
  requires(!sized_sentinel_for<_Iter1, _Iter2>)
inline constexpr bool disable_sized_sentinel_for<reverse_iterator<_Iter1>, reverse_iterator<_Iter2>> = true;



template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator<_Iter> make_reverse_iterator(_Iter __i) {
  return reverse_iterator<_Iter>(__i);
}
# 346 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
template <class _Iter>
class __unconstrained_reverse_iterator {
  _Iter __iter_;

public:
  static_assert(__has_bidirectional_iterator_category<_Iter>::value || bidirectional_iterator<_Iter>);

  using iterator_type = _Iter;
  using iterator_category =
      _If<__has_random_access_iterator_category<_Iter>::value,
          random_access_iterator_tag,
          __iterator_category_type<_Iter>>;
  using pointer = __iterator_pointer_type<_Iter>;
  using value_type = iter_value_t<_Iter>;
  using difference_type = iter_difference_t<_Iter>;
  using reference = iter_reference_t<_Iter>;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator(const __unconstrained_reverse_iterator&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __unconstrained_reverse_iterator(_Iter __iter) : __iter_(__iter) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter base() const { return __iter_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator*() const {
    auto __tmp = __iter_;
    return *--__tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer operator->() const {
    if constexpr (is_pointer_v<_Iter>) {
      return std::prev(__iter_);
    } else {
      return std::prev(__iter_).operator->();
    }
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr iter_rvalue_reference_t<_Iter>
  iter_move(const __unconstrained_reverse_iterator& __i) noexcept(
      is_nothrow_copy_constructible_v<_Iter>&& noexcept(ranges::iter_move(--std::declval<_Iter&>()))) {
    auto __tmp = __i.base();
    return ranges::iter_move(--__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator& operator++() {
    --__iter_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator operator++(int) {
    auto __tmp = *this;
    --__iter_;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator& operator--() {
    ++__iter_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator operator--(int) {
    auto __tmp = *this;
    ++__iter_;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator& operator+=(difference_type __n) {
    __iter_ -= __n;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator& operator-=(difference_type __n) {
    __iter_ += __n;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator operator+(difference_type __n) const {
    return __unconstrained_reverse_iterator(__iter_ - __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator operator-(difference_type __n) const {
    return __unconstrained_reverse_iterator(__iter_ + __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr difference_type operator-(const __unconstrained_reverse_iterator& __other) const {
    return __other.__iter_ - __iter_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator[](difference_type __n) const { return *(*this + __n); }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator==(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() == __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator!=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() != __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator<(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() > __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator>(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() < __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator<=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() >= __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator>=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() <= __rhs.base();
  }
};



template <template <class> class _RevIter1, template <class> class _RevIter2, class _Iter>
struct __unwrap_reverse_iter_impl {
  using _UnwrappedIter = decltype(__unwrap_iter_impl<_Iter>::__unwrap(std::declval<_Iter>()));
  using _ReverseWrapper = _RevIter1<_RevIter2<_Iter> >;

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ReverseWrapper
  __rewrap(_ReverseWrapper __orig_iter, _UnwrappedIter __unwrapped_iter) {
    return _ReverseWrapper(
        _RevIter2<_Iter>(__unwrap_iter_impl<_Iter>::__rewrap(__orig_iter.base().base(), __unwrapped_iter)));
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _UnwrappedIter __unwrap(_ReverseWrapper __i) noexcept {
    return __unwrap_iter_impl<_Iter>::__unwrap(__i.base().base());
  }
};


template <ranges::bidirectional_range _Range>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr ranges::subrange<reverse_iterator<ranges::iterator_t<_Range>>,
                                                 reverse_iterator<ranges::iterator_t<_Range>>>
__reverse_range(_Range&& __range) {
  auto __first = ranges::begin(__range);
  return {std::make_reverse_iterator(ranges::next(__first, ranges::end(__range))), std::make_reverse_iterator(__first)};
}


template <class _Iter, bool __b>
struct __unwrap_iter_impl<reverse_iterator<reverse_iterator<_Iter> >, __b>
    : __unwrap_reverse_iter_impl<reverse_iterator, reverse_iterator, _Iter> {};



template <class _Iter, bool __b>
struct __unwrap_iter_impl<reverse_iterator<__unconstrained_reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<reverse_iterator, __unconstrained_reverse_iterator, _Iter> {};

template <class _Iter, bool __b>
struct __unwrap_iter_impl<__unconstrained_reverse_iterator<reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<__unconstrained_reverse_iterator, reverse_iterator, _Iter> {};

template <class _Iter, bool __b>
struct __unwrap_iter_impl<__unconstrained_reverse_iterator<__unconstrained_reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<__unconstrained_reverse_iterator, __unconstrained_reverse_iterator, _Iter> {};



}}
# 123 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/wrap_iter.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/wrap_iter.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Iter>
class __wrap_iter {
public:
  typedef _Iter iterator_type;
  typedef typename iterator_traits<iterator_type>::value_type value_type;
  typedef typename iterator_traits<iterator_type>::difference_type difference_type;
  typedef typename iterator_traits<iterator_type>::pointer pointer;
  typedef typename iterator_traits<iterator_type>::reference reference;
  typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;

  typedef contiguous_iterator_tag iterator_concept;


private:
  iterator_type __i_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter() noexcept : __i_() {}
  template <class _Up, __enable_if_t<is_convertible<_Up, iterator_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter(const __wrap_iter<_Up>& __u) noexcept
      : __i_(__u.base()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator*() const noexcept { return *__i_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer operator->() const noexcept {
    return std::__to_address(__i_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter& operator++() noexcept {
    ++__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter operator++(int) noexcept {
    __wrap_iter __tmp(*this);
    ++(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter& operator--() noexcept {
    --__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter operator--(int) noexcept {
    __wrap_iter __tmp(*this);
    --(*this);
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter operator+(difference_type __n) const noexcept {
    __wrap_iter __w(*this);
    __w += __n;
    return __w;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter& operator+=(difference_type __n) noexcept {
    __i_ += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter operator-(difference_type __n) const noexcept {
    return *this + (-__n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter& operator-=(difference_type __n) noexcept {
    *this += -__n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator[](difference_type __n) const noexcept {
    return __i_[__n];
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator_type base() const noexcept { return __i_; }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __wrap_iter(iterator_type __x) noexcept : __i_(__x) {}

  template <class _Up>
  friend class __wrap_iter;
  template <class _CharT, class _Traits, class _Alloc>
  friend class basic_string;
  template <class _CharT, class _Traits>
  friend class basic_string_view;
  template <class _Tp, class _Alloc>
  friend class vector;
  template <class _Tp, size_t>
  friend class span;
  template <class _Tp, size_t _Size>
  friend struct array;
};

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept {
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept {
  return __x.base() == __y.base();
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept {
  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept {
  return __x.base() < __y.base();
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept {
  return !(__x == __y);
}

template <class _It