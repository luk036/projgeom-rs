# 1 "src/persp_object.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 512 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "build/.objs/projgeom-cpp/linux/arm64/release/include/projgeom/cxx/pch.hpp" 1
#pragma system_header

# 1 "/data/data/com.termux/files/home/github/rs/projgeom-rs/cpp_ai/include/projgeom/pch.hpp" 1


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 1 3
# 114 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config_site" 1 3
# 44 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config_site" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wmacro-redefined"






#pragma clang diagnostic pop
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 2 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 3
# 457 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/features.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/features.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/cdefs.h" 1 3 4
# 336 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/cdefs.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/android/versioning.h" 1 3 4
# 61 "/data/data/com.termux/files/usr/bin/../../usr/include/android/versioning.h" 3 4
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc23-extensions"


#pragma clang diagnostic pop
# 337 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/cdefs.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/android/api-level.h" 1 3 4
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/android/api-level.h" 3 4
extern "C" {
# 194 "/data/data/com.termux/files/usr/bin/../../usr/include/android/api-level.h" 3 4
int android_get_application_target_sdk_version() __attribute__((__availability__(android,strict,introduced=24 )));







# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/get_device_api_level_inlines.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/get_device_api_level_inlines.h" 3 4
extern "C" {


int __system_property_get(const char* _Nonnull __name, char* _Nonnull __value);
int atoi(const char* _Nonnull __s) __attribute__((__pure__));

static __inline__ int android_get_device_api_level() {
  char value[92] = { 0 };
  if (__system_property_get("ro.build.version.sdk", value) < 1) return -1;
  int api_level = atoi(value);
  return (api_level > 0) ? api_level : -1;
}

}
# 203 "/data/data/com.termux/files/usr/bin/../../usr/include/android/api-level.h" 2 3 4
# 220 "/data/data/com.termux/files/usr/bin/../../usr/include/android/api-level.h" 3 4
}
# 338 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/cdefs.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/android/ndk-version.h" 1 3 4
# 340 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/cdefs.h" 2 3 4
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/features.h" 2 3 4
# 458 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__config" 2 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/integral_constant.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/integral_constant.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, _Tp __v>
struct integral_constant {
  static constexpr const _Tp value = __v;
  typedef _Tp value_type;
  typedef integral_constant type;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator value_type() const noexcept { return value; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr value_type operator()() const noexcept { return value; }

};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

template <bool _Val>
using _BoolConstant __attribute__((__nodebug__)) = integral_constant<bool, _Val>;


template <bool __b>
using bool_constant = integral_constant<bool, __b>;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/operation_traits.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/operation_traits.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


struct __equal_tag {};
struct __plus_tag {};
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/operation_traits.h" 3
template <class _CanonicalTag, class _Operation, class... _Args>
struct __desugars_to : false_type {};

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

struct __equal_to {
  template <class _T1, class _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(const _T1& __x, const _T2& __y) const {
    return __x == __y;
  }
};

template <class _Tp, class _Up>
struct __desugars_to<__equal_tag, __equal_to, _Tp, _Up> : true_type {};



template <class _T1 = void, class _T2 = _T1>
struct __less {};

template <>
struct __less<void, void> {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(const _Tp& __lhs, const _Up& __rhs) const {
    return __lhs < __rhs;
  }
};

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_floating_point.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_floating_point.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cv.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cv.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_const.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_const.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_const {
  using type __attribute__((__nodebug__)) = __remove_const(_Tp);
};

template <class _Tp>
using __remove_const_t = __remove_const(_Tp);
# 43 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_const.h" 3
template <class _Tp>
using remove_const_t = __remove_const_t<_Tp>;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cv.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_volatile.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_volatile.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_volatile {
  using type __attribute__((__nodebug__)) = __remove_volatile(_Tp);
};

template <class _Tp>
using __remove_volatile_t = __remove_volatile(_Tp);
# 43 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_volatile.h" 3
template <class _Tp>
using remove_volatile_t = __remove_volatile_t<_Tp>;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cv.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cv.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct remove_cv {
  using type __attribute__((__nodebug__)) = __remove_cv(_Tp);
};





template <class _Tp>
using __remove_cv_t = __remove_cv(_Tp);



template <class _Tp>
using remove_cv_t = __remove_cv_t<_Tp>;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_floating_point.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_floating_point.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};


template <class _Tp>
struct is_floating_point : public __libcpp_is_floating_point<__remove_cv_t<_Tp> > {};


template <class _Tp>
inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_integral.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_integral.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp> struct __libcpp_is_integral { enum { value = 0 }; };
template <> struct __libcpp_is_integral<bool> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<signed char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned char> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<wchar_t> { enum { value = 1 }; };


template <> struct __libcpp_is_integral<char8_t> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<char16_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char32_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long long> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<__int128_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<__uint128_t> { enum { value = 1 }; };





template <class _Tp>
struct is_integral : _BoolConstant<__is_integral(_Tp)> {};


template <class _Tp>
inline constexpr bool is_integral_v = __is_integral(_Tp);
# 72 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_integral.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_arithmetic.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_arithmetic.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value || is_floating_point<_Tp>::value> {};


template <class _Tp>
inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_signed : _BoolConstant<__is_signed(_Tp)> {};


template <class _Tp>
inline constexpr bool is_signed_v = __is_signed(_Tp);
# 57 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed.h" 3
}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed_integer.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_signed_integer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp> struct __libcpp_is_signed_integer : public false_type {};
template <> struct __libcpp_is_signed_integer<signed char> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed short> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed int> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long long> : public true_type {};

template <> struct __libcpp_is_signed_integer<__int128_t> : public true_type {};



}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unsigned_integer.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unsigned_integer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp> struct __libcpp_is_unsigned_integer : public false_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned char> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned short> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned int> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long long> : public true_type {};

template <> struct __libcpp_is_unsigned_integer<__uint128_t> : public true_type {};



}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/arithmetic.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept integral = is_integral_v<_Tp>;

template <class _Tp>
concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;

template <class _Tp>
concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;

template <class _Tp>
concept floating_point = is_floating_point_v<_Tp>;



template <class _Tp>
concept __libcpp_unsigned_integer = __libcpp_is_unsigned_integer<_Tp>::value;

template <class _Tp>
concept __libcpp_signed_integer = __libcpp_is_signed_integer<_Tp>::value;

template <class _Tp>
concept __libcpp_integer = __libcpp_unsigned_integer<_Tp> || __libcpp_signed_integer<_Tp>;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/convertible_to.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/convertible_to.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_convertible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_convertible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _T1, class _T2>
struct is_convertible : public integral_constant<bool, __is_convertible(_T1, _T2)> {};


template <class _From, class _To>
inline constexpr bool is_convertible_v = __is_convertible(_From, _To);


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/convertible_to.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/declval.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/declval.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



#pragma GCC diagnostic push
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/declval.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/declval.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
_Tp&& __declval(int);
template <class _Tp>
_Tp __declval(long);
#pragma GCC diagnostic pop

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) decltype(std::__declval<_Tp>(0)) declval() noexcept {
  static_assert(!__is_same(_Tp, _Tp),
                "std::declval can only be used in an unevaluated context. "
                "It's likely that your current usage is trying to extract a value from the function.");
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/convertible_to.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/convertible_to.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _From, class _To>
concept convertible_to = is_convertible_v<_From, _To> && requires { static_cast<_To>(std::declval<_From>()); };



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/destructible.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/destructible.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_const.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_const.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_const : _BoolConstant<__is_const(_Tp)> {};


template <class _Tp>
inline constexpr bool is_const_v = __is_const(_Tp);
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_const.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_reference.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_reference.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_lvalue_reference : _BoolConstant<__is_lvalue_reference(_Tp)> {};

template <class _Tp>
struct is_rvalue_reference : _BoolConstant<__is_rvalue_reference(_Tp)> {};

template <class _Tp>
struct is_reference : _BoolConstant<__is_reference(_Tp)> {};


template <class _Tp>
inline constexpr bool is_reference_v = __is_reference(_Tp);
template <class _Tp>
inline constexpr bool is_lvalue_reference_v = __is_lvalue_reference(_Tp);
template <class _Tp>
inline constexpr bool is_rvalue_reference_v = __is_rvalue_reference(_Tp);
# 73 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_reference.h" 3
}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_function : integral_constant<bool, __is_function(_Tp)> {};
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_function.h" 3
template <class _Tp>
inline constexpr bool is_function_v = is_function<_Tp>::value;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_all_extents.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_all_extents.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 1 3
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/enable_if.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/enable_if.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <bool, class _Tp = void>
struct enable_if {};
template <class _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <bool _Bp, class _Tp = void>
using __enable_if_t __attribute__((__nodebug__)) = typename enable_if<_Bp, _Tp>::type;


template <bool _Bp, class _Tp = void>
using enable_if_t = typename enable_if<_Bp, _Tp>::type;


}}
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/version" 1 3
# 248 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/version" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__availability" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__availability" 3
# 249 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/version" 2 3
# 253 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/version" 3
# 41 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3
# 43 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 3



# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 1 3
# 84 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 3
# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_header_macro.h" 1 3
# 85 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3



# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 89 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_size_t.h" 1 3
# 18 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 94 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3
# 103 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 3
# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_wchar_t.h" 1 3
# 104 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_null.h" 1 3
# 109 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_nullptr_t.h" 1 3
# 114 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3
# 123 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 3
# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_max_align_t.h" 1 3
# 19 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 124 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_offsetof.h" 1 3
# 129 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3
# 47 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 2 3



typedef decltype(nullptr) nullptr_t;
# 43 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 2 3
# 54 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstddef" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

using ::nullptr_t;
using ::ptrdiff_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));


using ::max_align_t __attribute__((__using_if_exists__));


}}


namespace std
{
enum class byte : unsigned char {};

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte operator|(byte __lhs, byte __rhs) noexcept {
  return static_cast<byte>(
      static_cast<unsigned char>(static_cast<unsigned int>(__lhs) | static_cast<unsigned int>(__rhs)));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte& operator|=(byte& __lhs, byte __rhs) noexcept {
  return __lhs = __lhs | __rhs;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte operator&(byte __lhs, byte __rhs) noexcept {
  return static_cast<byte>(
      static_cast<unsigned char>(static_cast<unsigned int>(__lhs) & static_cast<unsigned int>(__rhs)));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte& operator&=(byte& __lhs, byte __rhs) noexcept {
  return __lhs = __lhs & __rhs;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte operator^(byte __lhs, byte __rhs) noexcept {
  return static_cast<byte>(
      static_cast<unsigned char>(static_cast<unsigned int>(__lhs) ^ static_cast<unsigned int>(__rhs)));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte& operator^=(byte& __lhs, byte __rhs) noexcept {
  return __lhs = __lhs ^ __rhs;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr byte operator~(byte __b) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(~static_cast<unsigned int>(__b)));
}

template <class _Integer, __enable_if_t<is_integral<_Integer>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr byte& operator<<=(byte& __lhs, _Integer __shift) noexcept {
  return __lhs = __lhs << __shift;
}

template <class _Integer, __enable_if_t<is_integral<_Integer>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr byte operator<<(byte __lhs, _Integer __shift) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) << __shift));
}

template <class _Integer, __enable_if_t<is_integral<_Integer>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr byte& operator>>=(byte& __lhs, _Integer __shift) noexcept {
  return __lhs = __lhs >> __shift;
}

template <class _Integer, __enable_if_t<is_integral<_Integer>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr byte operator>>(byte __lhs, _Integer __shift) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) >> __shift));
}

template <class _Integer, __enable_if_t<is_integral<_Integer>::value, int> = 0>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Integer to_integer(byte __b) noexcept {
  return static_cast<_Integer>(__b);
}

}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_all_extents.h" 2 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_all_extents.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_all_extents {
  using type __attribute__((__nodebug__)) = __remove_all_extents(_Tp);
};

template <class _Tp>
using __remove_all_extents_t = __remove_all_extents(_Tp);
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_all_extents.h" 3
template <class _Tp>
using remove_all_extents_t = __remove_all_extents_t<_Tp>;


}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_destructible : _BoolConstant<__is_destructible(_Tp)> {};


template <class _Tp>
inline constexpr bool is_destructible_v = __is_destructible(_Tp);
# 95 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_destructible.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_enum.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_enum.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {};


template <class _Tp>
inline constexpr bool is_enum_v = __is_enum(_Tp);


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_pointer.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_pointer.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_function_pointer.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_function_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __libcpp_is_member_pointer {
  enum { __is_member = false, __is_func = false, __is_obj = false };
};
template <class _Tp, class _Up>
struct __libcpp_is_member_pointer<_Tp _Up::*> {
  enum {
    __is_member = true,
    __is_func = is_function<_Tp>::value,
    __is_obj = !__is_func,
  };
};



template <class _Tp>
struct is_member_function_pointer : _BoolConstant<__is_member_function_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_member_function_pointer_v = __is_member_function_pointer(_Tp);
# 60 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_function_pointer.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_pointer.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_member_pointer : _BoolConstant<__is_member_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_pointer.h" 3
}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_null_pointer.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_null_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __is_nullptr_t_impl : public false_type {};
template <>
struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp>
struct __is_nullptr_t : public __is_nullptr_t_impl<__remove_cv_t<_Tp> > {};


template <class _Tp>
struct is_null_pointer : public __is_nullptr_t_impl<__remove_cv_t<_Tp> > {};


template <class _Tp>
inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;



}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_pointer.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_pointer : _BoolConstant<__is_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_pointer_v = __is_pointer(_Tp);
# 63 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_pointer.h" 3
}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_scalar : _BoolConstant<__is_scalar(_Tp)> {};


template <class _Tp>
inline constexpr bool is_scalar_v = __is_scalar(_Tp);
# 67 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scalar.h" 3
}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 2 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <bool, class _Tp>
struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp> : public false_type {};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::declval<_Tp>().~_Tp()) > {};

template <class _Tp>
struct is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp> {};

template <class _Tp, size_t _Ns>
struct is_nothrow_destructible<_Tp[_Ns]> : public is_nothrow_destructible<_Tp> {};

template <class _Tp>
struct is_nothrow_destructible<_Tp&> : public true_type {};

template <class _Tp>
struct is_nothrow_destructible<_Tp&&> : public true_type {};
# 68 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 3
template <class _Tp>
inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Tp>::value;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/destructible.h" 2 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/destructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept destructible = is_nothrow_destructible_v<_Tp>;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_constructible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class... _Args>
struct is_constructible : public integral_constant<bool, __is_constructible(_Tp, _Args...)> {};


template <class _Tp, class... _Args>
inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class _Tp, class... _Args>
concept constructible_from = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;



template <class _Tp>
concept __default_initializable = requires { ::new _Tp; };

template <class _Tp>
concept default_initializable = constructible_from<_Tp> && requires { _Tp{}; } && __default_initializable<_Tp>;


template <class _Tp>
concept move_constructible = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;



template <class _Tp>
concept copy_constructible =
    move_constructible<_Tp> &&
    constructible_from<_Tp, _Tp&> && convertible_to<_Tp&, _Tp> &&
    constructible_from<_Tp, const _Tp&> && convertible_to<const _Tp&, _Tp> &&
    constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;




}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/copyable.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/copyable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_reference_with.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_reference_with.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/same_as.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/same_as.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_same.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_same.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Up>
struct is_same : _BoolConstant<__is_same(_Tp, _Up)> {};


template <class _Tp, class _Up>
inline constexpr bool is_same_v = __is_same(_Tp, _Up);
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_same.h" 3
template <class _Tp, class _Up>
using _IsSame = _BoolConstant<__is_same(_Tp, _Up)>;

template <class _Tp, class _Up>
using _IsNotSame = _BoolConstant<!__is_same(_Tp, _Up)>;

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/same_as.h" 2 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/same_as.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class _Up>
concept __same_as_impl = _IsSame<_Tp, _Up>::value;

template <class _Tp, class _Up>
concept same_as = __same_as_impl<_Tp, _Up> && __same_as_impl<_Up, _Tp>;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_reference_with.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/conditional.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/conditional.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <bool>
struct _IfImpl;

template <>
struct _IfImpl<true> {
  template <class _IfRes, class _ElseRes>
  using _Select __attribute__((__nodebug__)) = _IfRes;
};

template <>
struct _IfImpl<false> {
  template <class _IfRes, class _ElseRes>
  using _Select __attribute__((__nodebug__)) = _ElseRes;
};

template <bool _Cond, class _IfRes, class _ElseRes>
using _If __attribute__((__nodebug__)) = typename _IfImpl<_Cond>::template _Select<_IfRes, _ElseRes>;

template <bool _Bp, class _If, class _Then>
struct conditional {
  using type __attribute__((__nodebug__)) = _If;
};
template <class _If, class _Then>
struct conditional<false, _If, _Then> {
  using type __attribute__((__nodebug__)) = _Then;
};


template <bool _Bp, class _IfRes, class _ElseRes>
using conditional_t __attribute__((__nodebug__)) = typename conditional<_Bp, _IfRes, _ElseRes>::type;



template <bool _Bp, class _If, class _Then>
using __conditional_t __attribute__((__nodebug__)) = typename conditional<_Bp, _If, _Then>::type;

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_referenceable.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_referenceable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





struct __libcpp_is_referenceable_impl {
  template <class _Tp>
  static _Tp& __test(int);
  template <class _Tp>
  static false_type __test(...);
};

template <class _Tp>
struct __libcpp_is_referenceable
    : integral_constant<bool, _IsNotSame<decltype(__libcpp_is_referenceable_impl::__test<_Tp>(0)), false_type>::value> {
};


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_void.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_void.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_void : _BoolConstant<__is_void(_Tp)> {};


template <class _Tp>
inline constexpr bool is_void_v = __is_void(_Tp);
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_void.h" 3
}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_reference.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_reference.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_reference {
  using type __attribute__((__nodebug__)) = __remove_reference_t(_Tp);
};

template <class _Tp>
using __libcpp_remove_reference_t = __remove_reference_t(_Tp);
# 41 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_reference.h" 3
template <class _Tp>
using remove_reference_t = __libcpp_remove_reference_t<_Tp>;


}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __add_pointer_t = __add_pointer(_Tp);
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_pointer.h" 3
template <class _Tp>
struct add_pointer {
  using type __attribute__((__nodebug__)) = __add_pointer_t<_Tp>;
};


template <class _Tp>
using add_pointer_t = __add_pointer_t<_Tp>;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_array.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_array.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_array.h" 3
template <class _Tp>
struct is_array : public false_type {};
template <class _Tp>
struct is_array<_Tp[]> : public true_type {};
template <class _Tp, size_t _Np>
struct is_array<_Tp[_Np]> : public true_type {};


template <class _Tp>
inline constexpr bool is_array_v = is_array<_Tp>::value;




}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_extent.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_extent.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_extent {
  using type __attribute__((__nodebug__)) = __remove_extent(_Tp);
};

template <class _Tp>
using __remove_extent_t = __remove_extent(_Tp);
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_extent.h" 3
template <class _Tp>
using remove_extent_t = __remove_extent_t<_Tp>;


}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 2 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
using __decay_t __attribute__((__nodebug__)) = __decay(_Tp);

template <class _Tp>
struct decay {
  using type __attribute__((__nodebug__)) = __decay_t<_Tp>;
};
# 67 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/decay.h" 3
template <class _Tp>
using decay_t = __decay_t<_Tp>;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cvref.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cvref.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_cvref.h" 3
template <class _Tp>
using __remove_cvref_t __attribute__((__nodebug__)) = __remove_cvref(_Tp);


template <class _Tp, class _Up>
using __is_same_uncvref = _IsSame<__remove_cvref_t<_Tp>, __remove_cvref_t<_Up> >;


template <class _Tp>
struct remove_cvref {
  using type __attribute__((__nodebug__)) = __remove_cvref(_Tp);
};

template <class _Tp>
using remove_cvref_t = __remove_cvref_t<_Tp>;


}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/void_t.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/void_t.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class...>
using void_t = void;


template <class...>
using __void_t = void;

}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp, class _Up>
using __cond_type = decltype(false ? std::declval<_Tp>() : std::declval<_Up>());

template <class _Tp, class _Up, class = void>
struct __common_type3 {};


template <class _Tp, class _Up>
struct __common_type3<_Tp, _Up, void_t<__cond_type<const _Tp&, const _Up&>>> {
  using type = remove_cvref_t<__cond_type<const _Tp&, const _Up&>>;
};

template <class _Tp, class _Up, class = void>
struct __common_type2_imp : __common_type3<_Tp, _Up> {};






template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up, __void_t<decltype(true ? std::declval<_Tp>() : std::declval<_Up>())> > {
  typedef __attribute__((__nodebug__)) __decay_t<decltype(true ? std::declval<_Tp>() : std::declval<_Up>())> type;
};

template <class, class = void>
struct __common_type_impl {};

template <class... _Tp>
struct __common_types;
template <class... _Tp>
struct common_type;

template <class _Tp, class _Up>
struct __common_type_impl< __common_types<_Tp, _Up>, __void_t<typename common_type<_Tp, _Up>::type> > {
  typedef typename common_type<_Tp, _Up>::type type;
};

template <class _Tp, class _Up, class _Vp, class... _Rest>
struct __common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...>, __void_t<typename common_type<_Tp, _Up>::type> >
    : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type, _Vp, _Rest...> > {};



template <>
struct common_type<> {};



template <class _Tp>
struct common_type<_Tp> : public common_type<_Tp, _Tp> {};




template <class _Tp, class _Up>
struct common_type<_Tp, _Up>
    : conditional<_IsSame<_Tp, __decay_t<_Tp> >::value && _IsSame<_Up, __decay_t<_Up> >::value,
                  __common_type2_imp<_Tp, _Up>,
                  common_type<__decay_t<_Tp>, __decay_t<_Up> > >::type {};



template <class _Tp, class _Up, class _Vp, class... _Rest>
struct common_type<_Tp, _Up, _Vp, _Rest...>
    : __common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...> > {};


template <class... _Tp>
using common_type_t = typename common_type<_Tp...>::type;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_const.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_const.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct add_const {
  typedef __attribute__((__nodebug__)) const _Tp type;
};


template <class _Tp>
using add_const_t = typename add_const<_Tp>::type;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_cv.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_cv.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct add_cv {
  typedef __attribute__((__nodebug__)) const volatile _Tp type;
};


template <class _Tp>
using add_cv_t = typename add_cv<_Tp>::type;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_volatile.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_volatile.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct add_volatile {
  typedef __attribute__((__nodebug__)) volatile _Tp type;
};


template <class _Tp>
using add_volatile_t = typename add_volatile<_Tp>::type;


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cv.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _From, class _To>
struct __copy_cv {
  using type = _To;
};

template <class _From, class _To>
struct __copy_cv<const _From, _To> {
  using type = typename add_const<_To>::type;
};

template <class _From, class _To>
struct __copy_cv<volatile _From, _To> {
  using type = typename add_volatile<_To>::type;
};

template <class _From, class _To>
struct __copy_cv<const volatile _From, _To> {
  using type = typename add_cv<_To>::type;
};

template <class _From, class _To>
using __copy_cv_t = typename __copy_cv<_From, _To>::type;

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cvref.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cvref.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_lvalue_reference.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_lvalue_reference.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __add_lvalue_reference_t = __add_lvalue_reference(_Tp);
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_lvalue_reference.h" 3
template <class _Tp>
struct add_lvalue_reference {
  using type __attribute__((__nodebug__)) = __add_lvalue_reference_t<_Tp>;
};


template <class _Tp>
using add_lvalue_reference_t = __add_lvalue_reference_t<_Tp>;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cvref.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_rvalue_reference.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_rvalue_reference.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __add_rvalue_reference_t = __add_rvalue_reference(_Tp);
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/add_rvalue_reference.h" 3
template <class _Tp>
struct add_rvalue_reference {
  using type = __add_rvalue_reference_t<_Tp>;
};


template <class _Tp>
using add_rvalue_reference_t = __add_rvalue_reference_t<_Tp>;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cvref.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/copy_cvref.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _From, class _To>
struct __copy_cvref {
  using type = __copy_cv_t<_From, _To>;
};

template <class _From, class _To>
struct __copy_cvref<_From&, _To> {
  using type = __add_lvalue_reference_t<__copy_cv_t<_From, _To> >;
};

template <class _From, class _To>
struct __copy_cvref<_From&&, _To> {
  using type = __add_rvalue_reference_t<__copy_cv_t<_From, _To> >;
};

template <class _From, class _To>
using __copy_cvref_t = typename __copy_cvref<_From, _To>::type;

}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 2 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/common_reference.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class _Xp, class _Yp>
using __cond_res = decltype(false ? std::declval<_Xp (&)()>()() : std::declval<_Yp (&)()>()());





template <class _Tp>
struct __xref {
  template <class _Up>
  using __apply = __copy_cvref_t<_Tp, _Up>;
};



template <class _Ap, class _Bp, class _Xp = remove_reference_t<_Ap>, class _Yp = remove_reference_t<_Bp>>
struct __common_ref;

template <class _Xp, class _Yp>
using __common_ref_t = typename __common_ref<_Xp, _Yp>::__type;

template <class _Xp, class _Yp>
using __cv_cond_res = __cond_res<__copy_cv_t<_Xp, _Yp>&, __copy_cv_t<_Yp, _Xp>&>;




template <class _Ap, class _Bp, class _Xp, class _Yp>
  requires
    requires { typename __cv_cond_res<_Xp, _Yp>; } &&
    is_reference_v<__cv_cond_res<_Xp, _Yp>>
struct __common_ref<_Ap&, _Bp&, _Xp, _Yp> {
  using __type = __cv_cond_res<_Xp, _Yp>;
};



template <class _Xp, class _Yp>
using __common_ref_C = remove_reference_t<__common_ref_t<_Xp&, _Yp&>>&&;




template <class _Ap, class _Bp, class _Xp, class _Yp>
  requires
    requires { typename __common_ref_C<_Xp, _Yp>; } &&
    is_convertible_v<_Ap&&, __common_ref_C<_Xp, _Yp>> &&
    is_convertible_v<_Bp&&, __common_ref_C<_Xp, _Yp>>
struct __common_ref<_Ap&&, _Bp&&, _Xp, _Yp> {
  using __type = __common_ref_C<_Xp, _Yp>;
};



template <class _Tp, class _Up>
using __common_ref_D = __common_ref_t<const _Tp&, _Up&>;




template <class _Ap, class _Bp, class _Xp, class _Yp>
  requires
    requires { typename __common_ref_D<_Xp, _Yp>; } &&
    is_convertible_v<_Ap&&, __common_ref_D<_Xp, _Yp>>
struct __common_ref<_Ap&&, _Bp&, _Xp, _Yp> {
  using __type = __common_ref_D<_Xp, _Yp>;
};




template <class _Ap, class _Bp, class _Xp, class _Yp>
struct __common_ref<_Ap&, _Bp&&, _Xp, _Yp> : __common_ref<_Bp&&, _Ap&> {};


template <class _Ap, class _Bp, class _Xp, class _Yp>
struct __common_ref {};



template <class...>
struct common_reference;

template <class... _Types>
using common_reference_t = typename common_reference<_Types...>::type;


template <>
struct common_reference<> {};


template <class _Tp>
struct common_reference<_Tp> {
  using type = _Tp;
};


template <class _Tp, class _Up>
struct __common_reference_sub_bullet3;
template <class _Tp, class _Up>
struct __common_reference_sub_bullet2 : __common_reference_sub_bullet3<_Tp, _Up> {};
template <class _Tp, class _Up>
struct __common_reference_sub_bullet1 : __common_reference_sub_bullet2<_Tp, _Up> {};



template <class _Tp, class _Up>
struct common_reference<_Tp, _Up> : __common_reference_sub_bullet1<_Tp, _Up> {};

template <class _Tp, class _Up>
  requires is_reference_v<_Tp> && is_reference_v<_Up> && requires { typename __common_ref_t<_Tp, _Up>; }
struct __common_reference_sub_bullet1<_Tp, _Up> {
  using type = __common_ref_t<_Tp, _Up>;
};



template <class, class, template <class> class, template <class> class>
struct basic_common_reference {};

template <class _Tp, class _Up>
using __basic_common_reference_t =
    typename basic_common_reference<remove_cvref_t<_Tp>,
                                    remove_cvref_t<_Up>,
                                    __xref<_Tp>::template __apply,
                                    __xref<_Up>::template __apply>::type;

template <class _Tp, class _Up>
  requires requires { typename __basic_common_reference_t<_Tp, _Up>; }
struct __common_reference_sub_bullet2<_Tp, _Up> {
  using type = __basic_common_reference_t<_Tp, _Up>;
};



template <class _Tp, class _Up>
  requires requires { typename __cond_res<_Tp, _Up>; }
struct __common_reference_sub_bullet3<_Tp, _Up> {
  using type = __cond_res<_Tp, _Up>;
};




template <class _Tp, class _Up>
struct __common_reference_sub_bullet3 : common_type<_Tp, _Up> {};



template <class _Tp, class _Up, class _Vp, class... _Rest>
  requires requires { typename common_reference_t<_Tp, _Up>; }
struct common_reference<_Tp, _Up, _Vp, _Rest...> : common_reference<common_reference_t<_Tp, _Up>, _Vp, _Rest...> {};


template <class...>
struct common_reference {};



}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_reference_with.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_reference_with.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class _Up>
concept common_reference_with =
    same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>> &&
    convertible_to<_Tp, common_reference_t<_Tp, _Up>> && convertible_to<_Up, common_reference_t<_Tp, _Up>>;



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_const_lvalue_ref.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_const_lvalue_ref.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
using __make_const_lvalue_ref = const __libcpp_remove_reference_t<_Tp>&;

}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/forward.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/forward.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp&&
forward([[_Clang::__lifetimebound__]] __libcpp_remove_reference_t<_Tp>& __t) noexcept {
  return static_cast<_Tp&&>(__t);
}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp&&
forward([[_Clang::__lifetimebound__]] __libcpp_remove_reference_t<_Tp>&& __t) noexcept {
  static_assert(!is_lvalue_reference<_Tp>::value, "cannot forward an rvalue as an lvalue");
  return static_cast<_Tp&&>(__t);
}

}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Lhs, class _Rhs>
concept assignable_from =
    is_lvalue_reference_v<_Lhs> &&
    common_reference_with<__make_const_lvalue_ref<_Lhs>, __make_const_lvalue_ref<_Rhs>> &&
    requires(_Lhs __lhs, _Rhs&& __rhs) {
      { __lhs = std::forward<_Rhs>(__rhs) } -> same_as<_Lhs>;
    };



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/copyable.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/movable.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/movable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/class_or_enum.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/class_or_enum.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_class.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_class.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_class : public integral_constant<bool, __is_class(_Tp)> {};


template <class _Tp>
inline constexpr bool is_class_v = __is_class(_Tp);


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/class_or_enum.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_union.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_union.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_union : public integral_constant<bool, __is_union(_Tp)> {};


template <class _Tp>
inline constexpr bool is_union_v = __is_union(_Tp);


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/class_or_enum.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/class_or_enum.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept __class_or_enum = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;



template <class _Tp>
concept __workaround_52970 = is_class_v<__remove_cvref_t<_Tp>> || is_union_v<__remove_cvref_t<_Tp>>;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/extent.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/extent.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp, size_t _Dim = 0>
struct extent : integral_constant<size_t, __array_extent(_Tp, _Dim)> {};


template <class _Tp, unsigned _Ip = 0>
inline constexpr size_t extent_v = __array_extent(_Tp, _Ip);
# 52 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/extent.h" 3
}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_assignable.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_nothrow_move_assignable
    : public integral_constant<bool,
                               __is_nothrow_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {
};


template <class _Tp>
inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Tp>::value;


}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_constructible.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template < class _Tp, class... _Args>
struct is_nothrow_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)> {};
# 65 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_constructible.h" 3
template <class _Tp, class... _Args>
inline constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Tp, _Args...>::value;


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class _Tp>
struct is_nothrow_move_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};
# 39 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 3
template <class _Tp>
inline constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Tp>::value;


}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_assignable.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Arg>
struct is_nothrow_assignable : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {
};


template <class _Tp, class _Arg>
inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_Tp, _Arg);


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/move.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/move.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_copy_constructible.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_copy_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_copy_constructible
    : public integral_constant<bool, __is_constructible(_Tp, __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {
};


template <class _Tp>
inline constexpr bool is_copy_constructible_v = is_copy_constructible<_Tp>::value;


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/move.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/move.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/move.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __libcpp_remove_reference_t<_Tp>&&
move([[_Clang::__lifetimebound__]] _Tp&& __t) noexcept {
  typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tp> _Up;
  return static_cast<_Up&&>(__t);
}

template <class _Tp>
using __move_if_noexcept_result_t =
    __conditional_t<!is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value, const _Tp&, _Tp&&>;

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __move_if_noexcept_result_t<_Tp>
move_if_noexcept([[_Clang::__lifetimebound__]] _Tp& __x) noexcept {
  return std::move(__x);
}

}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exchange.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _T1, class _T2 = _T1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 exchange(_T1& __obj, _T2&& __new_value) noexcept(
    is_nothrow_move_constructible<_T1>::value && is_nothrow_assignable<_T1&, _T2>::value) {
  _T1 __old_value = std::move(__obj);
  __obj = std::forward<_T2>(__new_value);
  return __old_value;
}


}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_move_assignable.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_move_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_move_assignable
    : public integral_constant<bool, __is_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {};


template <class _Tp>
inline constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_move_constructible.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_move_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_move_constructible
    : public integral_constant<bool, __is_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};


template <class _Tp>
inline constexpr bool is_move_constructible_v = is_move_constructible<_Tp>::value;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_swappable.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_swappable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/nat.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/nat.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

struct __nat {

  __nat() = delete;
  __nat(const __nat&) = delete;
  __nat& operator=(const __nat&) = delete;
  ~__nat() = delete;

};

}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_swappable.h" 2 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_swappable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __is_swappable;
template <class _Tp>
struct __is_nothrow_swappable;


template <class _Tp>
using __swap_result_t = __enable_if_t<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>;





template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __swap_result_t<_Tp> swap(_Tp& __x, _Tp& __y)
    noexcept(is_nothrow_move_constructible<_Tp>::value&& is_nothrow_move_assignable<_Tp>::value);

template <class _Tp, size_t _Np, __enable_if_t<__is_swappable<_Tp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
    noexcept(__is_nothrow_swappable<_Tp>::value);

namespace __detail {


template <class _Tp, class _Up = _Tp, bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with {
  template <class _LHS, class _RHS>
  static decltype(swap(std::declval<_LHS>(), std::declval<_RHS>())) __test_swap(int);
  template <class, class>
  static __nat __test_swap(long);


  typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
  typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

  static const bool value = _IsNotSame<__swap1, __nat>::value && _IsNotSame<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))&& noexcept(
          swap(std::declval<_Up>(), std::declval<_Tp>()));



};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

}

template <class _Tp>
struct __is_swappable : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value> {};

template <class _Tp>
struct __is_nothrow_swappable : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value> {};



template <class _Tp, class _Up>
struct is_swappable_with
    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value> {};

template <class _Tp>
struct is_swappable
    : public __conditional_t<__libcpp_is_referenceable<_Tp>::value,
                             is_swappable_with<__add_lvalue_reference_t<_Tp>, __add_lvalue_reference_t<_Tp> >,
                             false_type> {};

template <class _Tp, class _Up>
struct is_nothrow_swappable_with
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value> {};

template <class _Tp>
struct is_nothrow_swappable
    : public __conditional_t<__libcpp_is_referenceable<_Tp>::value,
                             is_nothrow_swappable_with<__add_lvalue_reference_t<_Tp>, __add_lvalue_reference_t<_Tp> >,
                             false_type> {};

template <class _Tp, class _Up>
inline constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;

template <class _Tp>
inline constexpr bool is_swappable_v = is_swappable<_Tp>::value;

template <class _Tp, class _Up>
inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;

template <class _Tp>
inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;



}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 2 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/swap.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
using __swap_result_t = __enable_if_t<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>;





template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __swap_result_t<_Tp> constexpr swap(_Tp& __x, _Tp& __y)
    noexcept(is_nothrow_move_constructible<_Tp>::value&& is_nothrow_move_assignable<_Tp>::value) {
  _Tp __t(std::move(__x));
  __x = std::move(__y);
  __y = std::move(__t);
}

template <class _Tp, size_t _Np, __enable_if_t<__is_swappable<_Tp>::value, int> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
    noexcept(__is_nothrow_swappable<_Tp>::value) {
  for (size_t __i = 0; __i != _Np; ++__i) {
    swap(__a[__i], __b[__i]);
  }
}

}}
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/swappable.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





namespace ranges {
namespace __swap {

template <class _Tp>
void swap(_Tp&, _Tp&) = delete;


template <class _Tp, class _Up>
concept __unqualified_swappable_with =
    (__class_or_enum<remove_cvref_t<_Tp>> || __class_or_enum<remove_cvref_t<_Up>>) &&
    requires(_Tp&& __t, _Up&& __u) {
        swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
    };


struct __fn;


template <class _Tp, class _Up, size_t _Size>
concept __swappable_arrays =
    !__unqualified_swappable_with<_Tp (&)[_Size], _Up (&)[_Size]> &&
    extent_v<_Tp> == extent_v<_Up> &&
    requires(_Tp (&__t)[_Size], _Up (&__u)[_Size], const __fn& __swap) {
        __swap(__t[0], __u[0]);
    };


template <class _Tp>
concept __exchangeable =
    !__unqualified_swappable_with<_Tp&, _Tp&> && move_constructible<_Tp> && assignable_from<_Tp&, _Tp>;

struct __fn {


  template <class _Tp, class _Up>
    requires __unqualified_swappable_with<_Tp, _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(swap(std::forward<_Tp>(__t), std::forward<_Up>(__u)))) {
    swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
  }


  template <class _Tp, class _Up, size_t _Size>
    requires __swappable_arrays<_Tp, _Up, _Size>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_Tp (&__t)[_Size], _Up (&__u)[_Size]) const
      noexcept(noexcept((*this)(*__t, *__u))) {

    for (size_t __i = 0; __i < _Size; ++__i) {
      (*this)(__t[__i], __u[__i]);
    }
  }


  template <__exchangeable _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_Tp& __x, _Tp& __y) const
      noexcept(is_nothrow_move_constructible_v<_Tp> && is_nothrow_move_assignable_v<_Tp>) {
    __y = std::exchange(__x, std::move(__y));
  }
};
}

inline namespace __cpo {
inline constexpr auto swap = __swap::__fn{};
}
}

template <class _Tp>
concept swappable = requires(_Tp& __a, _Tp& __b) { ranges::swap(__a, __b); };

template <class _Tp, class _Up>
concept swappable_with = common_reference_with<_Tp, _Up> && requires(_Tp&& __t, _Up&& __u) {
  ranges::swap(std::forward<_Tp>(__t), std::forward<_Tp>(__t));
  ranges::swap(std::forward<_Up>(__u), std::forward<_Up>(__u));
  ranges::swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
  ranges::swap(std::forward<_Up>(__u), std::forward<_Tp>(__t));
};



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/movable.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_object.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_object.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_object : _BoolConstant<__is_object(_Tp)> {};


template <class _Tp>
inline constexpr bool is_object_v = __is_object(_Tp);
# 50 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_object.h" 3
}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/movable.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/movable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept movable = is_object_v<_Tp> && move_constructible<_Tp> && assignable_from<_Tp&, _Tp> && swappable<_Tp>;



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/copyable.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/copyable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {






template <class _Tp>
concept copyable =
    copy_constructible<_Tp> &&
    movable<_Tp> &&
    assignable_from<_Tp&, _Tp&> &&
    assignable_from<_Tp&, const _Tp&> &&
    assignable_from<_Tp&, const _Tp>;




}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/equality_comparable.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/equality_comparable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/boolean_testable.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/boolean_testable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept __boolean_testable_impl = convertible_to<_Tp, bool>;

template <class _Tp>
concept __boolean_testable = __boolean_testable_impl<_Tp> && requires(_Tp&& __t) {
  { !std::forward<_Tp>(__t) } -> __boolean_testable_impl;
};



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/equality_comparable.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/equality_comparable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class _Up>
concept __weakly_equality_comparable_with =
    requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
      { __t == __u } -> __boolean_testable;
      { __t != __u } -> __boolean_testable;
      { __u == __t } -> __boolean_testable;
      { __u != __t } -> __boolean_testable;
    };

template <class _Tp>
concept equality_comparable = __weakly_equality_comparable_with<_Tp, _Tp>;


template <class _Tp, class _Up>
concept equality_comparable_with =
    equality_comparable<_Tp> && equality_comparable<_Up> &&
    common_reference_with<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>> &&
    equality_comparable<
        common_reference_t<
            __make_const_lvalue_ref<_Tp>,
            __make_const_lvalue_ref<_Up>>> &&
    __weakly_equality_comparable_with<_Tp, _Up>;




}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/totally_ordered.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/totally_ordered.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class _Up>
concept __partially_ordered_with = requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
  { __t < __u } -> __boolean_testable;
  { __t > __u } -> __boolean_testable;
  { __t <= __u } -> __boolean_testable;
  { __t >= __u } -> __boolean_testable;
  { __u < __t } -> __boolean_testable;
  { __u > __t } -> __boolean_testable;
  { __u <= __t } -> __boolean_testable;
  { __u >= __t } -> __boolean_testable;
};

template <class _Tp>
concept totally_ordered = equality_comparable<_Tp> && __partially_ordered_with<_Tp, _Tp>;


template <class _Tp, class _Up>
concept totally_ordered_with =
    totally_ordered<_Tp> && totally_ordered<_Up> &&
    equality_comparable_with<_Tp, _Up> &&
    totally_ordered<
        common_reference_t<
            __make_const_lvalue_ref<_Tp>,
            __make_const_lvalue_ref<_Up>>> &&
    __partially_ordered_with<_Tp, _Up>;




}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/pair.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/pair.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/tuple.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/tuple.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <size_t, class>
struct tuple_element;



template <class...>
class tuple;

template <class>
struct tuple_size;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&&) noexcept;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/pair.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/pair.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class, class>
struct pair;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) noexcept;


template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&&) noexcept;


}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/incrementable_traits.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/incrementable_traits.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_primary_template.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_primary_template.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_valid_expansion.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_valid_expansion.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <template <class...> class _Templ, class... _Args, class = _Templ<_Args...> >
true_type __sfinae_test_impl(int);
template <template <class...> class, class...>
false_type __sfinae_test_impl(...);

template <template <class...> class _Templ, class... _Args>
using _IsValidExpansion __attribute__((__nodebug__)) = decltype(std::__sfinae_test_impl<_Templ, _Args...>(0));

}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_primary_template.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_primary_template.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
using __test_for_primary_template = __enable_if_t<_IsSame<_Tp, typename _Tp::__primary_template>::value>;

template <class _Tp>
using __is_primary_template = _IsValidExpansion<__test_for_primary_template, _Tp>;

}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/incrementable_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/apply_cv.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/apply_cv.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_volatile.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_volatile.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_volatile : _BoolConstant<__is_volatile(_Tp)> {};


template <class _Tp>
inline constexpr bool is_volatile_v = __is_volatile(_Tp);
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_volatile.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/apply_cv.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/apply_cv.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp,
          bool = is_const<__libcpp_remove_reference_t<_Tp> >::value,
          bool = is_volatile<__libcpp_remove_reference_t<_Tp> >::value>
struct __apply_cv_impl {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, true, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, false, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = volatile _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, true, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const volatile _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, false, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, true, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, false, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = volatile _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, true, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const volatile _Up&;
};

template <class _Tp, class _Up>
using __apply_cv_t __attribute__((__nodebug__)) = typename __apply_cv_impl<_Tp>::template __apply<_Up>;

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 2 3




# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/type_list.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/type_list.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Hp, class _Tp>
struct __type_list {
  typedef _Hp _Head;
  typedef _Tp _Tail;
};

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)>
struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true> {
  typedef __attribute__((__nodebug__)) _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false> {
  typedef __attribute__((__nodebug__)) typename __find_first<_Tp, _Size>::type type;
};

}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __make_signed_t = __make_signed(_Tp);
# 77 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_signed.h" 3
template <class _Tp>
struct make_signed {
  using type __attribute__((__nodebug__)) = __make_signed_t<_Tp>;
};


template <class _Tp>
using make_signed_t = __make_signed_t<_Tp>;


}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/incrementable_traits.h" 2 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/incrementable_traits.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class>
struct incrementable_traits {};

template <class _Tp>
  requires is_object_v<_Tp>
struct incrementable_traits<_Tp*> {
  using difference_type = ptrdiff_t;
};

template <class _Ip>
struct incrementable_traits<const _Ip> : incrementable_traits<_Ip> {};

template <class _Tp>
concept __has_member_difference_type = requires { typename _Tp::difference_type; };

template <__has_member_difference_type _Tp>
struct incrementable_traits<_Tp> {
  using difference_type = typename _Tp::difference_type;
};

template <class _Tp>
concept __has_integral_minus = requires(const _Tp& __x, const _Tp& __y) {
  { __x - __y } -> integral;
};

template <__has_integral_minus _Tp>
  requires(!__has_member_difference_type<_Tp>)
struct incrementable_traits<_Tp> {
  using difference_type = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
};

template <class>
struct iterator_traits;




template <class _Ip>
using iter_difference_t =
    typename conditional_t<__is_primary_template<iterator_traits<remove_cvref_t<_Ip> > >::value,
                           incrementable_traits<remove_cvref_t<_Ip> >,
                           iterator_traits<remove_cvref_t<_Ip> > >::difference_type;



}}
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/readable_traits.h" 1 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/readable_traits.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class>
struct __cond_value_type {};

template <class _Tp>
  requires is_object_v<_Tp>
struct __cond_value_type<_Tp> {
  using value_type = remove_cv_t<_Tp>;
};

template <class _Tp>
concept __has_member_value_type = requires { typename _Tp::value_type; };

template <class _Tp>
concept __has_member_element_type = requires { typename _Tp::element_type; };

template <class>
struct indirectly_readable_traits {};

template <class _Ip>
  requires is_array_v<_Ip>
struct indirectly_readable_traits<_Ip> {
  using value_type = remove_cv_t<remove_extent_t<_Ip>>;
};

template <class _Ip>
struct indirectly_readable_traits<const _Ip> : indirectly_readable_traits<_Ip> {};

template <class _Tp>
struct indirectly_readable_traits<_Tp*> : __cond_value_type<_Tp> {};

template <__has_member_value_type _Tp>
struct indirectly_readable_traits<_Tp> : __cond_value_type<typename _Tp::value_type> {};

template <__has_member_element_type _Tp>
struct indirectly_readable_traits<_Tp> : __cond_value_type<typename _Tp::element_type> {};

template <__has_member_value_type _Tp>
  requires __has_member_element_type<_Tp>
struct indirectly_readable_traits<_Tp> {};

template <__has_member_value_type _Tp>
  requires __has_member_element_type<_Tp> &&
           same_as<remove_cv_t<typename _Tp::element_type>, remove_cv_t<typename _Tp::value_type>>
struct indirectly_readable_traits<_Tp> : __cond_value_type<typename _Tp::value_type> {};



}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/disjunction.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/disjunction.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <bool>
struct _OrImpl;

template <>
struct _OrImpl<true> {
  template <class _Res, class _First, class... _Rest>
  using _Result __attribute__((__nodebug__)) =
      typename _OrImpl<!bool(_First::value) && sizeof...(_Rest) != 0>::template _Result<_First, _Rest...>;
};

template <>
struct _OrImpl<false> {
  template <class _Res, class...>
  using _Result = _Res;
};







template <class... _Args>
using _Or __attribute__((__nodebug__)) = typename _OrImpl<sizeof...(_Args) != 0>::template _Result<false_type, _Args...>;



template <class... _Args>
struct disjunction : _Or<_Args...> {};

template <class... _Args>
inline constexpr bool disjunction_v = _Or<_Args...>::value;



}}
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __with_reference = _Tp&;

template <class _Tp>
concept __can_reference = requires { typename __with_reference<_Tp>; };

template <class _Tp>
concept __dereferenceable = requires(_Tp& __t) {
  { *__t } -> __can_reference;
};


template <__dereferenceable _Tp>
using iter_reference_t = decltype(*std::declval<_Tp&>());



template <class _Iter>
struct iterator_traits;

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

struct contiguous_iterator_tag : public random_access_iterator_tag {};


template <class _Iter>
struct __iter_traits_cache {
  using type = _If< __is_primary_template<iterator_traits<_Iter> >::value, _Iter, iterator_traits<_Iter> >;
};
template <class _Iter>
using _ITER_TRAITS = typename __iter_traits_cache<_Iter>::type;

struct __iter_concept_concept_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_concept;
};
struct __iter_concept_category_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_category;
};
struct __iter_concept_random_fallback {
  template <class _Iter>
  using _Apply = __enable_if_t< __is_primary_template<iterator_traits<_Iter> >::value, random_access_iterator_tag >;
};

template <class _Iter, class _Tester>
struct __test_iter_concept : _IsValidExpansion<_Tester::template _Apply, _Iter>, _Tester {};

template <class _Iter>
struct __iter_concept_cache {
  using type = _Or< __test_iter_concept<_Iter, __iter_concept_concept_test>,
                    __test_iter_concept<_Iter, __iter_concept_category_test>,
                    __test_iter_concept<_Iter, __iter_concept_random_fallback> >;
};

template <class _Iter>
using _ITER_CONCEPT = typename __iter_concept_cache<_Iter>::type::template _Apply<_Iter>;

template <class _Tp>
struct __has_iterator_typedefs {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type
  __test(__void_t<typename _Up::iterator_category>* = nullptr,
         __void_t<typename _Up::difference_type>* = nullptr,
         __void_t<typename _Up::value_type>* = nullptr,
         __void_t<typename _Up::reference>* = nullptr,
         __void_t<typename _Up::pointer>* = nullptr);

public:
  static const bool value = decltype(__test<_Tp>(nullptr, nullptr, nullptr, nullptr, nullptr))::value;
};

template <class _Tp>
struct __has_iterator_category {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type __test(typename _Up::iterator_category* = nullptr);

public:
  static const bool value = decltype(__test<_Tp>(nullptr))::value;
};

template <class _Tp>
struct __has_iterator_concept {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type __test(typename _Up::iterator_concept* = nullptr);

public:
  static const bool value = decltype(__test<_Tp>(nullptr))::value;
};






namespace __iterator_traits_detail {
template <class _Ip>
concept __cpp17_iterator = requires(_Ip __i) {
  { *__i } -> __can_reference;
  { ++__i } -> same_as<_Ip&>;
  { *__i++ } -> __can_reference;
} && copyable<_Ip>;

template <class _Ip>
concept __cpp17_input_iterator = __cpp17_iterator<_Ip> && equality_comparable<_Ip> && requires(_Ip __i) {
  typename incrementable_traits<_Ip>::difference_type;
  typename indirectly_readable_traits<_Ip>::value_type;
  typename common_reference_t<iter_reference_t<_Ip>&&, typename indirectly_readable_traits<_Ip>::value_type&>;
  typename common_reference_t<decltype(*__i++)&&, typename indirectly_readable_traits<_Ip>::value_type&>;
  requires signed_integral<typename incrementable_traits<_Ip>::difference_type>;
};

template <class _Ip>
concept __cpp17_forward_iterator =
    __cpp17_input_iterator<_Ip> && constructible_from<_Ip> && is_reference_v<iter_reference_t<_Ip>> &&
    same_as<remove_cvref_t<iter_reference_t<_Ip>>, typename indirectly_readable_traits<_Ip>::value_type> &&
    requires(_Ip __i) {
      { __i++ } -> convertible_to<_Ip const&>;
      { *__i++ } -> same_as<iter_reference_t<_Ip>>;
    };

template <class _Ip>
concept __cpp17_bidirectional_iterator = __cpp17_forward_iterator<_Ip> && requires(_Ip __i) {
  { --__i } -> same_as<_Ip&>;
  { __i-- } -> convertible_to<_Ip const&>;
  { *__i-- } -> same_as<iter_reference_t<_Ip>>;
};

template <class _Ip>
concept __cpp17_random_access_iterator =
    __cpp17_bidirectional_iterator<_Ip> && totally_ordered<_Ip> &&
    requires(_Ip __i, typename incrementable_traits<_Ip>::difference_type __n) {
      { __i += __n } -> same_as<_Ip&>;
      { __i -= __n } -> same_as<_Ip&>;
      { __i + __n } -> same_as<_Ip>;
      { __n + __i } -> same_as<_Ip>;
      { __i - __n } -> same_as<_Ip>;
      { __i - __i } -> same_as<decltype(__n)>;
      { __i[__n] } -> convertible_to<iter_reference_t<_Ip>>;
    };
}

template <class _Ip>
concept __has_member_reference = requires { typename _Ip::reference; };

template <class _Ip>
concept __has_member_pointer = requires { typename _Ip::pointer; };

template <class _Ip>
concept __has_member_iterator_category = requires { typename _Ip::iterator_category; };

template <class _Ip>
concept __specifies_members = requires {
  typename _Ip::value_type;
  typename _Ip::difference_type;
  requires __has_member_reference<_Ip>;
  requires __has_member_iterator_category<_Ip>;
};

template <class>
struct __iterator_traits_member_pointer_or_void {
  using type = void;
};

template <__has_member_pointer _Tp>
struct __iterator_traits_member_pointer_or_void<_Tp> {
  using type = typename _Tp::pointer;
};

template <class _Tp>
concept __cpp17_iterator_missing_members = !__specifies_members<_Tp> && __iterator_traits_detail::__cpp17_iterator<_Tp>;

template <class _Tp>
concept __cpp17_input_iterator_missing_members =
    __cpp17_iterator_missing_members<_Tp> && __iterator_traits_detail::__cpp17_input_iterator<_Tp>;


template <class>
struct __iterator_traits_member_pointer_or_arrow_or_void {
  using type = void;
};



template <__has_member_pointer _Ip>
struct __iterator_traits_member_pointer_or_arrow_or_void<_Ip> {
  using type = typename _Ip::pointer;
};



template <class _Ip>
  requires requires(_Ip& __i) { __i.operator->(); } && (!__has_member_pointer<_Ip>)
struct __iterator_traits_member_pointer_or_arrow_or_void<_Ip> {
  using type = decltype(std::declval<_Ip&>().operator->());
};


template <class _Ip>
struct __iterator_traits_member_reference {
  using type = iter_reference_t<_Ip>;
};



template <__has_member_reference _Ip>
struct __iterator_traits_member_reference<_Ip> {
  using type = typename _Ip::reference;
};



template <class _Ip>
struct __deduce_iterator_category {
  using type = input_iterator_tag;
};



template <__iterator_traits_detail::__cpp17_random_access_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = random_access_iterator_tag;
};



template <__iterator_traits_detail::__cpp17_bidirectional_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = bidirectional_iterator_tag;
};



template <__iterator_traits_detail::__cpp17_forward_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = forward_iterator_tag;
};

template <class _Ip>
struct __iterator_traits_iterator_category : __deduce_iterator_category<_Ip> {};




template <__has_member_iterator_category _Ip>
struct __iterator_traits_iterator_category<_Ip> {
  using type = typename _Ip::iterator_category;
};


template <class>
struct __iterator_traits_difference_type {
  using type = void;
};



template <class _Ip>
  requires requires { typename incrementable_traits<_Ip>::difference_type; }
struct __iterator_traits_difference_type<_Ip> {
  using type = typename incrementable_traits<_Ip>::difference_type;
};



template <class>
struct __iterator_traits {};




template <__specifies_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = typename _Ip::iterator_category;
  using value_type = typename _Ip::value_type;
  using difference_type = typename _Ip::difference_type;
  using pointer = typename __iterator_traits_member_pointer_or_void<_Ip>::type;
  using reference = typename _Ip::reference;
};




template <__cpp17_input_iterator_missing_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = typename __iterator_traits_iterator_category<_Ip>::type;
  using value_type = typename indirectly_readable_traits<_Ip>::value_type;
  using difference_type = typename incrementable_traits<_Ip>::difference_type;
  using pointer = typename __iterator_traits_member_pointer_or_arrow_or_void<_Ip>::type;
  using reference = typename __iterator_traits_member_reference<_Ip>::type;
};



template <__cpp17_iterator_missing_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = output_iterator_tag;
  using value_type = void;
  using difference_type = typename __iterator_traits_difference_type<_Ip>::type;
  using pointer = void;
  using reference = void;
};

template <class _Ip>
struct iterator_traits : __iterator_traits<_Ip> {
  using __primary_template = iterator_traits;
};
# 403 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Tp>

  requires is_object_v<_Tp>

struct iterator_traits<_Tp*> {
  typedef ptrdiff_t difference_type;
  typedef __remove_cv_t<_Tp> value_type;
  typedef _Tp* pointer;
  typedef _Tp& reference;
  typedef random_access_iterator_tag iterator_category;

  typedef contiguous_iterator_tag iterator_concept;

};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to : is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up> {
};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up, bool = __has_iterator_concept<_Tp>::value>
struct __has_iterator_concept_convertible_to : is_convertible<typename _Tp::iterator_concept, _Up> {};

template <class _Tp, class _Up>
struct __has_iterator_concept_convertible_to<_Tp, _Up, false> : false_type {};

template <class _Tp>
using __has_input_iterator_category = __has_iterator_category_convertible_to<_Tp, input_iterator_tag>;

template <class _Tp>
using __has_forward_iterator_category = __has_iterator_category_convertible_to<_Tp, forward_iterator_tag>;

template <class _Tp>
using __has_bidirectional_iterator_category = __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>;

template <class _Tp>
using __has_random_access_iterator_category = __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag>;
# 451 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Tp>
struct __libcpp_is_contiguous_iterator
    : _Or< __has_iterator_category_convertible_to<_Tp, contiguous_iterator_tag>,
           __has_iterator_concept_convertible_to<_Tp, contiguous_iterator_tag> > {};






template <class _Up>
struct __libcpp_is_contiguous_iterator<_Up*> : true_type {};

template <class _Iter>
class __wrap_iter;

template <class _Tp>
using __has_exactly_input_iterator_category =
    integral_constant<bool,
                      __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
                          !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value>;

template <class _Tp>
using __has_exactly_forward_iterator_category =
    integral_constant<bool,
                      __has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value &&
                          !__has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value>;

template <class _Tp>
using __has_exactly_bidirectional_iterator_category =
    integral_constant<bool,
                      __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value &&
                          !__has_iterator_category_convertible_to<_Tp, random_access_iterator_tag>::value>;

template <class _InputIterator>
using __iter_value_type = typename iterator_traits<_InputIterator>::value_type;

template <class _InputIterator>
using __iter_key_type = __remove_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>;

template <class _InputIterator>
using __iter_mapped_type = typename iterator_traits<_InputIterator>::value_type::second_type;

template <class _InputIterator>
using __iter_to_alloc_type =
    pair< typename add_const<typename iterator_traits<_InputIterator>::value_type::first_type>::type,
          typename iterator_traits<_InputIterator>::value_type::second_type>;

template <class _Iter>
using __iterator_category_type = typename iterator_traits<_Iter>::iterator_category;

template <class _Iter>
using __iterator_pointer_type = typename iterator_traits<_Iter>::pointer;

template <class _Iter>
using __iter_diff_t = typename iterator_traits<_Iter>::difference_type;

template <class _Iter>
using __iter_reference = typename iterator_traits<_Iter>::reference;
# 519 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Ip>
using iter_value_t =
    typename conditional_t<__is_primary_template<iterator_traits<remove_cvref_t<_Ip> > >::value,
                           indirectly_readable_traits<remove_cvref_t<_Ip> >,
                           iterator_traits<remove_cvref_t<_Ip> > >::value_type;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/addressof.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/addressof.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
inline constexpr __attribute__((__no_sanitize__("cfi"))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp* addressof(_Tp& __x) noexcept {
  return __builtin_addressof(__x);
}
# 55 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/addressof.h" 3
template <class _Tp>
_Tp* addressof(const _Tp&&) noexcept = delete;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/conjunction.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/conjunction.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class...>
using __expand_to_true = true_type;

template <class... _Pred>
__expand_to_true<__enable_if_t<_Pred::value>...> __and_helper(int);

template <class...>
false_type __and_helper(...);






template <class... _Pred>
using _And __attribute__((__nodebug__)) = decltype(std::__and_helper<_Pred...>(0));



template <class...>
struct conjunction : true_type {};

template <class _Arg>
struct conjunction<_Arg> : _Arg {};

template <class _Arg, class... _Args>
struct conjunction<_Arg, _Args...> : conditional_t<!bool(_Arg::value), _Arg, conjunction<_Args...>> {};

template <class... _Args>
inline constexpr bool conjunction_v = conjunction<_Args...>::value;



}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 2 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class = void>
struct __has_element_type : false_type {};

template <class _Tp>
struct __has_element_type<_Tp, __void_t<typename _Tp::element_type> > : true_type {};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type {};

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true> {
  typedef __attribute__((__nodebug__)) typename _Ptr::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true> {
  typedef __attribute__((__nodebug__)) typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false> {
  typedef __attribute__((__nodebug__)) _Tp type;
};

template <class _Tp, class = void>
struct __has_difference_type : false_type {};

template <class _Tp>
struct __has_difference_type<_Tp, __void_t<typename _Tp::difference_type> > : true_type {};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type {
  typedef __attribute__((__nodebug__)) ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true> {
  typedef __attribute__((__nodebug__)) typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind {
private:
  template <class _Xp>
  static false_type __test(...);
#pragma GCC diagnostic push
# 76 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 76 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template <class _Xp>
  static true_type __test(typename _Xp::template rebind<_Up>* = 0);
#pragma GCC diagnostic pop

public:
  static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind {

  typedef __attribute__((__nodebug__)) typename _Tp::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class... _Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true> {

  typedef __attribute__((__nodebug__)) typename _Sp<_Tp, _Args...>::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class... _Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false> {
  typedef _Sp<_Up, _Args...> type;
};

template <class _Ptr, class = void>
struct __pointer_traits_impl {};

template <class _Ptr>
struct __pointer_traits_impl<_Ptr, __void_t<typename __pointer_traits_element_type<_Ptr>::type> > {
  typedef _Ptr pointer;
  typedef typename __pointer_traits_element_type<pointer>::type element_type;
  typedef typename __pointer_traits_difference_type<pointer>::type difference_type;


  template <class _Up>
  using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;







private:
  struct __nat {};

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static pointer
  pointer_to(__conditional_t<is_void<element_type>::value, __nat, element_type>& __r) {
    return pointer::pointer_to(__r);
  }
};

template <class _Ptr>
struct pointer_traits : __pointer_traits_impl<_Ptr> {};

template <class _Tp>
struct pointer_traits<_Tp*> {
  typedef _Tp* pointer;
  typedef _Tp element_type;
  typedef ptrdiff_t difference_type;


  template <class _Up>
  using rebind = _Up*;







private:
  struct __nat {};

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static pointer
  pointer_to(__conditional_t<is_void<element_type>::value, __nat, element_type>& __r) noexcept {
    return std::addressof(__r);
  }
};


template <class _From, class _To>
using __rebind_pointer_t = typename pointer_traits<_From>::template rebind<_To>;







template <class _Pointer, class = void>
struct __to_address_helper;

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* __to_address(_Tp* __p) noexcept {
  static_assert(!is_function<_Tp>::value, "_Tp is a function type");
  return __p;
}

template <class _Pointer, class = void>
struct _HasToAddress : false_type {};

template <class _Pointer>
struct _HasToAddress<_Pointer, decltype((void)pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>())) >
    : true_type {};

template <class _Pointer, class = void>
struct _HasArrow : false_type {};

template <class _Pointer>
struct _HasArrow<_Pointer, decltype((void)std::declval<const _Pointer&>().operator->()) > : true_type {};

template <class _Pointer>
struct _IsFancyPointer {
  static const bool value = _HasArrow<_Pointer>::value || _HasToAddress<_Pointer>::value;
};


template <class _Pointer, __enable_if_t< _And<is_class<_Pointer>, _IsFancyPointer<_Pointer> >::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
    __decay_t<decltype(__to_address_helper<_Pointer>::__call(std::declval<const _Pointer&>()))>
    __to_address(const _Pointer& __p) noexcept {
  return __to_address_helper<_Pointer>::__call(__p);
}

template <class _Pointer, class>
struct __to_address_helper {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static decltype(std::__to_address(
      std::declval<const _Pointer&>().operator->()))
  __call(const _Pointer& __p) noexcept {
    return std::__to_address(__p.operator->());
  }
};

template <class _Pointer>
struct __to_address_helper<_Pointer,
                           decltype((void)pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>()))> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static decltype(pointer_traits<_Pointer>::to_address(
      std::declval<const _Pointer&>()))
  __call(const _Pointer& __p) noexcept {
    return pointer_traits<_Pointer>::to_address(__p);
  }
};


template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto to_address(_Tp* __p) noexcept {
  return std::__to_address(__p);
}

template <class _Pointer>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto to_address(const _Pointer& __p) noexcept
    -> decltype(std::__to_address(__p)) {
  return std::__to_address(__p);
}


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_iter.h" 3
template <class _Iter, bool = __libcpp_is_contiguous_iterator<_Iter>::value>
struct __unwrap_iter_impl {
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter __rewrap(_Iter, _Iter __iter) { return __iter; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter __unwrap(_Iter __i) noexcept { return __i; }
};





template <class _Iter>
struct __unwrap_iter_impl<_Iter, true> {
  using _ToAddressT = decltype(std::__to_address(std::declval<_Iter>()));

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter __rewrap(_Iter __orig_iter, _ToAddressT __unwrapped_iter) {
    return __orig_iter + (__unwrapped_iter - std::__to_address(__orig_iter));
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ToAddressT __unwrap(_Iter __i) noexcept {
    return std::__to_address(__i);
  }
};

template <class _Iter,
          class _Impl = __unwrap_iter_impl<_Iter>,
          __enable_if_t<is_copy_constructible<_Iter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(_Impl::__unwrap(std::declval<_Iter>()))
__unwrap_iter(_Iter __i) noexcept {
  return _Impl::__unwrap(__i);
}



template <class _Iter, __enable_if_t<!is_copy_constructible<_Iter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter __unwrap_iter(_Iter __i) noexcept {
  return __i;
}


template <class _OrigIter, class _Iter, class _Impl = __unwrap_iter_impl<_OrigIter> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _OrigIter __rewrap_iter(_OrigIter __orig_iter, _Iter __iter) noexcept {
  return _Impl::__rewrap(std::move(__orig_iter), std::move(__iter));
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/identity.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/identity.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/functional.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/functional.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class>
struct hash;

template <class>
class reference_wrapper;

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/identity.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/identity.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __is_identity : false_type {};

struct __identity {
  template <class _Tp>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp&& operator()(_Tp&& __t) const noexcept {
    return std::forward<_Tp>(__t);
  }

  using is_transparent = void;
};

template <>
struct __is_identity<__identity> : true_type {};
template <>
struct __is_identity<reference_wrapper<__identity> > : true_type {};
template <>
struct __is_identity<reference_wrapper<const __identity> > : true_type {};



struct identity {
  template <class _Tp>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp&& operator()(_Tp&& __t) const noexcept {
    return std::forward<_Tp>(__t);
  }

  using is_transparent = void;
};

template <>
struct __is_identity<identity> : true_type {};
template <>
struct __is_identity<reference_wrapper<identity> > : true_type {};
template <>
struct __is_identity<reference_wrapper<const identity> > : true_type {};



}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/invoke.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/invoke.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_base_of.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_base_of.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Bp, class _Dp>
struct is_base_of : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};


template <class _Bp, class _Dp>
inline constexpr bool is_base_of_v = __is_base_of(_Bp, _Dp);


}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_core_convertible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_core_convertible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {






template <class _Tp, class _Up, class = void>
struct __is_core_convertible : public false_type {};

template <class _Tp, class _Up>
struct __is_core_convertible<_Tp, _Up, decltype(static_cast<void (*)(_Up)>(0)(static_cast<_Tp (*)()>(0)()))>
    : public true_type {};

}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_object_pointer.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_object_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_member_object_pointer : _BoolConstant<__is_member_object_pointer(_Tp)> {};


template <class _Tp>
inline constexpr bool is_member_object_pointer_v = __is_member_object_pointer(_Tp);
# 44 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_member_object_pointer.h" 3
}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_reference_wrapper.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_reference_wrapper.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp>
struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp>
struct __is_reference_wrapper : public __is_reference_wrapper_impl<__remove_cv_t<_Tp> > {};

}}
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 2 3
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/invoke.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _DecayedFp>
struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value &&
                  (is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value)>;

template <class _Fp, class _A0, class _DecayFp = __decay_t<_Fp>, class _DecayA0 = __decay_t<_A0> >
using __enable_if_bullet2 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value &&
                  !(is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value) &&
                  !__is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value &&
                  (is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value)>;

template <class _Fp, class _A0, class _DecayFp = __decay_t<_Fp>, class _DecayA0 = __decay_t<_A0> >
using __enable_if_bullet5 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value &&
                  !(is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value) &&
                  !__is_reference_wrapper<_DecayA0>::value>;





template <class... _Args>
__nat __invoke(_Args&&... __args);




template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet1<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype((std::declval<_A0>().*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
    noexcept(noexcept((static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...)))
               { return (static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet2<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype((std::declval<_A0>().get().*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
    noexcept(noexcept((__a0.get().*__f)(static_cast<_Args&&>(__args)...)))
               { return (__a0.get().*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet3<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype(((*std::declval<_A0>()).*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)
    noexcept(noexcept(((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...)))
               { return ((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...); }



template <class _Fp, class _A0, class = __enable_if_bullet4<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype(std::declval<_A0>().*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept(static_cast<_A0&&>(__a0).*__f))
               { return static_cast<_A0&&>(__a0).*__f; }

template <class _Fp, class _A0, class = __enable_if_bullet5<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype(std::declval<_A0>().get().*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept(__a0.get().*__f))
               { return __a0.get().*__f; }

template <class _Fp, class _A0, class = __enable_if_bullet6<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype((*std::declval<_A0>()).*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept((*static_cast<_A0&&>(__a0)).*__f))
               { return (*static_cast<_A0&&>(__a0)).*__f; }



template <class _Fp, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
decltype(std::declval<_Fp>()(std::declval<_Args>()...))
__invoke(_Fp&& __f, _Args&&... __args)
    noexcept(noexcept(static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...)))
               { return static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...); }



template <class _Ret, class _Fp, class... _Args>
struct __invokable_r {
  template <class _XFp, class... _XArgs>
  static decltype(std::__invoke(std::declval<_XFp>(), std::declval<_XArgs>()...)) __try_call(int);
  template <class _XFp, class... _XArgs>
  static __nat __try_call(...);



  using _Result = decltype(__try_call<_Fp, _Args...>(0));

  using type = __conditional_t<_IsNotSame<_Result, __nat>::value,
                               __conditional_t<is_void<_Ret>::value, true_type, __is_core_convertible<_Result, _Ret> >,
                               false_type>;
  static const bool value = type::value;
};
template <class _Fp, class... _Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...> {
  typedef __nothrow_invokable_r_imp _ThisT;

  template <class _Tp>
  static void __test_noexcept(_Tp) noexcept;




  static const bool value =
      noexcept(_ThisT::__test_noexcept<_Ret>(std::__invoke(std::declval<_Fp>(), std::declval<_Args>()...)));

};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...> {



  static const bool value = noexcept(std::__invoke(std::declval<_Fp>(), std::declval<_Args>()...));

};

template <class _Ret, class _Fp, class... _Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<__invokable_r<_Ret, _Fp, _Args...>::value, is_void<_Ret>::value, _Ret, _Fp, _Args...>;

template <class _Fp, class... _Args>
using __nothrow_invokable = __nothrow_invokable_r_imp<__invokable<_Fp, _Args...>::value, true, void, _Fp, _Args...>;

template <class _Fp, class... _Args>
struct __invoke_of
    : public enable_if<__invokable<_Fp, _Args...>::value, typename __invokable_r<void, _Fp, _Args...>::_Result> {};

template <class _Ret, bool = is_void<_Ret>::value>
struct __invoke_void_return_wrapper {
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static _Ret __call(_Args&&... __args) {
    return std::__invoke(std::forward<_Args>(__args)...);
  }
};

template <class _Ret>
struct __invoke_void_return_wrapper<_Ret, true> {
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void __call(_Args&&... __args) {
    std::__invoke(std::forward<_Args>(__args)...);
  }
};





template <class _Fn, class... _Args>
struct is_invocable : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};

template <class _Ret, class _Fn, class... _Args>
struct is_invocable_r : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};

template <class _Fn, class... _Args>
inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;

template <class _Ret, class _Fn, class... _Args>
inline constexpr bool is_invocable_r_v = is_invocable_r<_Ret, _Fn, _Args...>::value;



template <class _Fn, class... _Args>
struct is_nothrow_invocable : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {
};

template <class _Ret, class _Fn, class... _Args>
struct is_nothrow_invocable_r
    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};

template <class _Fn, class... _Args>
inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _Args...>::value;

template <class _Ret, class _Fn, class... _Args>
inline constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;

template <class _Fn, class... _Args>
struct invoke_result : __invoke_of<_Fn, _Args...> {};

template <class _Fn, class... _Args>
using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/invoke.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/invoke.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Fn, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr invoke_result_t<_Fn, _Args...>
invoke(_Fn&& __f, _Args&&... __args) noexcept(is_nothrow_invocable_v<_Fn, _Args...>) {
  return std::__invoke(std::forward<_Fn>(__f), std::forward<_Args>(__args)...);
}




template <class _Result, class _Fn, class... _Args>
  requires is_invocable_r_v<_Result, _Fn, _Args...>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Result
invoke_r(_Fn&& __f, _Args&&... __args) noexcept(is_nothrow_invocable_r_v<_Result, _Fn, _Args...>) {
  if constexpr (is_void_v<_Result>) {
    static_cast<void>(std::invoke(std::forward<_Fn>(__f), std::forward<_Args>(__args)...));
  } else {



    static_assert(true,
                  "Returning from invoke_r would bind a temporary object to the reference return type, "
                  "which would result in a dangling reference.");
    return std::invoke(std::forward<_Fn>(__f), std::forward<_Args>(__args)...);
  }
}


}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/derived_from.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/derived_from.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Dp, class _Bp>
concept derived_from = is_base_of_v<_Bp, _Dp> && is_convertible_v<const volatile _Dp*, const volatile _Bp*>;



}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/invocable.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/invocable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Fn, class... _Args>
concept invocable = requires(_Fn&& __fn, _Args&&... __args) {
  std::invoke(std::forward<_Fn>(__fn), std::forward<_Args>(__args)...);
};



template <class _Fn, class... _Args>
concept regular_invocable = invocable<_Fn, _Args...>;



}}
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/predicate.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/predicate.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Fn, class... _Args>
concept predicate = regular_invocable<_Fn, _Args...> && __boolean_testable<invoke_result_t<_Fn, _Args...>>;



}}
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/regular.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/regular.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/semiregular.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/semiregular.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept semiregular = copyable<_Tp> && default_initializable<_Tp>;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/regular.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/regular.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp>
concept regular = semiregular<_Tp> && equality_comparable<_Tp>;



}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/relation.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/relation.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Rp, class _Tp, class _Up>
concept relation =
    predicate<_Rp, _Tp, _Tp> && predicate<_Rp, _Up, _Up> && predicate<_Rp, _Tp, _Up> && predicate<_Rp, _Up, _Tp>;



template <class _Rp, class _Tp, class _Up>
concept equivalence_relation = relation<_Rp, _Tp, _Up>;



template <class _Rp, class _Tp, class _Up>
concept strict_weak_order = relation<_Rp, _Tp, _Up>;



}}
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3






# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_move.h" 1 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_move.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_move.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





namespace ranges {
namespace __iter_move {

void iter_move();

template <class _Tp>
concept __unqualified_iter_move = __class_or_enum<remove_cvref_t<_Tp>> && requires(_Tp&& __t) {

  iter_move(std::forward<_Tp>(__t));
};

template <class _Tp>
concept __move_deref = !__unqualified_iter_move<_Tp> && requires(_Tp&& __t) {
  *__t;
  requires is_lvalue_reference_v<decltype(*__t)>;
};

template <class _Tp>
concept __just_deref = !__unqualified_iter_move<_Tp> && !__move_deref<_Tp> && requires(_Tp&& __t) {
  *__t;
  requires(!is_lvalue_reference_v<decltype(*__t)>);
};



struct __fn {

  template <class _Ip>
    requires __unqualified_iter_move<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) operator()(_Ip&& __i) const
      noexcept(noexcept(iter_move(std::forward<_Ip>(__i)))) {
    return iter_move(std::forward<_Ip>(__i));
  }


  template <class _Ip>
    requires __move_deref<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Ip&& __i) const
      noexcept(noexcept(std::move(*std::forward<_Ip>(__i)))) -> decltype(std::move(*std::forward<_Ip>(__i))) {
    return std::move(*std::forward<_Ip>(__i));
  }

  template <class _Ip>
    requires __just_deref<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Ip&& __i) const
      noexcept(noexcept(*std::forward<_Ip>(__i))) -> decltype(*std::forward<_Ip>(__i)) {
    return *std::forward<_Ip>(__i);
  }
};
}

inline namespace __cpo {
inline constexpr auto iter_move = __iter_move::__fn{};
}
}

template <__dereferenceable _Tp>
  requires requires(_Tp& __t) {
    { ranges::iter_move(__t) } -> __can_reference;
  }
using iter_rvalue_reference_t = decltype(ranges::iter_move(std::declval<_Tp&>()));



}}
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 2 3
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/concepts.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class _In>
concept __indirectly_readable_impl =
    requires(const _In __i) {
      typename iter_value_t<_In>;
      typename iter_reference_t<_In>;
      typename iter_rvalue_reference_t<_In>;
      { *__i } -> same_as<iter_reference_t<_In>>;
      { ranges::iter_move(__i) } -> same_as<iter_rvalue_reference_t<_In>>;
    } && common_reference_with<iter_reference_t<_In>&&, iter_value_t<_In>&> &&
    common_reference_with<iter_reference_t<_In>&&, iter_rvalue_reference_t<_In>&&> &&
    common_reference_with<iter_rvalue_reference_t<_In>&&, const iter_value_t<_In>&>;

template <class _In>
concept indirectly_readable = __indirectly_readable_impl<remove_cvref_t<_In>>;

template <indirectly_readable _Tp>
using iter_common_reference_t = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp>&>;


template <class _Out, class _Tp>
concept indirectly_writable = requires(_Out&& __o, _Tp&& __t) {
  *__o = std::forward<_Tp>(__t);
  *std::forward<_Out>(__o) = std::forward<_Tp>(__t);
  const_cast<const iter_reference_t<_Out>&&>(*__o) = std::forward<_Tp>(__t);
  const_cast<const iter_reference_t<_Out>&&>(*std::forward<_Out>(__o)) =
      std::forward<_Tp>(__t);
};


template <class _Tp>
concept __integer_like = integral<_Tp> && !same_as<_Tp, bool>;

template <class _Tp>
concept __signed_integer_like = signed_integral<_Tp>;

template <class _Ip>
concept weakly_incrementable =

    !same_as<_Ip, bool> &&
    movable<_Ip> && requires(_Ip __i) {
      typename iter_difference_t<_Ip>;
      requires __signed_integer_like<iter_difference_t<_Ip>>;
      { ++__i } -> same_as<_Ip&>;
      __i++;
    };


template <class _Ip>
concept incrementable = regular<_Ip> && weakly_incrementable<_Ip> && requires(_Ip __i) {
  { __i++ } -> same_as<_Ip>;
};


template <class _Ip>
concept input_or_output_iterator = requires(_Ip __i) {
  { *__i } -> __can_reference;
} && weakly_incrementable<_Ip>;


template <class _Sp, class _Ip>
concept sentinel_for = semiregular<_Sp> && input_or_output_iterator<_Ip> && __weakly_equality_comparable_with<_Sp, _Ip>;

template <class, class>
inline constexpr bool disable_sized_sentinel_for = false;

template <class _Sp, class _Ip>
concept sized_sentinel_for =
    sentinel_for<_Sp, _Ip> && !disable_sized_sentinel_for<remove_cv_t<_Sp>, remove_cv_t<_Ip>> &&
    requires(const _Ip& __i, const _Sp& __s) {
      { __s - __i } -> same_as<iter_difference_t<_Ip>>;
      { __i - __s } -> same_as<iter_difference_t<_Ip>>;
    };


template <class _Ip>
concept input_iterator = input_or_output_iterator<_Ip> && indirectly_readable<_Ip> && requires {
  typename _ITER_CONCEPT<_Ip>;
} && derived_from<_ITER_CONCEPT<_Ip>, input_iterator_tag>;


template <class _Ip, class _Tp>
concept output_iterator =
    input_or_output_iterator<_Ip> && indirectly_writable<_Ip, _Tp> && requires(_Ip __it, _Tp&& __t) {
      *__it++ = std::forward<_Tp>(__t);
    };


template <class _Ip>
concept forward_iterator =
    input_iterator<_Ip> && derived_from<_ITER_CONCEPT<_Ip>, forward_iterator_tag> && incrementable<_Ip> &&
    sentinel_for<_Ip, _Ip>;


template <class _Ip>
concept bidirectional_iterator =
    forward_iterator<_Ip> && derived_from<_ITER_CONCEPT<_Ip>, bidirectional_iterator_tag> && requires(_Ip __i) {
      { --__i } -> same_as<_Ip&>;
      { __i-- } -> same_as<_Ip>;
    };

template <class _Ip>
concept random_access_iterator =
    bidirectional_iterator<_Ip> && derived_from<_ITER_CONCEPT<_Ip>, random_access_iterator_tag> &&
    totally_ordered<_Ip> && sized_sentinel_for<_Ip, _Ip> &&
    requires(_Ip __i, const _Ip __j, const iter_difference_t<_Ip> __n) {
      { __i += __n } -> same_as<_Ip&>;
      { __j + __n } -> same_as<_Ip>;
      { __n + __j } -> same_as<_Ip>;
      { __i -= __n } -> same_as<_Ip&>;
      { __j - __n } -> same_as<_Ip>;
      { __j[__n] } -> same_as<iter_reference_t<_Ip>>;
    };

template <class _Ip>
concept contiguous_iterator =
    random_access_iterator<_Ip> && derived_from<_ITER_CONCEPT<_Ip>, contiguous_iterator_tag> &&
    is_lvalue_reference_v<iter_reference_t<_Ip>> && same_as<iter_value_t<_Ip>, remove_cvref_t<iter_reference_t<_Ip>>> &&
    requires(const _Ip& __i) {
      { std::to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_Ip>>>;
    };

template <class _Ip>
concept __has_arrow = input_iterator<_Ip> && (is_pointer_v<_Ip> || requires(_Ip __i) { __i.operator->(); });


template <class _Fp, class _It>
concept indirectly_unary_invocable =
    indirectly_readable<_It> && copy_constructible<_Fp> && invocable<_Fp&, iter_value_t<_It>&> &&
    invocable<_Fp&, iter_reference_t<_It>> && invocable<_Fp&, iter_common_reference_t<_It>> &&
    common_reference_with< invoke_result_t<_Fp&, iter_value_t<_It>&>, invoke_result_t<_Fp&, iter_reference_t<_It>>>;

template <class _Fp, class _It>
concept indirectly_regular_unary_invocable =
    indirectly_readable<_It> && copy_constructible<_Fp> && regular_invocable<_Fp&, iter_value_t<_It>&> &&
    regular_invocable<_Fp&, iter_reference_t<_It>> && regular_invocable<_Fp&, iter_common_reference_t<_It>> &&
    common_reference_with< invoke_result_t<_Fp&, iter_value_t<_It>&>, invoke_result_t<_Fp&, iter_reference_t<_It>>>;

template <class _Fp, class _It>
concept indirect_unary_predicate =
    indirectly_readable<_It> && copy_constructible<_Fp> && predicate<_Fp&, iter_value_t<_It>&> &&
    predicate<_Fp&, iter_reference_t<_It>> && predicate<_Fp&, iter_common_reference_t<_It>>;

template <class _Fp, class _It1, class _It2>
concept indirect_binary_predicate =
    indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fp> &&
    predicate<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
    predicate<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
    predicate<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
    predicate<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
    predicate<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

template <class _Fp, class _It1, class _It2 = _It1>
concept indirect_equivalence_relation =
    indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fp> &&
    equivalence_relation<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
    equivalence_relation<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
    equivalence_relation<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
    equivalence_relation<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
    equivalence_relation<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

template <class _Fp, class _It1, class _It2 = _It1>
concept indirect_strict_weak_order =
    indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fp> &&
    strict_weak_order<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
    strict_weak_order<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
    strict_weak_order<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
    strict_weak_order<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
    strict_weak_order<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

template <class _Fp, class... _Its>
  requires(indirectly_readable<_Its> && ...) && invocable<_Fp, iter_reference_t<_Its>...>
using indirect_result_t = invoke_result_t<_Fp, iter_reference_t<_Its>...>;

template <class _In, class _Out>
concept indirectly_movable = indirectly_readable<_In> && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;

template <class _In, class _Out>
concept indirectly_movable_storable =
    indirectly_movable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In>> && movable<iter_value_t<_In>> &&
    constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>> &&
    assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;

template <class _In, class _Out>
concept indirectly_copyable = indirectly_readable<_In> && indirectly_writable<_Out, iter_reference_t<_In>>;

template <class _In, class _Out>
concept indirectly_copyable_storable =
    indirectly_copyable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In>&> &&
    indirectly_writable<_Out, const iter_value_t<_In>&> && indirectly_writable<_Out, iter_value_t<_In>&&> &&
    indirectly_writable<_Out, const iter_value_t<_In>&&> && copyable<iter_value_t<_In>> &&
    constructible_from<iter_value_t<_In>, iter_reference_t<_In>> &&
    assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;






template <class _Tp>
using __has_random_access_iterator_category_or_concept

    = integral_constant<bool, random_access_iterator<_Tp>>;




}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/access.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/access.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/enable_borrowed_range.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/enable_borrowed_range.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {



template <class>
inline constexpr bool enable_borrowed_range = false;

}



}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/access.h" 2 3




# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/auto_cast.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/auto_cast.h" 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/access.h" 2 3
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/access.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {
template <class _Tp>
concept __can_borrow = is_lvalue_reference_v<_Tp> || enable_borrowed_range<remove_cvref_t<_Tp>>;
}



namespace ranges {
namespace __begin {
template <class _Tp>
concept __member_begin = __can_borrow<_Tp> && __workaround_52970<_Tp> && requires(_Tp&& __t) {
  { static_cast<::std::__decay_t<decltype((__t.begin()))> >(__t.begin()) } -> input_or_output_iterator;
};

void begin(auto&) = delete;
void begin(const auto&) = delete;

template <class _Tp>
concept __unqualified_begin =
    !__member_begin<_Tp> && __can_borrow<_Tp> && __class_or_enum<remove_cvref_t<_Tp>> && requires(_Tp&& __t) {
      { static_cast<::std::__decay_t<decltype((begin(__t)))> >(begin(__t)) } -> input_or_output_iterator;
    };

struct __fn {
  template <class _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp (&__t)[]) const noexcept
    requires(sizeof(_Tp) >= 0)
  {
    return __t + 0;
  }

  template <class _Tp, size_t _Np>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp (&__t)[_Np]) const noexcept
    requires(sizeof(_Tp) >= 0)
  {
    return __t + 0;
  }

  template <class _Tp>
    requires __member_begin<_Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((__t.begin()))> >(__t.begin()))) {
    return static_cast<::std::__decay_t<decltype((__t.begin()))> >(__t.begin());
  }

  template <class _Tp>
    requires __unqualified_begin<_Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((begin(__t)))> >(begin(__t)))) {
    return static_cast<::std::__decay_t<decltype((begin(__t)))> >(begin(__t));
  }

  void operator()(auto&&) const = delete;
};
}

inline namespace __cpo {
inline constexpr auto begin = __begin::__fn{};
}
}



namespace ranges {
template <class _Tp>
using iterator_t = decltype(ranges::begin(std::declval<_Tp&>()));
}



namespace ranges {
namespace __end {
template <class _Tp>
concept __member_end = __can_borrow<_Tp> && __workaround_52970<_Tp> && requires(_Tp&& __t) {
  typename iterator_t<_Tp>;
  { static_cast<::std::__decay_t<decltype((__t.end()))> >(__t.end()) } -> sentinel_for<iterator_t<_Tp>>;
};

void end(auto&) = delete;
void end(const auto&) = delete;

template <class _Tp>
concept __unqualified_end =
    !__member_end<_Tp> && __can_borrow<_Tp> && __class_or_enum<remove_cvref_t<_Tp>> && requires(_Tp&& __t) {
      typename iterator_t<_Tp>;
      { static_cast<::std::__decay_t<decltype((end(__t)))> >(end(__t)) } -> sentinel_for<iterator_t<_Tp>>;
    };

struct __fn {
  template <class _Tp, size_t _Np>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp (&__t)[_Np]) const noexcept
    requires(sizeof(_Tp) >= 0)
  {
    return __t + _Np;
  }

  template <class _Tp>
    requires __member_end<_Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((__t.end()))> >(__t.end()))) {
    return static_cast<::std::__decay_t<decltype((__t.end()))> >(__t.end());
  }

  template <class _Tp>
    requires __unqualified_end<_Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((end(__t)))> >(end(__t)))) {
    return static_cast<::std::__decay_t<decltype((end(__t)))> >(end(__t));
  }

  void operator()(auto&&) const = delete;
};
}

inline namespace __cpo {
inline constexpr auto end = __end::__fn{};
}
}



namespace ranges {
namespace __cbegin {
struct __fn {
  template <class _Tp>
    requires is_lvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t))))
          -> decltype(ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t))) {
    return ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t));
  }

  template <class _Tp>
    requires is_rvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::begin(static_cast<const _Tp&&>(__t))))
          -> decltype(ranges::begin(static_cast<const _Tp&&>(__t))) {
    return ranges::begin(static_cast<const _Tp&&>(__t));
  }
};
}

inline namespace __cpo {
inline constexpr auto cbegin = __cbegin::__fn{};
}
}



namespace ranges {
namespace __cend {
struct __fn {
  template <class _Tp>
    requires is_lvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t))))
          -> decltype(ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t))) {
    return ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t));
  }

  template <class _Tp>
    requires is_rvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::end(static_cast<const _Tp&&>(__t))))
          -> decltype(ranges::end(static_cast<const _Tp&&>(__t))) {
    return ranges::end(static_cast<const _Tp&&>(__t));
  }
};
}

inline namespace __cpo {
inline constexpr auto cend = __cend::__fn{};
}
}



}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/data.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/data.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_pointer.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_pointer.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
struct remove_pointer {
  using type __attribute__((__nodebug__)) = __remove_pointer(_Tp);
};

template <class _Tp>
using __remove_pointer_t = __remove_pointer(_Tp);
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_pointer.h" 3
template <class _Tp>
using remove_pointer_t = __remove_pointer_t<_Tp>;


}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/data.h" 2 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/data.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





namespace ranges {
namespace __data {
template <class _Tp>
concept __ptr_to_object = is_pointer_v<_Tp> && is_object_v<remove_pointer_t<_Tp>>;

template <class _Tp>
concept __member_data = __can_borrow<_Tp> && __workaround_52970<_Tp> && requires(_Tp&& __t) {
  { static_cast<::std::__decay_t<decltype((__t.data()))> >(__t.data()) } -> __ptr_to_object;
};

template <class _Tp>
concept __ranges_begin_invocable = !__member_data<_Tp> && __can_borrow<_Tp> && requires(_Tp&& __t) {
  { ranges::begin(__t) } -> contiguous_iterator;
};

struct __fn {
  template <__member_data _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const noexcept(noexcept(__t.data())) {
    return __t.data();
  }

  template <__ranges_begin_invocable _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(std::to_address(ranges::begin(__t)))) {
    return std::to_address(ranges::begin(__t));
  }
};
}

inline namespace __cpo {
inline constexpr auto data = __data::__fn{};
}
}



namespace ranges {
namespace __cdata {
struct __fn {
  template <class _Tp>
    requires is_lvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t))))
          -> decltype(ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t))) {
    return ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t));
  }

  template <class _Tp>
    requires is_rvalue_reference_v<_Tp&&>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::data(static_cast<const _Tp&&>(__t))))
          -> decltype(ranges::data(static_cast<const _Tp&&>(__t))) {
    return ranges::data(static_cast<const _Tp&&>(__t));
  }
};
}

inline namespace __cpo {
inline constexpr auto cdata = __cdata::__fn{};
}
}



}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/enable_view.h" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/enable_view.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {

struct view_base {};

template <class _Derived>
  requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
class view_interface;

template <class _Op, class _Yp>
  requires is_convertible_v<_Op*, view_interface<_Yp>*>
void __is_derived_from_view_interface(const _Op*, const view_interface<_Yp>*);

template <class _Tp>
inline constexpr bool enable_view = derived_from<_Tp, view_base> || requires {
  ranges::__is_derived_from_view_interface((_Tp*)nullptr, (_Tp*)nullptr);
};

}



}}
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/size.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/size.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_unsigned.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_unsigned.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unsigned.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unsigned.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_unsigned : _BoolConstant<__is_unsigned(_Tp)> {};


template <class _Tp>
inline constexpr bool is_unsigned_v = __is_unsigned(_Tp);
# 57 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unsigned.h" 3
}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_unsigned.h" 2 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_unsigned.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
using __make_unsigned_t = __make_unsigned(_Tp);
# 79 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/make_unsigned.h" 3
template <class _Tp>
struct make_unsigned {
  using type __attribute__((__nodebug__)) = __make_unsigned_t<_Tp>;
};


template <class _Tp>
using make_unsigned_t = __make_unsigned_t<_Tp>;



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __make_unsigned_t<_Tp> __to_unsigned_like(_Tp __x) noexcept {
  return static_cast<__make_unsigned_t<_Tp> >(__x);
}


template <class _Tp, class _Up>
using __copy_unsigned_t = __conditional_t<is_unsigned<_Tp>::value, __make_unsigned_t<_Up>, _Up>;

}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/size.h" 2 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/size.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {
template <class>
inline constexpr bool disable_sized_range = false;
}



namespace ranges {
namespace __size {
void size(auto&) = delete;
void size(const auto&) = delete;

template <class _Tp>
concept __size_enabled = !disable_sized_range<remove_cvref_t<_Tp>>;

template <class _Tp>
concept __member_size = __size_enabled<_Tp> && __workaround_52970<_Tp> && requires(_Tp&& __t) {
  { static_cast<::std::__decay_t<decltype((__t.size()))> >(__t.size()) } -> __integer_like;
};

template <class _Tp>
concept __unqualified_size =
    __size_enabled<_Tp> && !__member_size<_Tp> && __class_or_enum<remove_cvref_t<_Tp>> && requires(_Tp&& __t) {
      { static_cast<::std::__decay_t<decltype((size(__t)))> >(size(__t)) } -> __integer_like;
    };

template <class _Tp>
concept __difference =
    !__member_size<_Tp> && !__unqualified_size<_Tp> && __class_or_enum<remove_cvref_t<_Tp>> && requires(_Tp&& __t) {
      { ranges::begin(__t) } -> forward_iterator;
      { ranges::end(__t) } -> sized_sentinel_for<decltype(ranges::begin(std::declval<_Tp>()))>;
    };

struct __fn {

  template <class _Tp, size_t _Sz>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t operator()(_Tp (&&)[_Sz]) const noexcept {
    return _Sz;
  }


  template <class _Tp, size_t _Sz>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t operator()(_Tp (&)[_Sz]) const noexcept {
    return _Sz;
  }


  template <__member_size _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __integer_like auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((__t.size()))> >(__t.size()))) {
    return static_cast<::std::__decay_t<decltype((__t.size()))> >(__t.size());
  }


  template <__unqualified_size _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __integer_like auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<::std::__decay_t<decltype((size(__t)))> >(size(__t)))) {
    return static_cast<::std::__decay_t<decltype((size(__t)))> >(size(__t));
  }


  template <__difference _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t))))
          -> decltype(std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t))) {
    return std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t));
  }
};

}

inline namespace __cpo {
inline constexpr auto size = __size::__fn{};
}
}



namespace ranges {
namespace __ssize {
struct __fn {
  template <class _Tp>
    requires requires(_Tp&& __t) { ranges::size(__t); }
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr integral auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::size(__t))) {
    using _Signed = make_signed_t<decltype(ranges::size(__t))>;
    if constexpr (sizeof(ptrdiff_t) > sizeof(_Signed))
      return static_cast<ptrdiff_t>(ranges::size(__t));
    else
      return static_cast<_Signed>(ranges::size(__t));
  }
};
}

inline namespace __cpo {
inline constexpr auto ssize = __ssize::__fn{};
}
}



}}
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 2 3





# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/initializer_list" 1 3
# 50 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/initializer_list" 3


namespace std
{



template <class _Ep>
class initializer_list {
  const _Ep* __begin_;
  size_t __size_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr initializer_list(const _Ep* __b, size_t __s) noexcept
      : __begin_(__b),
        __size_(__s) {}

public:
  typedef _Ep value_type;
  typedef const _Ep& reference;
  typedef const _Ep& const_reference;
  typedef size_t size_type;

  typedef const _Ep* iterator;
  typedef const _Ep* const_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr initializer_list() noexcept : __begin_(nullptr), __size_(0) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t size() const noexcept { return __size_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Ep* begin() const noexcept { return __begin_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Ep* end() const noexcept { return __begin_ + __size_; }
};

template <class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Ep* begin(initializer_list<_Ep> __il) noexcept {
  return __il.begin();
}

template <class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Ep* end(initializer_list<_Ep> __il) noexcept {
  return __il.end();
}



}
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 2 3
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {



template <class _Tp>
concept range = requires(_Tp& __t) {
  ranges::begin(__t);
  ranges::end(__t);
};

template <class _Tp>
concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;

template <class _Range>
concept borrowed_range =
    range<_Range> && (is_lvalue_reference_v<_Range> || enable_borrowed_range<remove_cvref_t<_Range>>);



template <range _Rp>
using sentinel_t = decltype(ranges::end(std::declval<_Rp&>()));

template <range _Rp>
using range_difference_t = iter_difference_t<iterator_t<_Rp>>;

template <range _Rp>
using range_value_t = iter_value_t<iterator_t<_Rp>>;

template <range _Rp>
using range_reference_t = iter_reference_t<iterator_t<_Rp>>;

template <range _Rp>
using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Rp>>;

template <range _Rp>
using range_common_reference_t = iter_common_reference_t<iterator_t<_Rp>>;


template <class _Tp>
concept sized_range = range<_Tp> && requires(_Tp& __t) { ranges::size(__t); };

template <sized_range _Rp>
using range_size_t = decltype(ranges::size(std::declval<_Rp&>()));
# 93 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/concepts.h" 3
template <class _Tp>
concept view = range<_Tp> && movable<_Tp> && enable_view<_Tp>;

template <class _Range>
concept __simple_view =
    view<_Range> && range<const _Range> && same_as<iterator_t<_Range>, iterator_t<const _Range>> &&
    same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;


template <class _Rp, class _Tp>
concept output_range = range<_Rp> && output_iterator<iterator_t<_Rp>, _Tp>;

template <class _Tp>
concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;

template <class _Tp>
concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;

template <class _Tp>
concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;

template <class _Tp>
concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires(_Tp& __t) {
  { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;
};

template <class _Tp>
concept common_range = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;

template <class _Tp>
inline constexpr bool __is_std_initializer_list = false;

template <class _Ep>
inline constexpr bool __is_std_initializer_list<initializer_list<_Ep>> = true;

template <class _Tp>
concept viewable_range =
    range<_Tp> &&
    ((view<remove_cvref_t<_Tp>> && constructible_from<remove_cvref_t<_Tp>, _Tp>) ||
     (!view<remove_cvref_t<_Tp>> &&
      (is_lvalue_reference_v<_Tp> ||
       (movable<remove_reference_t<_Tp>> && !__is_std_initializer_list<remove_cvref_t<_Tp>>))));

}



}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 2 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/distance.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag) {
  typename iterator_traits<_InputIter>::difference_type __r(0);
  for (; __first != __last; ++__first)
    ++__r;
  return __r;
}

template <class _RandIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag) {
  return __last - __first;
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last) {
  return std::__distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}





namespace ranges {
namespace __distance {

struct __fn {
  template <class _Ip, sentinel_for<_Ip> _Sp>
    requires(!sized_sentinel_for<_Sp, _Ip>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iter_difference_t<_Ip> operator()(_Ip __first, _Sp __last) const {
    iter_difference_t<_Ip> __n = 0;
    while (__first != __last) {
      ++__first;
      ++__n;
    }
    return __n;
  }

  template <class _Ip, sized_sentinel_for<decay_t<_Ip>> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iter_difference_t<_Ip> operator()(_Ip&& __first, _Sp __last) const {
    if constexpr (sized_sentinel_for<_Sp, __remove_cvref_t<_Ip>>) {
      return __last - __first;
    } else {
      return __last - decay_t<_Ip>(__first);
    }
  }

  template <range _Rp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr range_difference_t<_Rp> operator()(_Rp&& __r) const {
    if constexpr (sized_range<_Rp>) {
      return static_cast<range_difference_t<_Rp>>(ranges::size(__r));
    } else {
      return operator()(ranges::begin(__r), ranges::end(__r));
    }
  }
};

}

inline namespace __cpo {
inline constexpr auto distance = __distance::__fn{};
}
}



}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assert" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assert" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assertion_handler" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assertion_handler" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__verbose_abort" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__verbose_abort" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



[[noreturn]] __attribute__((__visibility__("default")))
    __attribute__((__format__(__printf__, 1, 2))) void __libcpp_verbose_abort(const char* __format, ...);
# 51 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__verbose_abort" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assertion_handler" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assertion_handler" 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assert" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__assert" 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/access.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/access.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* begin(_Tp (&__array)[_Np]) noexcept {
  return __array;
}

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* end(_Tp (&__array)[_Np]) noexcept {
  return __array + _Np;
}



template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto begin(_Cp& __c) -> decltype(__c.begin()) {
  return __c.begin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto begin(const _Cp& __c) -> decltype(__c.begin()) {
  return __c.begin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto end(_Cp& __c) -> decltype(__c.end()) {
  return __c.end();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto end(const _Cp& __c) -> decltype(__c.end()) {
  return __c.end();
}



template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto cbegin(const _Cp& __c) noexcept(noexcept(std::begin(__c)))
    -> decltype(std::begin(__c)) {
  return std::begin(__c);
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto cend(const _Cp& __c) noexcept(noexcept(std::end(__c))) -> decltype(std::end(__c)) {
  return std::end(__c);
}
# 93 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/access.h" 3
}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/voidify.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/voidify.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <typename _Tp>
__attribute__((__always_inline__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void* __voidify(_Tp& __from) {

  return const_cast<void*>(static_cast<const volatile void*>(std::addressof(__from)));
}

}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 2 3





# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 1 3
# 91 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__exception/exception.h" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__exception/exception.h" 3


namespace std {
# 72 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__exception/exception.h" 3
class __attribute__((__visibility__("default"))) exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) exception() noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) exception(const exception&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) exception& operator=(const exception&) noexcept = default;

  virtual ~exception() noexcept;
  virtual const char* what() const noexcept;
};

class __attribute__((__visibility__("default"))) bad_exception : public exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_exception() noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_exception(const bad_exception&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_exception& operator=(const bad_exception&) noexcept = default;
  ~bad_exception() noexcept override;
  const char* what() const noexcept override;
};


}
# 92 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 2 3
# 105 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
# 119 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
namespace std
{


struct __attribute__((__visibility__("default"))) nothrow_t {
  explicit nothrow_t() = default;
};
extern __attribute__((__visibility__("default"))) const nothrow_t nothrow;

class __attribute__((__visibility__("default"))) bad_alloc : public exception {
public:
  bad_alloc() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_alloc(const bad_alloc&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_alloc& operator=(const bad_alloc&) noexcept = default;
  ~bad_alloc() noexcept override;
  const char* what() const noexcept override;
};

class __attribute__((__visibility__("default"))) bad_array_new_length : public bad_alloc {
public:
  bad_array_new_length() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_array_new_length(const bad_array_new_length&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_array_new_length& operator=(const bad_array_new_length&) noexcept = default;
  ~bad_array_new_length() noexcept override;
  const char* what() const noexcept override;
};

typedef void (*new_handler)();
__attribute__((__visibility__("default"))) new_handler set_new_handler(new_handler) noexcept;
__attribute__((__visibility__("default"))) new_handler get_new_handler() noexcept;
# 170 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
[[noreturn]] __attribute__((__visibility__("default"))) void __throw_bad_alloc();

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_bad_array_new_length() {

  throw bad_array_new_length();



}



enum class align_val_t : size_t {};
# 191 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
struct destroying_delete_t {
  explicit destroying_delete_t() = default;
};
inline constexpr destroying_delete_t destroying_delete{};


}
# 207 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/new" 3
[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new(std::size_t __sz) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new(std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete(void* __p) noexcept;
__attribute__((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete(void* __p, std::size_t __sz) noexcept;


[[__nodiscard__]] __attribute__((__visibility__("default"))) void* operator new[](std::size_t __sz) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new[](std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete[](void* __p) noexcept;
__attribute__((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::size_t __sz) noexcept;



[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new(std::size_t __sz, std::align_val_t) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete(void* __p, std::align_val_t) noexcept;
__attribute__((__visibility__("default"))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete(void* __p, std::size_t __sz, std::align_val_t) noexcept;


[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new[](std::size_t __sz, std::align_val_t) ;
[[__nodiscard__]] __attribute__((__visibility__("default"))) void*
operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t) noexcept;
__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::size_t __sz, std::align_val_t) noexcept;



[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void* operator new(std::size_t, void* __p) noexcept {
  return __p;
}
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void* operator new[](std::size_t, void* __p) noexcept {
  return __p;
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void operator delete(void*, void*) noexcept {}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void operator delete[](void*, void*) noexcept {}



 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool __is_overaligned_for_new(size_t __align) noexcept {

  return __align > 16UL;



}

template <class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void* __libcpp_operator_new(_Args... __args) {

  return __builtin_operator_new(__args...);



}

template <class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __libcpp_operator_delete(_Args... __args) {

  __builtin_operator_delete(__args...);



}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void* __libcpp_allocate(size_t __size, size_t __align) {

  if (__is_overaligned_for_new(__align)) {
    const align_val_t __align_val = static_cast<align_val_t>(__align);
    return __libcpp_operator_new(__size, __align_val);
  }


  (void)__align;
  return __libcpp_operator_new(__size);
}

template <class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __do_deallocate_handle_size(void* __ptr, size_t __size, _Args... __args) {




  return std::__libcpp_operator_delete(__ptr, __size, __args...);

}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) {




  if (__is_overaligned_for_new(__align)) {
    const align_val_t __align_val = static_cast<align_val_t>(__align);
    return __do_deallocate_handle_size(__ptr, __size, __align_val);
  } else {
    return __do_deallocate_handle_size(__ptr, __size);
  }

}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __libcpp_deallocate_unsized(void* __ptr, size_t __align) {




  if (__is_overaligned_for_new(__align)) {
    const align_val_t __align_val = static_cast<align_val_t>(__align);
    return __libcpp_operator_delete(__ptr, __align_val);
  } else {
    return __libcpp_operator_delete(__ptr);
  }

}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* __launder(_Tp* __p) noexcept {
  static_assert(!(is_function<_Tp>::value), "can't launder functions");
  static_assert(!(is_same<void, __remove_cv_t<_Tp> >::value), "can't launder cv-void");
  return __builtin_launder(__p);
}


template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* launder(_Tp* __p) noexcept {
  return std::__launder(__p);
}






inline constexpr size_t hardware_destructive_interference_size = 256;
inline constexpr size_t hardware_constructive_interference_size = 64;





}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 2 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/construct_at.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class... _Args, class = decltype(::new(std::declval<void*>()) _Tp(std::declval<_Args>()...))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* construct_at(_Tp* __location, _Args&&... __args) {
  ((void)0);
  return ::new (std::__voidify(*__location)) _Tp(std::forward<_Args>(__args)...);
}



template <class _Tp, class... _Args, class = decltype(::new(std::declval<void*>()) _Tp(std::declval<_Args>()...))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* __construct_at(_Tp* __location, _Args&&... __args) {

  return std::construct_at(__location, std::forward<_Args>(__args)...);




}






template <class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator __destroy(_ForwardIterator, _ForwardIterator);

template <class _Tp, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __destroy_at(_Tp* __loc) {
  ((void)0);
  __loc->~_Tp();
}


template <class _Tp, __enable_if_t<is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __destroy_at(_Tp* __loc) {
  ((void)0);
  std::__destroy(std::begin(*__loc), std::end(*__loc));
}


template <class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
__destroy(_ForwardIterator __first, _ForwardIterator __last) {
  for (; __first != __last; ++__first)
    std::__destroy_at(std::addressof(*__first));
  return __first;
}

template <class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _BidirectionalIterator
__reverse_destroy(_BidirectionalIterator __first, _BidirectionalIterator __last) {
  while (__last != __first) {
    --__last;
    std::__destroy_at(std::addressof(*__last));
  }
  return __last;
}



template <class _Tp, enable_if_t<!is_array_v<_Tp>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void destroy_at(_Tp* __loc) {
  std::__destroy_at(__loc);
}


template <class _Tp, enable_if_t<is_array_v<_Tp>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void destroy_at(_Tp* __loc) {
  std::__destroy_at(__loc);
}


template <class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void destroy(_ForwardIterator __first, _ForwardIterator __last) {
  (void)std::__destroy(std::move(__first), std::move(__last));
}

template <class _ForwardIterator, class _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {
  for (; __n > 0; (void)++__first, --__n)
    std::__destroy_at(std::addressof(*__first));
  return __first;
}



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/datasizeof.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/datasizeof.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_final.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_final.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};


template <class _Tp>
struct is_final : public integral_constant<bool, __is_final(_Tp)> {};



template <class _Tp>
inline constexpr bool is_final_v = __is_final(_Tp);


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/datasizeof.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/datasizeof.h" 3








 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __libcpp_datasizeof {

  static const size_t value = __datasizeof(_Tp);
# 61 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/datasizeof.h" 3
};

}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdint" 1 3
# 145 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdint" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdint.h" 1 3
# 110 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdint.h" 3
# 124 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdint.h" 3
# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/stdint.h" 1 3
# 56 "/data/data/com.termux/files/usr/lib/clang/21/include/stdint.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/stdint.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/stdint.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/wchar_limits.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/stdint.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/stdint.h" 2 3 4

typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;

typedef long __int64_t;
typedef unsigned long __uint64_t;






typedef long __intptr_t;
typedef unsigned long __uintptr_t;





typedef __int8_t int8_t;
typedef __uint8_t uint8_t;

typedef __int16_t int16_t;
typedef __uint16_t uint16_t;

typedef __int32_t int32_t;
typedef __uint32_t uint32_t;

typedef __int64_t int64_t;
typedef __uint64_t uint64_t;

typedef __intptr_t intptr_t;
typedef __uintptr_t uintptr_t;

typedef int8_t int_least8_t;
typedef uint8_t uint_least8_t;

typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;

typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;

typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;

typedef int8_t int_fast8_t;
typedef uint8_t uint_fast8_t;

typedef int64_t int_fast64_t;
typedef uint64_t uint_fast64_t;


typedef int64_t int_fast16_t;
typedef uint64_t uint_fast16_t;
typedef int64_t int_fast32_t;
typedef uint64_t uint_fast32_t;







typedef uint64_t uintmax_t;
typedef int64_t intmax_t;
# 57 "/data/data/com.termux/files/usr/lib/clang/21/include/stdint.h" 2 3
# 125 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdint.h" 2 3
# 146 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdint" 2 3
# 157 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdint" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

using ::int8_t __attribute__((__using_if_exists__));
using ::int16_t __attribute__((__using_if_exists__));
using ::int32_t __attribute__((__using_if_exists__));
using ::int64_t __attribute__((__using_if_exists__));

using ::uint8_t __attribute__((__using_if_exists__));
using ::uint16_t __attribute__((__using_if_exists__));
using ::uint32_t __attribute__((__using_if_exists__));
using ::uint64_t __attribute__((__using_if_exists__));

using ::int_least8_t __attribute__((__using_if_exists__));
using ::int_least16_t __attribute__((__using_if_exists__));
using ::int_least32_t __attribute__((__using_if_exists__));
using ::int_least64_t __attribute__((__using_if_exists__));

using ::uint_least8_t __attribute__((__using_if_exists__));
using ::uint_least16_t __attribute__((__using_if_exists__));
using ::uint_least32_t __attribute__((__using_if_exists__));
using ::uint_least64_t __attribute__((__using_if_exists__));

using ::int_fast8_t __attribute__((__using_if_exists__));
using ::int_fast16_t __attribute__((__using_if_exists__));
using ::int_fast32_t __attribute__((__using_if_exists__));
using ::int_fast64_t __attribute__((__using_if_exists__));

using ::uint_fast8_t __attribute__((__using_if_exists__));
using ::uint_fast16_t __attribute__((__using_if_exists__));
using ::uint_fast32_t __attribute__((__using_if_exists__));
using ::uint_fast64_t __attribute__((__using_if_exists__));

using ::intptr_t __attribute__((__using_if_exists__));
using ::uintptr_t __attribute__((__using_if_exists__));

using ::intmax_t __attribute__((__using_if_exists__));
using ::uintmax_t __attribute__((__using_if_exists__));

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {};


template <class _Tp>
inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);



template <class _Tp>
inline constexpr bool __is_cheap_to_copy = is_trivially_copyable_v<_Tp> && sizeof(_Tp) <= sizeof(std::intmax_t);


}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {







template <class _From, class _To>
struct __is_always_bitcastable {
  using _UnqualFrom = __remove_cv_t<_From>;
  using _UnqualTo = __remove_cv_t<_To>;


  static const bool value =

      (is_same<_UnqualFrom, _UnqualTo>::value && is_trivially_copyable<_UnqualFrom>::value) ||
# 74 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 3
      (
        sizeof(_From) == sizeof(_To) &&
        is_integral<_From>::value &&
        is_integral<_To>::value &&
        !is_same<_UnqualTo, bool>::value
      );

};

}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_assignable.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Up>
struct is_assignable : _BoolConstant<__is_assignable(_Tp, _Up)> {};


template <class _Tp, class _Arg>
inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Arg);


}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_constant_evaluated.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_constant_evaluated.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr bool is_constant_evaluated() noexcept {
  return __builtin_is_constant_evaluated();
}


__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr bool __libcpp_is_constant_evaluated() noexcept {
  return __builtin_is_constant_evaluated();
}

}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_equality_comparable.h" 1 3
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_equality_comparable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Up, class = void>
struct __is_equality_comparable : false_type {};

template <class _Tp, class _Up>
struct __is_equality_comparable<_Tp, _Up, __void_t<decltype(std::declval<_Tp>() == std::declval<_Up>())> > : true_type {
};
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_equality_comparable.h" 3
template <class _Tp, class _Up, class = void>
struct __libcpp_is_trivially_equality_comparable_impl : false_type {};

template <class _Tp>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp, _Tp>

    : integral_constant<bool, __is_trivially_equality_comparable(_Tp) && __is_equality_comparable<_Tp, _Tp>::value> {
};





template <class _Tp, class _Up>
struct __libcpp_is_trivially_equality_comparable_impl<
    _Tp,
    _Up,
    __enable_if_t<is_integral<_Tp>::value && is_integral<_Up>::value && !is_same<_Tp, _Up>::value &&
                  is_signed<_Tp>::value == is_signed<_Up>::value && sizeof(_Tp) == sizeof(_Up)> > : true_type {};

template <class _Tp>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp*, _Tp*> : true_type {};


template <class _Tp, class _Up>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp*, _Up*>
    : integral_constant<
          bool,
          __is_equality_comparable<_Tp*, _Up*>::value &&
              (is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value || is_void<_Tp>::value || is_void<_Up>::value)> {
};

template <class _Tp, class _Up>
using __libcpp_is_trivially_equality_comparable =
    __libcpp_is_trivially_equality_comparable_impl<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >;

}}
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 3
template <class _Tp, class _Up>
struct __libcpp_is_trivially_lexicographically_comparable
    : integral_constant<bool,
                        is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value && sizeof(_Tp) == 1 &&
                            is_unsigned<_Tp>::value> {};

}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/is_pointer_in_range.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/is_pointer_in_range.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Up, class = void>
struct __is_less_than_comparable : false_type {};

template <class _Tp, class _Up>
struct __is_less_than_comparable<_Tp, _Up, __void_t<decltype(std::declval<_Tp>() < std::declval<_Up>())> > : true_type {
};

template <class _Tp, class _Up, __enable_if_t<__is_less_than_comparable<const _Tp*, const _Up*>::value, int> = 0>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("address"))) bool __is_pointer_in_range(
    const _Tp* __begin, const _Tp* __end, const _Up* __ptr) {
  if (__libcpp_is_constant_evaluated()) {
    ((void)0);



    if (!__builtin_constant_p(__begin <= __ptr && __ptr < __end))
      return false;
  }


  return !__less<>()(__ptr, __begin) && __less<>()(__ptr, __end);
}

template <class _Tp, class _Up, __enable_if_t<!__is_less_than_comparable<const _Tp*, const _Up*>::value, int> = 0>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("address"))) bool __is_pointer_in_range(
    const _Tp* __begin, const _Tp* __end, const _Up* __ptr) {
  if (__libcpp_is_constant_evaluated())
    return false;

  return reinterpret_cast<const char*>(__begin) <= reinterpret_cast<const char*>(__ptr) &&
         reinterpret_cast<const char*>(__ptr) < reinterpret_cast<const char*>(__end);
}

}}
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



enum class __element_count : size_t {};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t __constexpr_strlen(const char* __str) {
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 3
  return __builtin_strlen(__str);
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int
__constexpr_memcmp(const _Tp* __lhs, const _Up* __rhs, __element_count __n) {
  static_assert(__libcpp_is_trivially_lexicographically_comparable<_Tp, _Up>::value,
                "_Tp and _Up have to be trivially lexicographically comparable");

  auto __count = static_cast<size_t>(__n);

  if (__libcpp_is_constant_evaluated()) {

    if (sizeof(_Tp) == 1 && !is_same<_Tp, bool>::value)
      return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp));


    while (__count != 0) {
      if (*__lhs < *__rhs)
        return -1;
      if (*__rhs < *__lhs)
        return 1;

      --__count;
      ++__lhs;
      ++__rhs;
    }
    return 0;
  } else {
    return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp));
  }
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
__constexpr_memcmp_equal(const _Tp* __lhs, const _Up* __rhs, __element_count __n) {
  static_assert(__libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                "_Tp and _Up have to be trivially equality comparable");

  auto __count = static_cast<size_t>(__n);

  if (__libcpp_is_constant_evaluated()) {

    if (sizeof(_Tp) == 1 && is_integral<_Tp>::value && !is_same<_Tp, bool>::value)
      return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp)) == 0;

    while (__count != 0) {
      if (*__lhs != *__rhs)
        return false;

      --__count;
      ++__lhs;
      ++__rhs;
    }
    return true;
  } else {
    return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp)) == 0;
  }
}

template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* __constexpr_memchr(_Tp* __str, _Up __value, size_t __count) {
  static_assert(sizeof(_Tp) == 1 && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                "Calling memchr on non-trivially equality comparable types is unsafe.");

  if (__libcpp_is_constant_evaluated()) {


    if constexpr (is_same_v<remove_cv_t<_Tp>, char> && is_same_v<remove_cv_t<_Up>, char>)
      return __builtin_char_memchr(__str, __value, __count);


    for (; __count; --__count) {
      if (*__str == __value)
        return __str;
      ++__str;
    }
    return nullptr;
  } else {
    char __value_buffer = 0;
    __builtin_memcpy(&__value_buffer, &__value, sizeof(char));
    return static_cast<_Tp*>(__builtin_memchr(__str, __value_buffer, __count));
  }
}
# 150 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/constexpr_c_functions.h" 3
template <class _Tp, class _Up, __enable_if_t<is_assignable<_Tp&, _Up const&>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up const& __src) {
  __dest = __src;
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                               is_assignable<_Tp&, _Up&&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up& __src) {
  __dest =
      static_cast<_Up&&>(__src);
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                              !is_assignable<_Tp&, _Up&&>::value &&
                                               is_constructible<_Tp, _Up const&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up const& __src) {


  std::__construct_at(std::addressof(__dest), __src);
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                              !is_assignable<_Tp&, _Up&&>::value &&
                                              !is_constructible<_Tp, _Up const&>::value &&
                                               is_constructible<_Tp, _Up&&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& __assign_trivially_copyable(_Tp& __dest, _Up& __src) {


  std::__construct_at(
      std::addressof(__dest),
      static_cast<_Up&&>(__src));
  return __dest;
}

template <class _Tp, class _Up, __enable_if_t<__is_always_bitcastable<_Up, _Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp*
__constexpr_memmove(_Tp* __dest, _Up* __src, __element_count __n) {
  size_t __count = static_cast<size_t>(__n);
  if (__libcpp_is_constant_evaluated()) {

    if (is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value) {
      ::__builtin_memmove(__dest, __src, __count * sizeof(_Tp));
      return __dest;
    }

    if (std::__is_pointer_in_range(__src, __src + __count, __dest)) {
      for (; __count > 0; --__count)
        std::__assign_trivially_copyable(__dest[__count - 1], __src[__count - 1]);
    } else {
      for (size_t __i = 0; __i != __count; ++__i)
        std::__assign_trivially_copyable(__dest[__i], __src[__i]);
    }
  } else if (__count > 0) {
    ::__builtin_memmove(__dest, __src, (__count - 1) * sizeof(_Tp) + __libcpp_datasizeof<_Tp>::value);
  }
  return __dest;
}

}}
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/equal.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __equal_iter_impl(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate& __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return true;
}

template <class _Tp,
          class _Up,
          class _BinaryPredicate,
          __enable_if_t<__desugars_to<__equal_tag, _BinaryPredicate, _Tp, _Up>::value && !is_volatile<_Tp>::value &&
                            !is_volatile<_Up>::value && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                        int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
__equal_iter_impl(_Tp* __first1, _Tp* __last1, _Up* __first2, _BinaryPredicate&) {
  return std::__constexpr_memcmp_equal(__first1, __first2, __element_count(__last1 - __first1));
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) {
  return std::__equal_iter_impl(
      std::__unwrap_iter(__first1), std::__unwrap_iter(__last1), std::__unwrap_iter(__first2), __pred);
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
  return std::equal(__first1, __last1, __first2, __equal_to());
}


template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
__equal(_InputIterator1 __first1,
        _InputIterator1 __last1,
        _InputIterator2 __first2,
        _InputIterator2 __last2,
        _BinaryPredicate __pred,
        input_iterator_tag,
        input_iterator_tag) {
  for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return __first1 == __last1 && __first2 == __last2;
}

template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Pred, class _Proj1, class _Proj2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __equal_impl(
    _Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2, _Pred& __comp, _Proj1& __proj1, _Proj2& __proj2) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (!std::__invoke(__comp, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
      return false;
    ++__first1;
    ++__first2;
  }
  return __first1 == __last1 && __first2 == __last2;
}

template <class _Tp,
          class _Up,
          class _Pred,
          class _Proj1,
          class _Proj2,
          __enable_if_t<__desugars_to<__equal_tag, _Pred, _Tp, _Up>::value && __is_identity<_Proj1>::value &&
                            __is_identity<_Proj2>::value && !is_volatile<_Tp>::value && !is_volatile<_Up>::value &&
                            __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                        int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
__equal_impl(_Tp* __first1, _Tp* __last1, _Up* __first2, _Up*, _Pred&, _Proj1&, _Proj2&) {
  return std::__constexpr_memcmp_equal(__first1, __first2, __element_count(__last1 - __first1));
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
__equal(_RandomAccessIterator1 __first1,
        _RandomAccessIterator1 __last1,
        _RandomAccessIterator2 __first2,
        _RandomAccessIterator2 __last2,
        _BinaryPredicate __pred,
        random_access_iterator_tag,
        random_access_iterator_tag) {
  if (std::distance(__first1, __last1) != std::distance(__first2, __last2))
    return false;
  __identity __proj;
  return std::__equal_impl(
      std::__unwrap_iter(__first1),
      std::__unwrap_iter(__last1),
      std::__unwrap_iter(__first2),
      std::__unwrap_iter(__last2),
      __pred,
      __proj,
      __proj);
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
equal(_InputIterator1 __first1,
      _InputIterator1 __last1,
      _InputIterator2 __first2,
      _InputIterator2 __last2,
      _BinaryPredicate __pred) {
  return std::__equal<_BinaryPredicate&>(
      __first1,
      __last1,
      __first2,
      __last2,
      __pred,
      typename iterator_traits<_InputIterator1>::iterator_category(),
      typename iterator_traits<_InputIterator2>::iterator_category());
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::__equal(
      __first1,
      __last1,
      __first2,
      __last2,
      __equal_to(),
      typename iterator_traits<_InputIterator1>::iterator_category(),
      typename iterator_traits<_InputIterator2>::iterator_category());
}


}}
# 115 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/fill_n.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/fill_n.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/convert_to_integral.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/convert_to_integral.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/underlying_type.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/underlying_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, bool = is_enum<_Tp>::value>
struct __underlying_type_impl;

template <class _Tp>
struct __underlying_type_impl<_Tp, false> {};

template <class _Tp>
struct __underlying_type_impl<_Tp, true> {
  typedef __underlying_type(_Tp) type;
};

template <class _Tp>
struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {};


template <class _Tp>
using underlying_type_t = typename underlying_type<_Tp>::type;


}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/convert_to_integral.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/convert_to_integral.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int __convert_to_integral(int __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unsigned __convert_to_integral(unsigned __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr long __convert_to_integral(long __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unsigned long __convert_to_integral(unsigned long __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr long long __convert_to_integral(long long __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unsigned long long __convert_to_integral(unsigned long long __val) {
  return __val;
}

template <typename _Fp, __enable_if_t<is_floating_point<_Fp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr long long __convert_to_integral(_Fp __val) {
  return __val;
}


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __int128_t __convert_to_integral(__int128_t __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __uint128_t __convert_to_integral(__uint128_t __val) { return __val; }


template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type {
  typedef typename underlying_type<_Tp>::type type;
  typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) {
  return __val;
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/fill_n.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/fill_n.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value) {
  for (; __n > 0; ++__first, (void)--__n)
    *__first = __value;
  return __first;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value) {
  return std::__fill_n(__first, std::__convert_to_integral(__n), __value);
}

}}
# 116 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp_ref_type.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/comp_ref_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Compare>
struct __debug_less {
  _Compare& __comp_;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __debug_less(_Compare& __c) : __comp_(__c) {}

  template <class _Tp, class _Up>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const _Tp& __x, const _Up& __y) {
    bool __r = __comp_(__x, __y);
    if (__r)
      __do_compare_assert(0, __y, __x);
    return __r;
  }

  template <class _Tp, class _Up>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(_Tp& __x, _Up& __y) {
    bool __r = __comp_(__x, __y);
    if (__r)
      __do_compare_assert(0, __y, __x);
    return __r;
  }

  template <class _LHS, class _RHS>
  constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) decltype((void)std::declval<_Compare&>()(
      std::declval<_LHS&>(), std::declval<_RHS&>()))
  __do_compare_assert(int, _LHS& __l, _RHS& __r) {
    ((void)0);
    (void)__l;
    (void)__r;
  }

  template <class _LHS, class _RHS>
  constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __do_compare_assert(long, _LHS&, _RHS&) {}
};






template <class _Comp>
using __comp_ref_type = _Comp&;


}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Compare, class _InputIterator1, class _InputIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __lexicographical_compare(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _Compare __comp) {
  for (; __first2 != __last2; ++__first1, (void)++__first2) {
    if (__first1 == __last1 || __comp(*__first1, *__first2))
      return true;
    if (__comp(*__first2, *__first1))
      return false;
  }
  return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool lexicographical_compare(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _Compare __comp) {
  return std::__lexicographical_compare<__comp_ref_type<_Compare> >(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool lexicographical_compare(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::lexicographical_compare(__first1, __last1, __first2, __last2, __less<>());
}

}}
# 117 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min_element.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min_element.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_callable.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_callable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Func, class... _Args, class = decltype(std::declval<_Func>()(std::declval<_Args>()...))>
true_type __is_callable_helper(int);
template <class...>
false_type __is_callable_helper(...);

template <class _Func, class... _Args>
struct __is_callable : decltype(std::__is_callable_helper<_Func, _Args...>(0)) {};

}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min_element.h" 2 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min_element.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min_element.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Comp, class _Iter, class _Sent, class _Proj>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter
__min_element(_Iter __first, _Sent __last, _Comp __comp, _Proj& __proj) {
  if (__first == __last)
    return __first;

  _Iter __i = __first;
  while (++__i != __last)
    if (std::__invoke(__comp, std::__invoke(__proj, *__i), std::__invoke(__proj, *__first)))
      __first = __i;

  return __first;
}

template <class _Comp, class _Iter, class _Sent>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter __min_element(_Iter __first, _Sent __last, _Comp __comp) {
  auto __proj = __identity();
  return std::__min_element<_Comp>(std::move(__first), std::move(__last), __comp, __proj);
}

template <class _ForwardIterator, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  static_assert(
      __has_forward_iterator_category<_ForwardIterator>::value, "std::min_element requires a ForwardIterator");
  static_assert(
      __is_callable<_Compare, decltype(*__first), decltype(*__first)>::value, "The comparator has to be callable");

  return std::__min_element<__comp_ref_type<_Compare> >(std::move(__first), std::move(__last), __comp);
}

template <class _ForwardIterator>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::min_element(__first, __last, __less<>());
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/min.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp&
min([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp&
min([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b) {
  return std::min(__a, __b, __less<>());
}



template <class _Tp, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp
min(initializer_list<_Tp> __t, _Compare __comp) {
  return *std::__min_element<__comp_ref_type<_Compare> >(__t.begin(), __t.end(), __comp);
}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp min(initializer_list<_Tp> __t) {
  return *std::min_element(__t.begin(), __t.end(), __less<>());
}



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/three_way_comp_ref_type.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/three_way_comp_ref_type.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/ordering.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/ordering.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




enum class _OrdResult : signed char { __less = -1, __equiv = 0, __greater = 1 };

enum class _NCmpResult : signed char { __unordered = -127 };

class partial_ordering;
class weak_ordering;
class strong_ordering;

template <class _Tp, class... _Args>
inline constexpr bool __one_of_v = (is_same_v<_Tp, _Args> || ...);

struct _CmpUnspecifiedParam {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _CmpUnspecifiedParam(int _CmpUnspecifiedParam::*) noexcept {}

  template <class _Tp, class = enable_if_t<!__one_of_v<_Tp, int, partial_ordering, weak_ordering, strong_ordering>>>
  _CmpUnspecifiedParam(_Tp) = delete;
};

class partial_ordering {
  using _ValueT = signed char;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit constexpr partial_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit constexpr partial_ordering(_NCmpResult __v) noexcept : __value_(_ValueT(__v)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __is_ordered() const noexcept {
    return __value_ != _ValueT(_NCmpResult::__unordered);
  }

public:

  static const partial_ordering less;
  static const partial_ordering equivalent;
  static const partial_ordering greater;
  static const partial_ordering unordered;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(partial_ordering, partial_ordering) noexcept = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ < 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ <= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ > 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ >= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 < __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 <= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 > __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 >= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr partial_ordering
  operator<=>(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr partial_ordering
  operator<=>(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v < 0 ? partial_ordering::greater : (__v > 0 ? partial_ordering::less : __v);
  }

private:
  _ValueT __value_;
};

inline constexpr partial_ordering partial_ordering::less(_OrdResult::__less);
inline constexpr partial_ordering partial_ordering::equivalent(_OrdResult::__equiv);
inline constexpr partial_ordering partial_ordering::greater(_OrdResult::__greater);
inline constexpr partial_ordering partial_ordering::unordered(_NCmpResult ::__unordered);

class weak_ordering {
  using _ValueT = signed char;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit constexpr weak_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}

public:
  static const weak_ordering less;
  static const weak_ordering equivalent;
  static const weak_ordering greater;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator partial_ordering() const noexcept {
    return __value_ == 0 ? partial_ordering::equivalent
                         : (__value_ < 0 ? partial_ordering::less : partial_ordering::greater);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(weak_ordering, weak_ordering) noexcept = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ < 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ <= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ > 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ >= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 < __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 <= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 > __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 >= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr weak_ordering operator<=>(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr weak_ordering operator<=>(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return __v < 0 ? weak_ordering::greater : (__v > 0 ? weak_ordering::less : __v);
  }

private:
  _ValueT __value_;
};

inline constexpr weak_ordering weak_ordering::less(_OrdResult::__less);
inline constexpr weak_ordering weak_ordering::equivalent(_OrdResult::__equiv);
inline constexpr weak_ordering weak_ordering::greater(_OrdResult::__greater);

class strong_ordering {
  using _ValueT = signed char;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit constexpr strong_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}

public:
  static const strong_ordering less;
  static const strong_ordering equal;
  static const strong_ordering equivalent;
  static const strong_ordering greater;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator partial_ordering() const noexcept {
    return __value_ == 0 ? partial_ordering::equivalent
                         : (__value_ < 0 ? partial_ordering::less : partial_ordering::greater);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator weak_ordering() const noexcept {
    return __value_ == 0 ? weak_ordering::equivalent : (__value_ < 0 ? weak_ordering::less : weak_ordering::greater);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(strong_ordering, strong_ordering) noexcept = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator==(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ < 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ <= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ > 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ >= 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 < __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator<=(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 <= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 > __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool operator>=(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 >= __v.__value_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr strong_ordering
  operator<=>(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr strong_ordering
  operator<=>(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return __v < 0 ? strong_ordering::greater : (__v > 0 ? strong_ordering::less : __v);
  }

private:
  _ValueT __value_;
};

inline constexpr strong_ordering strong_ordering::less(_OrdResult::__less);
inline constexpr strong_ordering strong_ordering::equal(_OrdResult::__equiv);
inline constexpr strong_ordering strong_ordering::equivalent(_OrdResult::__equiv);
inline constexpr strong_ordering strong_ordering::greater(_OrdResult::__greater);




template <class _Tp>
concept __comparison_category = __one_of_v<_Tp, partial_ordering, weak_ordering, strong_ordering>;



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/three_way_comp_ref_type.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/three_way_comp_ref_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Comp>
struct __debug_three_way_comp {
  _Comp& __comp_;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __debug_three_way_comp(_Comp& __c) : __comp_(__c) {}

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(const _Tp& __x, const _Up& __y) {
    auto __r = __comp_(__x, __y);
    if constexpr (__comparison_category<decltype(__comp_(__x, __y))>)
      __do_compare_assert(__y, __x, __r);
    return __r;
  }

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp& __x, _Up& __y) {
    auto __r = __comp_(__x, __y);
    if constexpr (__comparison_category<decltype(__comp_(__x, __y))>)
      __do_compare_assert(__y, __x, __r);
    return __r;
  }

  template <class _LHS, class _RHS, class _Order>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __do_compare_assert(_LHS& __l, _RHS& __r, _Order __o) {
    _Order __expected = __o;
    if (__o == _Order::less)
      __expected = _Order::greater;
    if (__o == _Order::greater)
      __expected = _Order::less;
    ((void)0);

    (void)__l;
    (void)__r;
  }
};






template <class _Comp>
using __three_way_comp_ref_type = _Comp&;




}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/three_way_comparable.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/three_way_comparable.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/common_comparison_category.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/common_comparison_category.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace __comp_detail {

enum _ClassifyCompCategory : unsigned { _None, _PartialOrd, _WeakOrd, _StrongOrd, _CCC_Size };

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ClassifyCompCategory __type_to_enum() noexcept {
  if (is_same_v<_Tp, partial_ordering>)
    return _PartialOrd;
  if (is_same_v<_Tp, weak_ordering>)
    return _WeakOrd;
  if (is_same_v<_Tp, strong_ordering>)
    return _StrongOrd;
  return _None;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ClassifyCompCategory
__compute_comp_type(const _ClassifyCompCategory (&__types)[_Size]) {
  int __seen[_CCC_Size] = {};
  for (auto __type : __types)
    ++__seen[__type];
  if (__seen[_None])
    return _None;
  if (__seen[_PartialOrd])
    return _PartialOrd;
  if (__seen[_WeakOrd])
    return _WeakOrd;
  return _StrongOrd;
}

template <class... _Ts, bool _False = false>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto __get_comp_type() {
  using _CCC = _ClassifyCompCategory;
  constexpr _CCC __type_kinds[] = {_StrongOrd, __type_to_enum<_Ts>()...};
  constexpr _CCC __cat = __comp_detail::__compute_comp_type(__type_kinds);
  if constexpr (__cat == _None)
    return void();
  else if constexpr (__cat == _PartialOrd)
    return partial_ordering::equivalent;
  else if constexpr (__cat == _WeakOrd)
    return weak_ordering::equivalent;
  else if constexpr (__cat == _StrongOrd)
    return strong_ordering::equivalent;
  else
    static_assert(_False, "unhandled case");
}
}


template <class... _Ts>
struct common_comparison_category {
  using type = decltype(__comp_detail::__get_comp_type<_Ts...>());
};

template <class... _Ts>
using common_comparison_category_t = typename common_comparison_category<_Ts...>::type;



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/three_way_comparable.h" 2 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/three_way_comparable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp, class _Cat>
concept __compares_as = same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;

template <class _Tp, class _Cat = partial_ordering>
concept three_way_comparable =
    __weakly_equality_comparable_with<_Tp, _Tp> && __partially_ordered_with<_Tp, _Tp> &&
    requires(__make_const_lvalue_ref<_Tp> __a, __make_const_lvalue_ref<_Tp> __b) {
      { __a <=> __b } -> __compares_as<_Cat>;
    };

template <class _Tp, class _Up, class _Cat = partial_ordering>
concept three_way_comparable_with =
    three_way_comparable<_Tp, _Cat> && three_way_comparable<_Up, _Cat> &&
    common_reference_with<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>> &&
    three_way_comparable<common_reference_t<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>>, _Cat> &&
    __weakly_equality_comparable_with<_Tp, _Up> && __partially_ordered_with<_Tp, _Up> &&
    requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
      { __t <=> __u } -> __compares_as<_Cat>;
      { __u <=> __t } -> __compares_as<_Cat>;
    };



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



struct compare_three_way {
  template <class _T1, class _T2>
    requires three_way_comparable_with<_T1, _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) <=> std::forward<_T2>(__u))) {
    return std::forward<_T1>(__t) <=> std::forward<_T2>(__u);
  }

  using is_transparent = void;
};



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _InputIterator1, class _InputIterator2, class _Cmp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto __lexicographical_compare_three_way_fast_path(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Cmp& __comp)
    -> decltype(__comp(*__first1, *__first2)) {
  static_assert(
      signed_integral<__iter_diff_t<_InputIterator1>>, "Using a non-integral difference_type is undefined behavior.");
  static_assert(
      signed_integral<__iter_diff_t<_InputIterator2>>, "Using a non-integral difference_type is undefined behavior.");

  using _Len1 = __iter_diff_t<_InputIterator1>;
  using _Len2 = __iter_diff_t<_InputIterator2>;
  using _Common = common_type_t<_Len1, _Len2>;

  _Len1 __len1 = __last1 - __first1;
  _Len2 __len2 = __last2 - __first2;
  _Common __min_len = std::min<_Common>(__len1, __len2);

  for (_Common __i = 0; __i < __min_len; ++__i) {
    auto __c = __comp(*__first1, *__first2);
    if (__c != 0) {
      return __c;
    }
    ++__first1;
    ++__first2;
  }

  return __len1 <=> __len2;
}


template <class _InputIterator1, class _InputIterator2, class _Cmp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto __lexicographical_compare_three_way_slow_path(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Cmp& __comp)
    -> decltype(__comp(*__first1, *__first2)) {
  while (true) {
    bool __exhausted1 = __first1 == __last1;
    bool __exhausted2 = __first2 == __last2;

    if (__exhausted1 || __exhausted2) {
      if (!__exhausted1)
        return strong_ordering::greater;
      if (!__exhausted2)
        return strong_ordering::less;
      return strong_ordering::equal;
    }

    auto __c = __comp(*__first1, *__first2);
    if (__c != 0) {
      return __c;
    }

    ++__first1;
    ++__first2;
  }
}

template <class _InputIterator1, class _InputIterator2, class _Cmp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto lexicographical_compare_three_way(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Cmp __comp)
    -> decltype(__comp(*__first1, *__first2)) {
  static_assert(__comparison_category<decltype(__comp(*__first1, *__first2))>,
                "The comparator passed to lexicographical_compare_three_way must return a comparison category type.");
  static_assert(std::is_copy_constructible_v<_InputIterator1>, "Iterators must be copy constructible.");
  static_assert(std::is_copy_constructible_v<_InputIterator2>, "Iterators must be copy constructible.");
  __three_way_comp_ref_type<_Cmp> __wrapped_comp_ref(__comp);
  if constexpr (__has_random_access_iterator_category<_InputIterator1>::value &&
                __has_random_access_iterator_category<_InputIterator2>::value) {
    return std::__lexicographical_compare_three_way_fast_path(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __wrapped_comp_ref);
  } else {

    return std::__lexicographical_compare_three_way_slow_path(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __wrapped_comp_ref);
  }
}

template <class _InputIterator1, class _InputIterator2>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto lexicographical_compare_three_way(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::lexicographical_compare_three_way(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), std::compare_three_way());
}



}}
# 118 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iter_swap.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iter_swap.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)

    noexcept(noexcept(swap(*std::declval<_ForwardIterator1>(), *std::declval<_ForwardIterator2>()))) {
  swap(*__a, *__b);
}

}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/ranges_iterator_concept.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/ranges_iterator_concept.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/ranges_iterator_concept.h" 2 3



 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

namespace ranges {

template <class _IterMaybeQualified>
consteval auto __get_iterator_concept() {
  using _Iter = __remove_cvref_t<_IterMaybeQualified>;

  if constexpr (contiguous_iterator<_Iter>)
    return contiguous_iterator_tag();
  else if constexpr (random_access_iterator<_Iter>)
    return random_access_iterator_tag();
  else if constexpr (bidirectional_iterator<_Iter>)
    return bidirectional_iterator_tag();
  else if constexpr (forward_iterator<_Iter>)
    return forward_iterator_tag();
  else if constexpr (input_iterator<_Iter>)
    return input_iterator_tag();
}

template <class _Iter>
using __iterator_concept = decltype(__get_iterator_concept<_Iter>());

}
}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 1 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/unreachable.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/unreachable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

[[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline void __libcpp_unreachable() {
  ((void)0);
  __builtin_unreachable();
}



[[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline void unreachable() { __libcpp_unreachable(); }



}}
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/limits" 1 3
# 112 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/limits" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 116 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/limits" 2 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

enum float_round_style {
  round_indeterminate = -1,
  round_toward_zero = 0,
  round_to_nearest = 1,
  round_toward_infinity = 2,
  round_toward_neg_infinity = 3
};

enum __attribute__((__deprecated__)) float_denorm_style {
  denorm_indeterminate = -1,
  denorm_absent = 0,
  denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits {
protected:
  typedef _Tp type;

  static constexpr const bool is_specialized = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return type(); }

  static constexpr const int digits = 0;
  static constexpr const int digits10 = 0;
  static constexpr const int max_digits10 = 0;
  static constexpr const bool is_signed = false;
  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 0;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return type(); }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_absent;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return type(); }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = false;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min {
  static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};

template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false> {
  static constexpr const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true> {
protected:
  typedef _Tp type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = type(-1) < type(0);
  static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
  static constexpr const int digits10 = digits * 3 / 10;
  static constexpr const int max_digits10 = 0;
  static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
  static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return __min; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return __max; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return min(); }

  static constexpr const bool is_integer = true;
  static constexpr const bool is_exact = true;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return type(0); }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_absent;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return type(0); }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = !std::is_signed<_Tp>::value;




  static constexpr const bool traps = false;

  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true> {
protected:
  typedef bool type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = false;
  static constexpr const int digits = 1;
  static constexpr const int digits10 = 0;
  static constexpr const int max_digits10 = 0;
  static constexpr const type __min = false;
  static constexpr const type __max = true;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return __min; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return __max; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return min(); }

  static constexpr const bool is_integer = true;
  static constexpr const bool is_exact = true;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return type(0); }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_absent;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return type(0); }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true> {
protected:
  typedef float type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 24;
  static constexpr const int digits10 = 6;
  static constexpr const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return 1.17549435e-38F; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return 3.40282347e+38F; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return -max(); }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return 1.19209290e-7F; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return 0.5F; }

  static constexpr const int min_exponent = (-125);
  static constexpr const int min_exponent10 = (-37);
  static constexpr const int max_exponent = 128;
  static constexpr const int max_exponent10 = 38;

  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_present;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return __builtin_huge_valf(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return __builtin_nanf(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return __builtin_nansf(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return 1.40129846e-45F; }

  static constexpr const bool is_iec559 = true;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;

  static constexpr const bool tinyness_before = true;



  static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true> {
protected:
  typedef double type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 53;
  static constexpr const int digits10 = 15;
  static constexpr const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return 2.2250738585072014e-308; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return 1.7976931348623157e+308; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return -max(); }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return 2.2204460492503131e-16; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return 0.5; }

  static constexpr const int min_exponent = (-1021);
  static constexpr const int min_exponent10 = (-307);
  static constexpr const int max_exponent = 1024;
  static constexpr const int max_exponent10 = 308;

  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_present;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return __builtin_huge_val(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return __builtin_nan(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return __builtin_nans(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return 4.9406564584124654e-324; }

  static constexpr const bool is_iec559 = true;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;

  static constexpr const bool tinyness_before = true;



  static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true> {
protected:
  typedef long double type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 113;
  static constexpr const int digits10 = 33;
  static constexpr const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return 1.18973149535723176508575932662800702e+4932L; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return -max(); }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return 1.92592994438723585305597794258492732e-34L; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return 0.5L; }

  static constexpr const int min_exponent = (-16381);
  static constexpr const int min_exponent10 = (-4931);
  static constexpr const int max_exponent = 16384;
  static constexpr const int max_exponent10 = 4932;

  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = denorm_present;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return __builtin_huge_vall(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return __builtin_nanl(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return __builtin_nansl(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return 6.47517511943802511092443895822764655e-4966L; }




  static constexpr const bool is_iec559 = true;

  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;

  static constexpr const bool tinyness_before = true;



  static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class numeric_limits : private __libcpp_numeric_limits<_Tp> {
  typedef __libcpp_numeric_limits<_Tp> __base;
  typedef typename __base::type type;

public:
  static constexpr const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type min() noexcept { return __base::min(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type max() noexcept { return __base::max(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type lowest() noexcept { return __base::lowest(); }

  static constexpr const int digits = __base::digits;
  static constexpr const int digits10 = __base::digits10;
  static constexpr const int max_digits10 = __base::max_digits10;
  static constexpr const bool is_signed = __base::is_signed;
  static constexpr const bool is_integer = __base::is_integer;
  static constexpr const bool is_exact = __base::is_exact;
  static constexpr const int radix = __base::radix;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type epsilon() noexcept { return __base::epsilon(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type round_error() noexcept { return __base::round_error(); }

  static constexpr const int min_exponent = __base::min_exponent;
  static constexpr const int min_exponent10 = __base::min_exponent10;
  static constexpr const int max_exponent = __base::max_exponent;
  static constexpr const int max_exponent10 = __base::max_exponent10;

  static constexpr const bool has_infinity = __base::has_infinity;
  static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
  static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
#pragma GCC diagnostic push
# 466 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 466 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  static __attribute__((__deprecated__)) constexpr const float_denorm_style has_denorm = __base::has_denorm;
  static __attribute__((__deprecated__)) constexpr const bool has_denorm_loss = __base::has_denorm_loss;
#pragma GCC diagnostic pop
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type infinity() noexcept { return __base::infinity(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type quiet_NaN() noexcept { return __base::quiet_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type signaling_NaN() noexcept { return __base::signaling_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr type denorm_min() noexcept { return __base::denorm_min(); }

  static constexpr const bool is_iec559 = __base::is_iec559;
  static constexpr const bool is_bounded = __base::is_bounded;
  static constexpr const bool is_modulo = __base::is_modulo;

  static constexpr const bool traps = __base::traps;
  static constexpr const bool tinyness_before = __base::tinyness_before;
  static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class numeric_limits<const _Tp> : public numeric_limits<_Tp> {};

template <class _Tp>
class numeric_limits<volatile _Tp> : public numeric_limits<_Tp> {};

template <class _Tp>
class numeric_limits<const volatile _Tp> : public numeric_limits<_Tp> {};

}}
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 2 3
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/advance.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__advance(_InputIter& __i, typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag) {
  for (; __n > 0; --__n)
    ++__i;
}

template <class _BiDirIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__advance(_BiDirIter& __i, typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag) {
  if (__n >= 0)
    for (; __n > 0; --__n)
      ++__i;
  else
    for (; __n < 0; ++__n)
      --__i;
}

template <class _RandIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__advance(_RandIter& __i, typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag) {
  __i += __n;
}

template < class _InputIter,
           class _Distance,
           class _IntegralDistance = decltype(std::__convert_to_integral(std::declval<_Distance>())),
           __enable_if_t<is_integral<_IntegralDistance>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void advance(_InputIter& __i, _Distance __orig_n) {
  typedef typename iterator_traits<_InputIter>::difference_type _Difference;
  _Difference __n = static_cast<_Difference>(std::__convert_to_integral(__orig_n));

  ((void)0);

  std::__advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}





namespace ranges {
namespace __advance {

struct __fn {
private:
  template <class _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr void __advance_forward(_Ip& __i, iter_difference_t<_Ip> __n) {
    while (__n > 0) {
      --__n;
      ++__i;
    }
  }

  template <class _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr void __advance_backward(_Ip& __i, iter_difference_t<_Ip> __n) {
    while (__n < 0) {
      ++__n;
      --__i;
    }
  }

public:

  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_Ip& __i, iter_difference_t<_Ip> __n) const {

    ((void)0);



    if constexpr (random_access_iterator<_Ip>) {
      __i += __n;
      return;
    } else if constexpr (bidirectional_iterator<_Ip>) {

      __advance_forward(__i, __n);

      __advance_backward(__i, __n);
      return;
    } else {

      __advance_forward(__i, __n);
      return;
    }
  }



  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_Ip& __i, _Sp __bound_sentinel) const {

    if constexpr (assignable_from<_Ip&, _Sp>) {
      __i = std::move(__bound_sentinel);
    }


    else if constexpr (sized_sentinel_for<_Sp, _Ip>) {
      (*this)(__i, __bound_sentinel - __i);
    }

    else {
      while (__i != __bound_sentinel) {
        ++__i;
      }
    }
  }







  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iter_difference_t<_Ip>
  operator()(_Ip& __i, iter_difference_t<_Ip> __n, _Sp __bound_sentinel) const {

    ((void)0);


    if constexpr (sized_sentinel_for<_Sp, _Ip>) {


      auto __magnitude_geq = [](auto __a, auto __b) { return __a == 0 ? __b == 0 : __a > 0 ? __a >= __b : __a <= __b; };
      if (const auto __m = __bound_sentinel - __i; __magnitude_geq(__n, __m)) {
        (*this)(__i, __bound_sentinel);
        return __n - __m;
      }


      (*this)(__i, __n);
      return 0;
    } else {


      while (__i != __bound_sentinel && __n > 0) {
        ++__i;
        --__n;
      }


      if constexpr (bidirectional_iterator<_Ip> && same_as<_Ip, _Sp>) {
        while (__i != __bound_sentinel && __n < 0) {
          --__i;
          ++__n;
        }
      }
      return __n;
    }

    __libcpp_unreachable();
  }
};

}

inline namespace __cpo {
inline constexpr auto advance = __advance::__fn{};
}
}



}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_swap.h" 1 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_swap.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iter_swap.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





namespace ranges {
namespace __iter_swap {
template <class _I1, class _I2>
void iter_swap(_I1, _I2) = delete;

template <class _T1, class _T2>
concept __unqualified_iter_swap =
    (__class_or_enum<remove_cvref_t<_T1>> || __class_or_enum<remove_cvref_t<_T2>>)&&requires(_T1&& __x, _T2&& __y) {

      iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y));
    };

template <class _T1, class _T2>
concept __readable_swappable =
    indirectly_readable<_T1> && indirectly_readable<_T2> &&
    swappable_with<iter_reference_t<_T1>, iter_reference_t<_T2>>;

struct __fn {

  template <class _T1, class _T2>
    requires __unqualified_iter_swap<_T1, _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y)))) {
    (void)iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y));
  }


  template <class _T1, class _T2>
    requires(!__unqualified_iter_swap<_T1, _T2>) && __readable_swappable<_T1, _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(ranges::swap(*std::forward<_T1>(__x), *std::forward<_T2>(__y)))) {
    ranges::swap(*std::forward<_T1>(__x), *std::forward<_T2>(__y));
  }

  template <class _T1, class _T2>
    requires(!__unqualified_iter_swap<_T1, _T2> &&
             !__readable_swappable<_T1, _T2>) &&
            indirectly_movable_storable<_T1, _T2> &&
            indirectly_movable_storable<_T2, _T1>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(iter_value_t<_T2>(ranges::iter_move(__y))) &&
               noexcept(*__y = ranges::iter_move(__x)) &&
               noexcept(*std::forward<_T1>(__x) = std::declval<iter_value_t<_T2>>())) {
    iter_value_t<_T2> __old(ranges::iter_move(__y));
    *__y = ranges::iter_move(__x);
    *std::forward<_T1>(__x) = std::move(__old);
  }
};
}

inline namespace __cpo {
inline constexpr auto iter_swap = __iter_swap::__fn{};
}
}

template <class _I1, class _I2 = _I1>
concept indirectly_swappable =
    indirectly_readable<_I1> && indirectly_readable<_I2> && requires(const _I1 __i1, const _I2 __i2) {
      ranges::iter_swap(__i1, __i1);
      ranges::iter_swap(__i2, __i2);
      ranges::iter_swap(__i1, __i2);
      ranges::iter_swap(__i2, __i1);
    };



}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/next.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/next.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _InputIter
next(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {


  ((void)0);


  std::advance(__x, __n);
  return __x;
}





namespace ranges {
namespace __next {

struct __fn {
  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x) const {
    ++__x;
    return __x;
  }

  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n) const {
    ranges::advance(__x, __n);
    return __x;
  }

  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x, _Sp __bound_sentinel) const {
    ranges::advance(__x, __bound_sentinel);
    return __x;
  }

  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n, _Sp __bound_sentinel) const {
    ranges::advance(__x, __n, __bound_sentinel);
    return __x;
  }
};

}

inline namespace __cpo {
inline constexpr auto next = __next::__fn{};
}
}



}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/prev.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/prev.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _InputIter
prev(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {


  ((void)0);

  std::advance(__x, -__n);
  return __x;
}





namespace ranges {
namespace __prev {

struct __fn {
  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x) const {
    --__x;
    return __x;
  }

  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n) const {
    ranges::advance(__x, -__n);
    return __x;
  }

  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n, _Ip __bound_iter) const {
    ranges::advance(__x, -__n, __bound_iter);
    return __x;
  }
};

}

inline namespace __cpo {
inline constexpr auto prev = __prev::__fn{};
}
}



}}
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _AlgPolicy>
struct _IterOps;


struct _RangeAlgPolicy {};

template <>
struct _IterOps<_RangeAlgPolicy> {
  template <class _Iter>
  using __value_type = iter_value_t<_Iter>;

  template <class _Iter>
  using __iterator_category = ranges::__iterator_concept<_Iter>;

  template <class _Iter>
  using __difference_type = iter_difference_t<_Iter>;

  static constexpr auto advance = ranges::advance;
  static constexpr auto distance = ranges::distance;
  static constexpr auto __iter_move = ranges::iter_move;
  static constexpr auto iter_swap = ranges::iter_swap;
  static constexpr auto next = ranges::next;
  static constexpr auto prev = ranges::prev;
  static constexpr auto __advance_to = ranges::advance;
};



struct _ClassicAlgPolicy {};

template <>
struct _IterOps<_ClassicAlgPolicy> {
  template <class _Iter>
  using __value_type = typename iterator_traits<_Iter>::value_type;

  template <class _Iter>
  using __iterator_category = typename iterator_traits<_Iter>::iterator_category;

  template <class _Iter>
  using __difference_type = typename iterator_traits<_Iter>::difference_type;


  template <class _Iter, class _Distance>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void advance(_Iter& __iter, _Distance __count) {
    std::advance(__iter, __count);
  }


  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static typename iterator_traits<_Iter>::difference_type
  distance(_Iter __first, _Iter __last) {
    return std::distance(__first, __last);
  }

  template <class _Iter>
  using __deref_t = decltype(*std::declval<_Iter&>());

  template <class _Iter>
  using __move_t = decltype(std::move(*std::declval<_Iter&>()));

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void __validate_iter_reference() {
    static_assert(
        is_same<__deref_t<_Iter>, typename iterator_traits<__remove_cvref_t<_Iter> >::reference>::value,
        "It looks like your iterator's `iterator_traits<It>::reference` does not match the return type of "
        "dereferencing the iterator, i.e., calling `*it`. This is undefined behavior according to [input.iterators] "
        "and can lead to dangling reference issues at runtime, so we are flagging this.");
  }


  template <class _Iter, __enable_if_t<is_reference<__deref_t<_Iter> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static


      __move_t<_Iter>
      __iter_move(_Iter&& __i) {
    __validate_iter_reference<_Iter>();

    return std::move(*std::forward<_Iter>(__i));
  }

  template <class _Iter, __enable_if_t<!is_reference<__deref_t<_Iter> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static



      __deref_t<_Iter>
      __iter_move(_Iter&& __i) {
    __validate_iter_reference<_Iter>();

    return *std::forward<_Iter>(__i);
  }


  template <class _Iter1, class _Iter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void iter_swap(_Iter1&& __a, _Iter2&& __b) {
    std::iter_swap(std::forward<_Iter1>(__a), std::forward<_Iter2>(__b));
  }


  template <class _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr _Iterator next(_Iterator, _Iterator __last) {
    return __last;
  }

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr __remove_cvref_t<_Iter>
  next(_Iter&& __it, typename iterator_traits<__remove_cvref_t<_Iter> >::difference_type __n = 1) {
    return std::next(std::forward<_Iter>(__it), __n);
  }


  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr __remove_cvref_t<_Iter>
  prev(_Iter&& __iter, typename iterator_traits<__remove_cvref_t<_Iter> >::difference_type __n = 1) {
    return std::prev(std::forward<_Iter>(__iter), __n);
  }

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr void __advance_to(_Iter& __first, _Iter __last) {
    __first = __last;
  }
};

}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/synth_three_way.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/synth_three_way.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/synth_three_way.h" 3
template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto __synth_three_way(const _Tp& __t, const _Up& __u)
  requires requires {
    { __t < __u } -> __boolean_testable;
    { __u < __t } -> __boolean_testable;
  }
{
  if constexpr (three_way_comparable_with<_Tp, _Up>) {
    return __t <=> __u;
  } else {
    if (__t < __u)
      return weak_ordering::less;
    if (__u < __t)
      return weak_ordering::greater;
    return weak_ordering::equivalent;
  }
}

template <class _Tp, class _Up = _Tp>
using __synth_three_way_result = decltype(std::__synth_three_way(std::declval<_Tp&>(), std::declval<_Up&>()));



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/different_from.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/different_from.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp, class _Up>
concept __different_from = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/array.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/array.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, size_t _Size>
struct array;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& get(array<_Tp, _Size>&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp& get(const array<_Tp, _Size>&) noexcept;


template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp&& get(array<_Tp, _Size>&&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp&& get(const array<_Tp, _Size>&&) noexcept;


template <class>
struct __is_std_array : false_type {};

template <class _Tp, size_t _Size>
struct __is_std_array<array<_Tp, _Size> > : true_type {};

}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/subrange.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/subrange.h" 3




 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

namespace ranges {

enum class subrange_kind : bool { unsized, sized };

template <input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent, subrange_kind _Kind>
  requires(_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _Iter>)
class subrange;

template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires((_Index == 0 && copyable<_Iter>) || _Index == 1)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto get(const subrange<_Iter, _Sent, _Kind>&);

template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires(_Index < 2)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto get(subrange<_Iter, _Sent, _Kind>&&);

}

using ranges::get;

}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/pair_like.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/pair_like.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/complex.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/complex.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
class complex;
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/complex.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like.h" 2 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct __tuple_like_impl : false_type {};

template <class... _Tp>
struct __tuple_like_impl<tuple<_Tp...> > : true_type {};

template <class _T1, class _T2>
struct __tuple_like_impl<pair<_T1, _T2> > : true_type {};

template <class _Tp, size_t _Size>
struct __tuple_like_impl<array<_Tp, _Size> > : true_type {};

template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct __tuple_like_impl<ranges::subrange<_Ip, _Sp, _Kp> > : true_type {};
# 51 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like.h" 3
template <class _Tp>
concept __tuple_like = __tuple_like_impl<remove_cvref_t<_Tp>>::value;



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/pair_like.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_size.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_size.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_types.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_types.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class... _Tp>
struct __tuple_types {};

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_size.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_size.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct tuple_size;


template <class _Tp, class...>
using __enable_if_tuple_size_imp = _Tp;

template <class _Tp>
struct tuple_size<__enable_if_tuple_size_imp< const _Tp,
                                                                   __enable_if_t<!is_volatile<_Tp>::value>,
                                                                   integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct tuple_size<__enable_if_tuple_size_imp< volatile _Tp,
                                                                   __enable_if_t<!is_const<_Tp>::value>,
                                                                   integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct
    tuple_size<__enable_if_tuple_size_imp< const volatile _Tp, integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
# 60 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_size.h" 3
template <class... _Tp>
struct tuple_size<tuple<_Tp...> > : public integral_constant<size_t, sizeof...(_Tp)> {};

template <class... _Tp>
struct tuple_size<__tuple_types<_Tp...> > : public integral_constant<size_t, sizeof...(_Tp)> {};



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/pair_like.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/pair_like.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
concept __pair_like = __tuple_like<_Tp> && tuple_size<remove_cvref_t<_Tp>>::value == 2;



}}
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/sfinae_helpers.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/sfinae_helpers.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/make_tuple_types.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/make_tuple_types.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_element.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_element.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_indices.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_indices.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/integer_sequence.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/integer_sequence.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <size_t...>
struct __tuple_indices;

template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};


template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template __to_tuple_indices<_Sp>;
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/integer_sequence.h" 3
template <class _Tp, _Tp... _Ip>
struct integer_sequence {
  typedef _Tp value_type;
  static_assert(is_integral<_Tp>::value, "std::integer_sequence can only be instantiated with an integral type");
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t size() noexcept { return sizeof...(_Ip); }
};

template <size_t... _Ip>
using index_sequence = integer_sequence<size_t, _Ip...>;



template <class _Tp, _Tp _Ep>
using make_integer_sequence __attribute__((__nodebug__)) = __make_integer_seq<integer_sequence, _Tp, _Ep>;
# 72 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/integer_sequence.h" 3
template <size_t _Np>
using make_index_sequence = make_integer_sequence<size_t, _Np>;

template <class... _Tp>
using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;



template <size_t... _Index, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __for_each_index_sequence(index_sequence<_Index...>, _Function __func) {
  (__func.template operator()<_Index>(), ...);
}




}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_indices.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_indices.h" 3




 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <size_t...>
struct __tuple_indices {};

template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices {
  static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
  typedef __make_indices_imp<_Ep, _Sp> type;
};

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_element.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_element.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <size_t _Ip, class _Tp>
struct tuple_element;

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, const _Tp> {
  typedef __attribute__((__nodebug__)) typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, volatile _Tp> {
  typedef __attribute__((__nodebug__)) typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, const volatile _Tp> {
  typedef __attribute__((__nodebug__)) typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};
# 72 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_element.h" 3
template <size_t _Ip, class... _Types>
struct tuple_element<_Ip, __tuple_types<_Types...> > {
  static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
  typedef __attribute__((__nodebug__)) __type_pack_element<_Ip, _Types...> type;
};


template <size_t _Ip, class... _Tp>
using tuple_element_t __attribute__((__nodebug__)) = typename tuple_element<_Ip, _Tp...>::type;




}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/make_tuple_types.h" 2 3
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/make_tuple_types.h" 3




 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {






template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;

template <template <class...> class _Tuple, class... _Types, size_t... _Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {

  template <class _Tp>
  using __apply_quals __attribute__((__nodebug__)) = __tuple_types<__apply_cv_t<_Tp, __type_pack_element<_Idx, _Types...>>...>;
};

template <class _Vt, size_t _Np, size_t... _Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t>
  using __value_type = _Vt;
  template <class _Tp>
  using __apply_quals = __tuple_types<__apply_cv_t<_Tp, __value_type<_Idx>>...>;
};

template <class _Tp,
          size_t _Ep = tuple_size<__libcpp_remove_reference_t<_Tp> >::value,
          size_t _Sp = 0,
          bool _SameSize = (_Ep == tuple_size<__libcpp_remove_reference_t<_Tp> >::value)>
struct __make_tuple_types {
  static_assert(_Sp <= _Ep, "__make_tuple_types input error");
  using _RawTp = __remove_cv_t<__libcpp_remove_reference_t<_Tp> >;
  using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
  using type = typename _Maker::template __apply_quals<_Tp>;
};

template <class... _Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __attribute__((__nodebug__)) __tuple_types<_Types...> type;
};

template <class... _Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __attribute__((__nodebug__)) __tuple_types<_Types...> type;
};

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/sfinae_helpers.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like_ext.h" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/tuple_like_ext.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __tuple_like_ext : false_type {};

template <class _Tp>
struct __tuple_like_ext<const _Tp> : public __tuple_like_ext<_Tp> {};
template <class _Tp>
struct __tuple_like_ext<volatile _Tp> : public __tuple_like_ext<_Tp> {};
template <class _Tp>
struct __tuple_like_ext<const volatile _Tp> : public __tuple_like_ext<_Tp> {};


template <class... _Tp>
struct __tuple_like_ext<tuple<_Tp...> > : true_type {};


template <class _T1, class _T2>
struct __tuple_like_ext<pair<_T1, _T2> > : true_type {};

template <class _Tp, size_t _Size>
struct __tuple_like_ext<array<_Tp, _Size> > : true_type {};

template <class... _Tp>
struct __tuple_like_ext<__tuple_types<_Tp...> > : true_type {};

}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/sfinae_helpers.h" 2 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/sfinae_helpers.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <bool... _Preds>
struct __all_dummy;

template <bool... _Pred>
struct __all : _IsSame<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>> {};

struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait, class... _LArgs, class... _RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
      -> __all<__enable_if_t<_Trait<_LArgs, _RArgs>::value, bool>{true}...>;
  template <template <class...> class>
  static auto __do_test(...) -> false_type;

  template <class _FromArgs, class _ToArgs>
  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
};



template <class _Tp,
          class _Up,
          bool = __tuple_like_ext<__libcpp_remove_reference_t<_Tp> >::value,
          bool = __tuple_like_ext<_Up>::value>
struct __tuple_constructible : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible< typename __make_tuple_types<_Tp>::type,
                                                   typename __make_tuple_types<_Up>::type > {};

template <size_t _Ip, class... _Tp>
struct tuple_element<_Ip, tuple<_Tp...> > {
  typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};

struct __attribute__((__visibility__("default"))) __check_tuple_constructor_fail {
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_explicit_default() { return false; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_implicit_default() { return false; }
  template <class...>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_explicit() {
    return false;
  }
  template <class...>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_implicit() {
    return false;
  }
  template <class...>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_assign() {
    return false;
  }
};




template <bool _CanCopy, bool _CanMove>
struct __sfinae_ctor_base {};
template <>
struct __sfinae_ctor_base<false, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base&&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<true, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base(__sfinae_ctor_base&&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<false, true> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base&&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};

template <bool _CanCopy, bool _CanMove>
struct __sfinae_assign_base {};
template <>
struct __sfinae_assign_base<false, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base&&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<true, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base&&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<false, true> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base&&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = default;
};


}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_copy_assignable.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_copy_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_copy_assignable
    : public integral_constant<
          bool,
          __is_assignable(__add_lvalue_reference_t<_Tp>, __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};


template <class _Tp>
inline constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;


}}
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_default_constructible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_default_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_default_constructible : public integral_constant<bool, __is_constructible(_Tp)> {};


template <class _Tp>
inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);


}}
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_implicitly_default_constructible.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_implicitly_default_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {






template <class _Tp>
void __test_implicit_default_constructible(_Tp);

template <class _Tp, class = void, class = typename is_default_constructible<_Tp>::type>
struct __is_implicitly_default_constructible : false_type {};

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp,
                                             decltype(std::__test_implicit_default_constructible<_Tp const&>({})),
                                             true_type> : true_type {};

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp,
                                             decltype(std::__test_implicit_default_constructible<_Tp const&>({})),
                                             false_type> : false_type {};


}}
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_copy_assignable.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_copy_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_nothrow_copy_assignable
    : public integral_constant<bool,
                               __is_nothrow_assignable(__add_lvalue_reference_t<_Tp>,
                                                       __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};


template <class _Tp>
inline constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Tp>::value;


}}
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 3
template <class _Tp>
struct is_nothrow_copy_constructible
    : public integral_constant<
          bool,
          __is_nothrow_constructible(_Tp, typename add_lvalue_reference<typename add_const<_Tp>::type>::type)> {};




template <class _Tp>
inline constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Tp>::value;


}}
# 41 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_default_constructible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_default_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_nothrow_default_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp)> {};


template <class _Tp>
inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Tp);


}}
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3





# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/unwrap_ref.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/unwrap_ref.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __unwrap_reference {
  typedef __attribute__((__nodebug__)) _Tp type;
};

template <class _Tp>
struct __unwrap_reference<reference_wrapper<_Tp> > {
  typedef __attribute__((__nodebug__)) _Tp& type;
};


template <class _Tp>
struct unwrap_reference : __unwrap_reference<_Tp> {};

template <class _Tp>
using unwrap_reference_t = typename unwrap_reference<_Tp>::type;

template <class _Tp>
struct unwrap_ref_decay : unwrap_reference<__decay_t<_Tp> > {};

template <class _Tp>
using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;


template <class _Tp>
struct __unwrap_ref_decay

    : unwrap_ref_decay<_Tp>



{
};

}}
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/piecewise_construct.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/piecewise_construct.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

struct piecewise_construct_t {
  explicit piecewise_construct_t() = default;
};


inline constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();




}}
# 52 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3
# 56 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 60 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class, class>
struct __non_trivially_copyable_base {
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __non_trivially_copyable_base() noexcept {}
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
  __non_trivially_copyable_base(__non_trivially_copyable_base const&) noexcept {}
};


template <class _Tp>
struct __is_specialization_of_subrange : false_type {};

template <class _Iter, class _Sent, ranges::subrange_kind _Kind>
struct __is_specialization_of_subrange<ranges::subrange<_Iter, _Sent, _Kind>> : true_type {};


template <class _T1, class _T2>
struct pair



{
  using first_type = _T1;
  using second_type = _T2;

  _T1 first;
  _T2 second;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) pair(pair const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) pair(pair&&) = default;
# 121 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3
  struct _CheckArgs {
    template <int&...>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_implicit_default() {
      return __is_implicitly_default_constructible<_T1>::value && __is_implicitly_default_constructible<_T2>::value;
    }

    template <int&...>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __enable_default() {
      return is_default_constructible<_T1>::value && is_default_constructible<_T2>::value;
    }

    template <class _U1, class _U2>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __is_pair_constructible() {
      return is_constructible<first_type, _U1>::value && is_constructible<second_type, _U2>::value;
    }

    template <class _U1, class _U2>
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __is_implicit() {
      return is_convertible<_U1, first_type>::value && is_convertible<_U2, second_type>::value;
    }
  };

  template <bool _MaybeEnable>
  using _CheckArgsDep __attribute__((__nodebug__)) =
      typename conditional< _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;

  template <bool _Dummy = true, __enable_if_t<_CheckArgsDep<_Dummy>::__enable_default(), int> = 0>
  explicit(!_CheckArgsDep<_Dummy>::__enable_implicit_default()) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair()
      noexcept(is_nothrow_default_constructible<first_type>::value&& is_nothrow_default_constructible<second_type>::value)

      : first(), second() {}

  template <bool _Dummy = true,
            __enable_if_t<_CheckArgsDep<_Dummy>::template __is_pair_constructible<_T1 const&, _T2 const&>(), int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      !_CheckArgsDep<_Dummy>::template __is_implicit<_T1 const&, _T2 const&>()) pair(_T1 const& __t1, _T2 const& __t2)
      noexcept(is_nothrow_copy_constructible<first_type>::value&& is_nothrow_copy_constructible<second_type>::value)
      : first(__t1), second(__t2) {}

  template <

      class _U1 = _T1,
      class _U2 = _T2,




      __enable_if_t<_CheckArgs::template __is_pair_constructible<_U1, _U2>(), int> = 0 >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_CheckArgs::template __is_implicit<_U1, _U2>())
      pair(_U1&& __u1, _U2&& __u2)
          noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

      : first(std::forward<_U1>(__u1)), second(std::forward<_U2>(__u2)) {
  }


  template <class _U1, class _U2, __enable_if_t<_CheckArgs::template __is_pair_constructible<_U1&, _U2&>(), int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_CheckArgs::template __is_implicit<_U1&, _U2&>())
      pair(pair<_U1, _U2>& __p) noexcept((is_nothrow_constructible<first_type, _U1&>::value &&
                                          is_nothrow_constructible<second_type, _U2&>::value))
      : first(__p.first), second(__p.second) {}


  template <class _U1,
            class _U2,
            __enable_if_t<_CheckArgs::template __is_pair_constructible<_U1 const&, _U2 const&>(), int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      !_CheckArgs::template __is_implicit<_U1 const&, _U2 const&>()) pair(pair<_U1, _U2> const& __p)
      noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

      : first(__p.first), second(__p.second) {}

  template <class _U1, class _U2, __enable_if_t<_CheckArgs::template __is_pair_constructible<_U1, _U2>(), int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_CheckArgs::template __is_implicit<_U1, _U2>())
      pair(pair<_U1, _U2>&& __p)
          noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

      : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second)) {}


  template <class _U1,
            class _U2,
            __enable_if_t<_CheckArgs::template __is_pair_constructible<const _U1&&, const _U2&&>(), int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_CheckArgs::template __is_implicit<const _U1&&, const _U2&&>())
      pair(const pair<_U1, _U2>&& __p) noexcept(is_nothrow_constructible<first_type, const _U1&&>::value &&
                                                is_nothrow_constructible<second_type, const _U2&&>::value)
      : first(std::move(__p.first)), second(std::move(__p.second)) {}




  template <class _PairLike>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr bool __pair_like_explicit_wknd() {
    if constexpr (__pair_like<_PairLike>) {
      return !is_convertible_v<decltype(std::get<0>(std::declval<_PairLike&&>())), first_type> ||
             !is_convertible_v<decltype(std::get<1>(std::declval<_PairLike&&>())), second_type>;
    }
    return false;
  }

  template <__pair_like _PairLike>
    requires(!__is_specialization_of_subrange<remove_cvref_t<_PairLike>>::value &&
             is_constructible_v<first_type, decltype(std::get<0>(std::declval<_PairLike &&>()))> &&
             is_constructible_v<second_type, decltype(std::get<1>(std::declval<_PairLike &&>()))>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(__pair_like_explicit_wknd<_PairLike>()) pair(_PairLike&& __p)
      : first(std::get<0>(std::forward<_PairLike>(__p))), second(std::get<1>(std::forward<_PairLike>(__p))) {}


  template <class... _Args1, class... _Args2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args) noexcept(is_nothrow_constructible<first_type, _Args1...>::value&& is_nothrow_constructible<second_type, _Args2...>::value)

      : pair(__pc,
             __first_args,
             __second_args,
             typename __make_tuple_indices<sizeof...(_Args1)>::type(),
             typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair&
  operator=(__conditional_t< is_copy_assignable<first_type>::value && is_copy_assignable<second_type>::value,
                             pair,
                             __nat> const& __p)
      noexcept(is_nothrow_copy_assignable<first_type>::value&& is_nothrow_copy_assignable<second_type>::value) {
    first = __p.first;
    second = __p.second;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair& operator=(
      __conditional_t< is_move_assignable<first_type>::value && is_move_assignable<second_type>::value, pair, __nat>&&
          __p)
      noexcept(is_nothrow_move_assignable<first_type>::value&& is_nothrow_move_assignable<second_type>::value) {
    first = std::forward<first_type>(__p.first);
    second = std::forward<second_type>(__p.second);
    return *this;
  }

  template <
      class _U1,
      class _U2,
      __enable_if_t<is_assignable<first_type&, _U1 const&>::value && is_assignable<second_type&, _U2 const&>::value,
                    int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair& operator=(pair<_U1, _U2> const& __p) {
    first = __p.first;
    second = __p.second;
    return *this;
  }

  template <class _U1,
            class _U2,
            __enable_if_t<is_assignable<first_type&, _U1>::value && is_assignable<second_type&, _U2>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair& operator=(pair<_U1, _U2>&& __p) {
    first = std::forward<_U1>(__p.first);
    second = std::forward<_U2>(__p.second);
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const pair& operator=(pair const& __p) const
      noexcept(is_nothrow_copy_assignable_v<const first_type> && is_nothrow_copy_assignable_v<const second_type>)
    requires(is_copy_assignable_v<const first_type> && is_copy_assignable_v<const second_type>)
  {
    first = __p.first;
    second = __p.second;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const pair& operator=(pair&& __p) const
      noexcept(is_nothrow_assignable_v<const first_type&, first_type> &&
               is_nothrow_assignable_v<const second_type&, second_type>)
    requires(is_assignable_v<const first_type&, first_type> && is_assignable_v<const second_type&, second_type>)
  {
    first = std::forward<first_type>(__p.first);
    second = std::forward<second_type>(__p.second);
    return *this;
  }

  template <class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const pair& operator=(const pair<_U1, _U2>& __p) const
    requires(is_assignable_v<const first_type&, const _U1&> && is_assignable_v<const second_type&, const _U2&>)
  {
    first = __p.first;
    second = __p.second;
    return *this;
  }

  template <class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const pair& operator=(pair<_U1, _U2>&& __p) const
    requires(is_assignable_v<const first_type&, _U1> && is_assignable_v<const second_type&, _U2>)
  {
    first = std::forward<_U1>(__p.first);
    second = std::forward<_U2>(__p.second);
    return *this;
  }

  template <__pair_like _PairLike>
    requires(__different_from<_PairLike, pair> && !__is_specialization_of_subrange<remove_cvref_t<_PairLike>>::value &&
             is_assignable_v<first_type&, decltype(std::get<0>(std::declval<_PairLike>()))> &&
             is_assignable_v<second_type&, decltype(std::get<1>(std::declval<_PairLike>()))>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair& operator=(_PairLike&& __p) {
    first = std::get<0>(std::forward<_PairLike>(__p));
    second = std::get<1>(std::forward<_PairLike>(__p));
    return *this;
  }

  template <__pair_like _PairLike>
    requires(__different_from<_PairLike, pair> && !__is_specialization_of_subrange<remove_cvref_t<_PairLike>>::value &&
             is_assignable_v<first_type const&, decltype(std::get<0>(std::declval<_PairLike>()))> &&
             is_assignable_v<second_type const&, decltype(std::get<1>(std::declval<_PairLike>()))>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair const& operator=(_PairLike&& __p) const {
    first = std::get<0>(std::forward<_PairLike>(__p));
    second = std::get<1>(std::forward<_PairLike>(__p));
    return *this;
  }
# 426 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(pair& __p)
      noexcept(__is_nothrow_swappable<first_type>::value&& __is_nothrow_swappable<second_type>::value) {
    using std::swap;
    swap(first, __p.first);
    swap(second, __p.second);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(const pair& __p) const
      noexcept(__is_nothrow_swappable<const first_type>::value && __is_nothrow_swappable<const second_type>::value) {
    using std::swap;
    swap(first, __p.first);
    swap(second, __p.second);
  }


private:

  template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  pair(piecewise_construct_t,
       tuple<_Args1...>& __first_args,
       tuple<_Args2...>& __second_args,
       __tuple_indices<_I1...>,
       __tuple_indices<_I2...>);

};


template <class _T1, class _T2>
pair(_T1, _T2) -> pair<_T1, _T2>;




template <class _T1, class _T2, class _U1, class _U2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y) {
  return __x.first == __y.first && __x.second == __y.second;
}



template <class _T1, class _T2, class _U1, class _U2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr common_comparison_category_t< __synth_three_way_result<_T1, _U1>,
                                                              __synth_three_way_result<_T2, _U2> >
operator<=>(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y) {
  if (auto __c = std::__synth_three_way(__x.first, __y.first); __c != 0) {
    return __c;
  }
  return std::__synth_three_way(__x.second, __y.second);
}
# 514 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/pair.h" 3
template <class _T1, class _T2, class _U1, class _U2, template <class> class _TQual, template <class> class _UQual>
  requires requires {
    typename pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>, common_reference_t<_TQual<_T2>, _UQual<_U2>>>;
  }
struct basic_common_reference<pair<_T1, _T2>, pair<_U1, _U2>, _TQual, _UQual> {
  using type = pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>, common_reference_t<_TQual<_T2>, _UQual<_U2>>>;
};

template <class _T1, class _T2, class _U1, class _U2>
  requires requires { typename pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>; }
struct common_type<pair<_T1, _T2>, pair<_U1, _U2>> {
  using type = pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>;
};


template <class _T1, class _T2, __enable_if_t<__is_swappable<_T1>::value && __is_swappable<_T2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value&& __is_nothrow_swappable<_T2>::value) {
  __x.swap(__y);
}


template <class _T1, class _T2>
  requires(__is_swappable<const _T1>::value && __is_swappable<const _T2>::value)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
swap(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}


template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
    pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
    make_pair(_T1&& __t1, _T2&& __t2) {
  return pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>(
      std::forward<_T1>(__t1), std::forward<_T2>(__t2));
}

template <class _T1, class _T2>
struct tuple_size<pair<_T1, _T2> > : public integral_constant<size_t, 2> {};

template <size_t _Ip, class _T1, class _T2>
struct tuple_element<_Ip, pair<_T1, _T2> > {
  static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};

template <class _T1, class _T2>
struct tuple_element<0, pair<_T1, _T2> > {
  using type __attribute__((__nodebug__)) = _T1;
};

template <class _T1, class _T2>
struct tuple_element<1, pair<_T1, _T2> > {
  using type __attribute__((__nodebug__)) = _T2;
};

template <size_t _Ip>
struct __get_pair;

template <>
struct __get_pair<0> {
  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1& get(pair<_T1, _T2>& __p) noexcept {
    return __p.first;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _T1& get(const pair<_T1, _T2>& __p) noexcept {
    return __p.first;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1&& get(pair<_T1, _T2>&& __p) noexcept {
    return std::forward<_T1>(__p.first);
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _T1&& get(const pair<_T1, _T2>&& __p) noexcept {
    return std::forward<const _T1>(__p.first);
  }
};

template <>
struct __get_pair<1> {
  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T2& get(pair<_T1, _T2>& __p) noexcept {
    return __p.second;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _T2& get(const pair<_T1, _T2>& __p) noexcept {
    return __p.second;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T2&& get(pair<_T1, _T2>&& __p) noexcept {
    return std::forward<_T2>(__p.second);
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _T2&& get(const pair<_T1, _T2>&& __p) noexcept {
    return std::forward<const _T2>(__p.second);
  }
};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) noexcept {
  return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) noexcept {
  return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) noexcept {
  return __get_pair<_Ip>::get(std::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) noexcept {
  return __get_pair<_Ip>::get(std::move(__p));
}


template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1& get(pair<_T1, _T2>& __p) noexcept {
  return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 const& get(pair<_T1, _T2> const& __p) noexcept {
  return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1&& get(pair<_T1, _T2>&& __p) noexcept {
  return __get_pair<0>::get(std::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 const&& get(pair<_T1, _T2> const&& __p) noexcept {
  return __get_pair<0>::get(std::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1& get(pair<_T2, _T1>& __p) noexcept {
  return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 const& get(pair<_T2, _T1> const& __p) noexcept {
  return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1&& get(pair<_T2, _T1>&& __p) noexcept {
  return __get_pair<1>::get(std::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 const&& get(pair<_T2, _T1> const&& __p) noexcept {
  return __get_pair<1>::get(std::move(__p));
}



}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/swap_ranges.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2, class _Sentinel2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2, _Sentinel2 __last2) {
  while (__first1 != __last1 && __first2 != __last2) {
    _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
    ++__first1;
    ++__first2;
  }

  return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}


template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2) {
  while (__first1 != __last1) {
    _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
    ++__first1;
    ++__first2;
  }

  return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  return std::__swap_ranges<_ClassicAlgPolicy>(std::move(__first1), std::move(__last1), std::move(__first2)).second;
}

}}
# 119 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way_result.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_three_way_result.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class, class, class>
struct __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __compare_three_way_result {};

template <class _Tp, class _Up>
struct __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __compare_three_way_result<
    _Tp,
    _Up,
    decltype(std::declval<__make_const_lvalue_ref<_Tp>>() <=> std::declval<__make_const_lvalue_ref<_Up>>(), void())> {
  using type = decltype(std::declval<__make_const_lvalue_ref<_Tp>>() <=> std::declval<__make_const_lvalue_ref<_Up>>());
};

template <class _Tp, class _Up = _Tp>
struct compare_three_way_result : __compare_three_way_result<_Tp, _Up, void> {};

template <class _Tp, class _Up = _Tp>
using compare_three_way_result_t = typename compare_three_way_result<_Tp, _Up>::type;



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/iterator.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Category, class _Tp, class _Distance = ptrdiff_t, class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__((__deprecated__)) iterator {
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
  typedef _Category iterator_category;
};

}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3




# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/segmented_iterator.h" 1 3
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/segmented_iterator.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Iterator>
struct __segmented_iterator_traits;
# 68 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/segmented_iterator.h" 3
template <class _Tp, size_t = 0>
struct __has_specialization : false_type {};

template <class _Tp>
struct __has_specialization<_Tp, sizeof(_Tp) * 0> : true_type {};

template <class _Iterator>
using __is_segmented_iterator = __has_specialization<__segmented_iterator_traits<_Iterator> >;

}}
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 1 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/dangling.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/dangling.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {
struct dangling {
  dangling() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr dangling(auto&&...) noexcept {}
};

template <range _Rp>
using borrowed_iterator_t = _If<borrowed_range<_Rp>, iterator_t<_Rp>, dangling>;


}



}}
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/view_interface.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/view_interface.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/empty.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/empty.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





namespace ranges {
namespace __empty {
template <class _Tp>
concept __member_empty = __workaround_52970<_Tp> && requires(_Tp&& __t) { bool(__t.empty()); };

template <class _Tp>
concept __can_invoke_size = !__member_empty<_Tp> && requires(_Tp&& __t) { ranges::size(__t); };

template <class _Tp>
concept __can_compare_begin_end = !__member_empty<_Tp> && !__can_invoke_size<_Tp> && requires(_Tp&& __t) {
  bool(ranges::begin(__t) == ranges::end(__t));
  { ranges::begin(__t) } -> forward_iterator;
};

struct __fn {
  template <__member_empty _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(_Tp&& __t) const noexcept(noexcept(bool(__t.empty()))) {
    return bool(__t.empty());
  }

  template <__can_invoke_size _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(_Tp&& __t) const noexcept(noexcept(ranges::size(__t))) {
    return ranges::size(__t) == 0;
  }

  template <__can_compare_begin_end _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(_Tp&& __t) const
      noexcept(noexcept(bool(ranges::begin(__t) == ranges::end(__t)))) {
    return ranges::begin(__t) == ranges::end(__t);
  }
};
}

inline namespace __cpo {
inline constexpr auto empty = __empty::__fn{};
}
}



}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/view_interface.h" 2 3
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/view_interface.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {

template <class _Derived>
  requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
class view_interface {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Derived& __derived() noexcept {
    static_assert(sizeof(_Derived) && derived_from<_Derived, view_interface> && view<_Derived>);
    return static_cast<_Derived&>(*this);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Derived const& __derived() const noexcept {
    static_assert(sizeof(_Derived) && derived_from<_Derived, view_interface> && view<_Derived>);
    return static_cast<_Derived const&>(*this);
  }

public:
  template <class _D2 = _Derived>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty()
    requires forward_range<_D2>
  {
    return ranges::begin(__derived()) == ranges::end(__derived());
  }

  template <class _D2 = _Derived>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty() const
    requires forward_range<const _D2>
  {
    return ranges::begin(__derived()) == ranges::end(__derived());
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit operator bool()
    requires requires(_D2& __t) { ranges::empty(__t); }
  {
    return !ranges::empty(__derived());
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit operator bool() const
    requires requires(const _D2& __t) { ranges::empty(__t); }
  {
    return !ranges::empty(__derived());
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto data()
    requires contiguous_iterator<iterator_t<_D2>>
  {
    return std::to_address(ranges::begin(__derived()));
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto data() const
    requires range<const _D2> && contiguous_iterator<iterator_t<const _D2>>
  {
    return std::to_address(ranges::begin(__derived()));
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto size()
    requires forward_range<_D2> && sized_sentinel_for<sentinel_t<_D2>, iterator_t<_D2>>
  {
    return std::__to_unsigned_like(ranges::end(__derived()) - ranges::begin(__derived()));
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto size() const
    requires forward_range<const _D2> && sized_sentinel_for<sentinel_t<const _D2>, iterator_t<const _D2>>
  {
    return std::__to_unsigned_like(ranges::end(__derived()) - ranges::begin(__derived()));
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) front()
    requires forward_range<_D2>
  {
    ((void)0);

    return *ranges::begin(__derived());
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) front() const
    requires forward_range<const _D2>
  {
    ((void)0);

    return *ranges::begin(__derived());
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) back()
    requires bidirectional_range<_D2> && common_range<_D2>
  {
    ((void)0);

    return *ranges::prev(ranges::end(__derived()));
  }

  template <class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) back() const
    requires bidirectional_range<const _D2> && common_range<const _D2>
  {
    ((void)0);

    return *ranges::prev(ranges::end(__derived()));
  }

  template <random_access_range _RARange = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) operator[](range_difference_t<_RARange> __index) {
    return ranges::begin(__derived())[__index];
  }

  template <random_access_range _RARange = const _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) operator[](range_difference_t<_RARange> __index) const {
    return ranges::begin(__derived())[__index];
  }
};

}



}}
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 2 3
# 46 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 50 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/subrange.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace ranges {
template <class _From, class _To>
concept __uses_nonqualification_pointer_conversion =
    is_pointer_v<_From> && is_pointer_v<_To> &&
    !convertible_to<remove_pointer_t<_From> (*)[], remove_pointer_t<_To> (*)[]>;

template <class _From, class _To>
concept __convertible_to_non_slicing =
    convertible_to<_From, _To> && !__uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>;

template <class _Pair, class _Iter, class _Sent>
concept __pair_like_convertible_from =
    !range<_Pair> && __pair_like<_Pair> && constructible_from<_Pair, _Iter, _Sent> &&
    __convertible_to_non_slicing<_Iter, tuple_element_t<0, _Pair>> && convertible_to<_Sent, tuple_element_t<1, _Pair>>;

template <input_or_output_iterator _Iter,
          sentinel_for<_Iter> _Sent = _Iter,
          subrange_kind _Kind = sized_sentinel_for<_Sent, _Iter> ? subrange_kind::sized : subrange_kind::unsized>
  requires(_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _Iter>)
class subrange : public view_interface<subrange<_Iter, _Sent, _Kind>> {
public:

  static constexpr bool _StoreSize = (_Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _Iter>);

private:
  static constexpr bool _MustProvideSizeAtConstruction = !_StoreSize;
  struct _Empty {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Empty(auto) noexcept {}
  };
  using _Size = conditional_t<_StoreSize, make_unsigned_t<iter_difference_t<_Iter>>, _Empty>;
  [[__no_unique_address__]] _Iter __begin_ = _Iter();
  [[__no_unique_address__]] _Sent __end_ = _Sent();
  [[__no_unique_address__]] _Size __size_ = 0;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) subrange()
    requires default_initializable<_Iter>
  = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange(__convertible_to_non_slicing<_Iter> auto __iter, _Sent __sent)
    requires _MustProvideSizeAtConstruction
      : __begin_(std::move(__iter)), __end_(std::move(__sent)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange(
      __convertible_to_non_slicing<_Iter> auto __iter, _Sent __sent, make_unsigned_t<iter_difference_t<_Iter>> __n)
    requires(_Kind == subrange_kind::sized)
      : __begin_(std::move(__iter)), __end_(std::move(__sent)), __size_(__n) {
    if constexpr (sized_sentinel_for<_Sent, _Iter>)
      ((void)0);

  }

  template <__different_from<subrange> _Range>
    requires borrowed_range<_Range> && __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
             convertible_to<sentinel_t<_Range>, _Sent>
             __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange(_Range&& __range)
               requires(!_StoreSize)
      : subrange(ranges::begin(__range), ranges::end(__range)) {}

  template <__different_from<subrange> _Range>
    requires borrowed_range<_Range> && __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
             convertible_to<sentinel_t<_Range>, _Sent>
             __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange(_Range&& __range)
               requires _StoreSize && sized_range<_Range>
      : subrange(__range, ranges::size(__range)) {}

  template <borrowed_range _Range>
    requires __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
             convertible_to<sentinel_t<_Range>, _Sent>
             __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange(_Range&& __range, make_unsigned_t<iter_difference_t<_Iter>> __n)
               requires(_Kind == subrange_kind::sized)
      : subrange(ranges::begin(__range), ranges::end(__range), __n) {}

  template <__different_from<subrange> _Pair>
    requires __pair_like_convertible_from<_Pair, const _Iter&, const _Sent&>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator _Pair() const {
    return _Pair(__begin_, __end_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter begin() const
    requires copyable<_Iter>
  {
    return __begin_;
  }

  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter begin()
    requires(!copyable<_Iter>)
  {
    return std::move(__begin_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Sent end() const { return __end_; }

  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty() const { return __begin_ == __end_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr make_unsigned_t<iter_difference_t<_Iter>> size() const
    requires(_Kind == subrange_kind::sized)
  {
    if constexpr (_StoreSize)
      return __size_;
    else
      return std::__to_unsigned_like(__end_ - __begin_);
  }

  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange next(iter_difference_t<_Iter> __n = 1) const&
    requires forward_iterator<_Iter>
  {
    auto __tmp = *this;
    __tmp.advance(__n);
    return __tmp;
  }

  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange next(iter_difference_t<_Iter> __n = 1) && {
    advance(__n);
    return std::move(*this);
  }

  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange prev(iter_difference_t<_Iter> __n = 1) const
    requires bidirectional_iterator<_Iter>
  {
    auto __tmp = *this;
    __tmp.advance(-__n);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr subrange& advance(iter_difference_t<_Iter> __n) {
    if constexpr (bidirectional_iterator<_Iter>) {
      if (__n < 0) {
        ranges::advance(__begin_, __n);
        if constexpr (_StoreSize)
          __size_ += std::__to_unsigned_like(-__n);
        return *this;
      }
    }

    auto __d = __n - ranges::advance(__begin_, __n, __end_);
    if constexpr (_StoreSize)
      __size_ -= std::__to_unsigned_like(__d);
    return *this;
  }
};

template <input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent>
subrange(_Iter, _Sent) -> subrange<_Iter, _Sent>;

template <input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent>
subrange(_Iter, _Sent, make_unsigned_t<iter_difference_t<_Iter>>) -> subrange<_Iter, _Sent, subrange_kind::sized>;

template <borrowed_range _Range>
subrange(_Range&&)
    -> subrange<iterator_t<_Range>,
                sentinel_t<_Range>,
                (sized_range<_Range> || sized_sentinel_for<sentinel_t<_Range>, iterator_t<_Range>>)
                    ? subrange_kind::sized
                    : subrange_kind::unsized>;

template <borrowed_range _Range>
subrange(_Range&&, make_unsigned_t<range_difference_t<_Range>>)
    -> subrange<iterator_t<_Range>, sentinel_t<_Range>, subrange_kind::sized>;

template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires((_Index == 0 && copyable<_Iter>) || _Index == 1)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto get(const subrange<_Iter, _Sent, _Kind>& __subrange) {
  if constexpr (_Index == 0)
    return __subrange.begin();
  else
    return __subrange.end();
}

template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires(_Index < 2)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto get(subrange<_Iter, _Sent, _Kind>&& __subrange) {
  if constexpr (_Index == 0)
    return __subrange.begin();
  else
    return __subrange.end();
}

template <class _Ip, class _Sp, subrange_kind _Kp>
inline constexpr bool enable_borrowed_range<subrange<_Ip, _Sp, _Kp>> = true;

template <range _Rp>
using borrowed_subrange_t = _If<borrowed_range<_Rp>, subrange<iterator_t<_Rp>>, dangling>;
}



using ranges::get;



template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_size<ranges::subrange<_Ip, _Sp, _Kp>> : integral_constant<size_t, 2> {};

template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<0, ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Ip;
};

template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<1, ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Sp;
};

template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<0, const ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Ip;
};

template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<1, const ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Sp;
};



}}
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

#pragma GCC diagnostic push
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Iter>
class reverse_iterator

    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>

{
#pragma GCC diagnostic pop

private:

  _Iter __t_;



  static_assert(__has_bidirectional_iterator_category<_Iter>::value || bidirectional_iterator<_Iter>,
                "reverse_iterator<It> requires It to be a bidirectional iterator.");


protected:
  _Iter current;

public:
  using iterator_type = _Iter;

  using iterator_category =
      _If<__has_random_access_iterator_category<_Iter>::value,
          random_access_iterator_tag,
          typename iterator_traits<_Iter>::iterator_category>;
  using pointer = typename iterator_traits<_Iter>::pointer;

  using iterator_concept = _If<random_access_iterator<_Iter>, random_access_iterator_tag, bidirectional_iterator_tag>;
  using value_type = iter_value_t<_Iter>;
  using difference_type = iter_difference_t<_Iter>;
  using reference = iter_reference_t<_Iter>;







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator() : __t_(), current() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit reverse_iterator(_Iter __x) : __t_(__x), current(__x) {}

  template <class _Up, __enable_if_t<!is_same<_Up, _Iter>::value && is_convertible<_Up const&, _Iter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator(const reverse_iterator<_Up>& __u)
      : __t_(__u.base()), current(__u.base()) {}

  template <class _Up,
            __enable_if_t<!is_same<_Up, _Iter>::value && is_convertible<_Up const&, _Iter>::value &&
                              is_assignable<_Iter&, _Up const&>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator& operator=(const reverse_iterator<_Up>& __u) {
    __t_ = current = __u.base();
    return *this;
  }
# 129 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter base() const { return current; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator*() const {
    _Iter __tmp = current;
    return *--__tmp;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer operator->() const
    requires is_pointer_v<_Iter> || requires(const _Iter __i) { __i.operator->(); }
  {
    if constexpr (is_pointer_v<_Iter>) {
      return std::prev(current);
    } else {
      return std::prev(current).operator->();
    }
  }




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator& operator++() {
    --current;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator operator++(int) {
    reverse_iterator __tmp(*this);
    --current;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator& operator--() {
    ++current;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator operator--(int) {
    reverse_iterator __tmp(*this);
    ++current;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator operator+(difference_type __n) const {
    return reverse_iterator(current - __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator operator-(difference_type __n) const {
    return reverse_iterator(current + __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator[](difference_type __n) const {
    return *(*this + __n);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr iter_rvalue_reference_t<_Iter> iter_move(const reverse_iterator& __i) noexcept(
      is_nothrow_copy_constructible_v<_Iter>&& noexcept(ranges::iter_move(--std::declval<_Iter&>()))) {
    auto __tmp = __i.base();
    return ranges::iter_move(--__tmp);
  }

  template <indirectly_swappable<_Iter> _Iter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr void
  iter_swap(const reverse_iterator& __x, const reverse_iterator<_Iter2>& __y) noexcept(
      is_nothrow_copy_constructible_v<_Iter> &&
      is_nothrow_copy_constructible_v<_Iter2>&& noexcept(
          ranges::iter_swap(--std::declval<_Iter&>(), --std::declval<_Iter2&>()))) {
    auto __xtmp = __x.base();
    auto __ytmp = __y.base();
    ranges::iter_swap(--__xtmp, --__ytmp);
  }

};

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() == __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() > __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() != __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() < __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() <= __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)

  requires requires {
    { __x.base() >= __y.base() } -> convertible_to<bool>;
  }

{
  return __x.base() >= __y.base();
}


template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr compare_three_way_result_t<_Iter1, _Iter2>
operator<=>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y) {
  return __y.base() <=> __x.base();
}



template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    -> decltype(__y.base() - __x.base()) {
  return __y.base() - __x.base();
}
# 300 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x) {
  return reverse_iterator<_Iter>(__x.base() - __n);
}


template <class _Iter1, class _Iter2>
  requires(!sized_sentinel_for<_Iter1, _Iter2>)
inline constexpr bool disable_sized_sentinel_for<reverse_iterator<_Iter1>, reverse_iterator<_Iter2>> = true;



template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator<_Iter> make_reverse_iterator(_Iter __i) {
  return reverse_iterator<_Iter>(__i);
}
# 346 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_iterator.h" 3
template <class _Iter>
class __unconstrained_reverse_iterator {
  _Iter __iter_;

public:
  static_assert(__has_bidirectional_iterator_category<_Iter>::value || bidirectional_iterator<_Iter>);

  using iterator_type = _Iter;
  using iterator_category =
      _If<__has_random_access_iterator_category<_Iter>::value,
          random_access_iterator_tag,
          __iterator_category_type<_Iter>>;
  using pointer = __iterator_pointer_type<_Iter>;
  using value_type = iter_value_t<_Iter>;
  using difference_type = iter_difference_t<_Iter>;
  using reference = iter_reference_t<_Iter>;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator(const __unconstrained_reverse_iterator&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __unconstrained_reverse_iterator(_Iter __iter) : __iter_(__iter) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter base() const { return __iter_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator*() const {
    auto __tmp = __iter_;
    return *--__tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer operator->() const {
    if constexpr (is_pointer_v<_Iter>) {
      return std::prev(__iter_);
    } else {
      return std::prev(__iter_).operator->();
    }
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr iter_rvalue_reference_t<_Iter>
  iter_move(const __unconstrained_reverse_iterator& __i) noexcept(
      is_nothrow_copy_constructible_v<_Iter>&& noexcept(ranges::iter_move(--std::declval<_Iter&>()))) {
    auto __tmp = __i.base();
    return ranges::iter_move(--__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator& operator++() {
    --__iter_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator operator++(int) {
    auto __tmp = *this;
    --__iter_;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator& operator--() {
    ++__iter_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator operator--(int) {
    auto __tmp = *this;
    ++__iter_;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator& operator+=(difference_type __n) {
    __iter_ -= __n;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator& operator-=(difference_type __n) {
    __iter_ += __n;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator operator+(difference_type __n) const {
    return __unconstrained_reverse_iterator(__iter_ - __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __unconstrained_reverse_iterator operator-(difference_type __n) const {
    return __unconstrained_reverse_iterator(__iter_ + __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr difference_type operator-(const __unconstrained_reverse_iterator& __other) const {
    return __other.__iter_ - __iter_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator[](difference_type __n) const { return *(*this + __n); }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator==(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() == __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator!=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() != __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator<(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() > __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator>(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() < __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator<=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() >= __rhs.base();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) friend constexpr bool
  operator>=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() <= __rhs.base();
  }
};



template <template <class> class _RevIter1, template <class> class _RevIter2, class _Iter>
struct __unwrap_reverse_iter_impl {
  using _UnwrappedIter = decltype(__unwrap_iter_impl<_Iter>::__unwrap(std::declval<_Iter>()));
  using _ReverseWrapper = _RevIter1<_RevIter2<_Iter> >;

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ReverseWrapper
  __rewrap(_ReverseWrapper __orig_iter, _UnwrappedIter __unwrapped_iter) {
    return _ReverseWrapper(
        _RevIter2<_Iter>(__unwrap_iter_impl<_Iter>::__rewrap(__orig_iter.base().base(), __unwrapped_iter)));
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _UnwrappedIter __unwrap(_ReverseWrapper __i) noexcept {
    return __unwrap_iter_impl<_Iter>::__unwrap(__i.base().base());
  }
};


template <ranges::bidirectional_range _Range>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr ranges::subrange<reverse_iterator<ranges::iterator_t<_Range>>,
                                                 reverse_iterator<ranges::iterator_t<_Range>>>
__reverse_range(_Range&& __range) {
  auto __first = ranges::begin(__range);
  return {std::make_reverse_iterator(ranges::next(__first, ranges::end(__range))), std::make_reverse_iterator(__first)};
}


template <class _Iter, bool __b>
struct __unwrap_iter_impl<reverse_iterator<reverse_iterator<_Iter> >, __b>
    : __unwrap_reverse_iter_impl<reverse_iterator, reverse_iterator, _Iter> {};



template <class _Iter, bool __b>
struct __unwrap_iter_impl<reverse_iterator<__unconstrained_reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<reverse_iterator, __unconstrained_reverse_iterator, _Iter> {};

template <class _Iter, bool __b>
struct __unwrap_iter_impl<__unconstrained_reverse_iterator<reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<__unconstrained_reverse_iterator, reverse_iterator, _Iter> {};

template <class _Iter, bool __b>
struct __unwrap_iter_impl<__unconstrained_reverse_iterator<__unconstrained_reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<__unconstrained_reverse_iterator, __unconstrained_reverse_iterator, _Iter> {};



}}
# 123 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/wrap_iter.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/wrap_iter.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Iter>
class __wrap_iter {
public:
  typedef _Iter iterator_type;
  typedef typename iterator_traits<iterator_type>::value_type value_type;
  typedef typename iterator_traits<iterator_type>::difference_type difference_type;
  typedef typename iterator_traits<iterator_type>::pointer pointer;
  typedef typename iterator_traits<iterator_type>::reference reference;
  typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;

  typedef contiguous_iterator_tag iterator_concept;


private:
  iterator_type __i_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter() noexcept : __i_() {}
  template <class _Up, __enable_if_t<is_convertible<_Up, iterator_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter(const __wrap_iter<_Up>& __u) noexcept
      : __i_(__u.base()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator*() const noexcept { return *__i_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer operator->() const noexcept {
    return std::__to_address(__i_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter& operator++() noexcept {
    ++__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter operator++(int) noexcept {
    __wrap_iter __tmp(*this);
    ++(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter& operator--() noexcept {
    --__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter operator--(int) noexcept {
    __wrap_iter __tmp(*this);
    --(*this);
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter operator+(difference_type __n) const noexcept {
    __wrap_iter __w(*this);
    __w += __n;
    return __w;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter& operator+=(difference_type __n) noexcept {
    __i_ += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter operator-(difference_type __n) const noexcept {
    return *this + (-__n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter& operator-=(difference_type __n) noexcept {
    *this += -__n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator[](difference_type __n) const noexcept {
    return __i_[__n];
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator_type base() const noexcept { return __i_; }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __wrap_iter(iterator_type __x) noexcept : __i_(__x) {}

  template <class _Up>
  friend class __wrap_iter;
  template <class _CharT, class _Traits, class _Alloc>
  friend class basic_string;
  template <class _CharT, class _Traits>
  friend class basic_string_view;
  template <class _Tp, class _Alloc>
  friend class vector;
  template <class _Tp, size_t>
  friend class span;
  template <class _Tp, size_t _Size>
  friend struct array;
};

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept {
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept {
  return __x.base() == __y.base();
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept {
  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept {
  return __x.base() < __y.base();
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept {
  return !(__x == __y);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept {
  return !(__x == __y);
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept {
  return __y < __x;
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept {
  return __y < __x;
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept {
  return !(__x < __y);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept {
  return !(__x < __y);
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept {
  return !(__y < __x);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept {
  return !(__y < __x);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr

    auto
    operator-(const __wrap_iter<_Iter1>& __x,
              const __wrap_iter<_Iter2>& __y) noexcept->decltype(__x.base() - __y.base())




{
  return __x.base() - __y.base();
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __wrap_iter<_Iter1>
operator+(typename __wrap_iter<_Iter1>::difference_type __n, __wrap_iter<_Iter1> __x) noexcept {
  __x += __n;
  return __x;
}






template <class _It>
struct pointer_traits<__wrap_iter<_It> > {
  typedef __wrap_iter<_It> pointer;
  typedef typename pointer_traits<_It>::element_type element_type;
  typedef typename pointer_traits<_It>::difference_type difference_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static element_type* to_address(pointer __w) noexcept {
    return std::__to_address(__w.base());
  }
};

}}
# 124 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 135 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/empty.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/empty.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

struct __empty {};

}}
# 136 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdexcept" 1 3
# 46 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdexcept" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/string.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/string.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/memory_resource.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/memory_resource.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

namespace pmr {
template <class _ValueType>
class polymorphic_allocator;
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/string.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/string.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _CharT>
struct char_traits;
template <>
struct char_traits<char>;


template <>
struct char_traits<char8_t>;


template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;


template <>
struct char_traits<wchar_t>;


template <class _Tp>
class allocator;

template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_string;

using string = basic_string<char>;


using wstring = basic_string<wchar_t>;



using u8string = basic_string<char8_t>;


using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;



namespace pmr {
template <class _CharT, class _Traits = char_traits<_CharT>>
using basic_string = std::basic_string<_CharT, _Traits, polymorphic_allocator<_CharT>>;

using string = basic_string<char>;


using wstring = basic_string<wchar_t>;



using u8string = basic_string<char8_t>;


using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
}




template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(string)))

      __attribute__((__preferred_name__(wstring)))


      __attribute__((__preferred_name__(u8string)))

      __attribute__((__preferred_name__(u16string)))
      __attribute__((__preferred_name__(u32string)))

      __attribute__((__preferred_name__(pmr::string)))

      __attribute__((__preferred_name__(pmr::wstring)))


      __attribute__((__preferred_name__(pmr::u8string)))

      __attribute__((__preferred_name__(pmr::u16string)))
      __attribute__((__preferred_name__(pmr::u32string)))

      basic_string;


}}
# 47 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdexcept" 2 3
# 51 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdexcept" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


class __attribute__((__visibility__("hidden"))) __libcpp_refstring {
  const char* __imp_;

  bool __uses_refcount() const;

public:
  explicit __libcpp_refstring(const char* __msg);
  __libcpp_refstring(const __libcpp_refstring& __s) noexcept;
  __libcpp_refstring& operator=(const __libcpp_refstring& __s) noexcept;
  ~__libcpp_refstring();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const char* c_str() const noexcept { return __imp_; }
};


}}

namespace std
{

class __attribute__((__visibility__("default"))) logic_error : public exception {


private:
  std::__libcpp_refstring __imp_;

public:
  explicit logic_error(const string&);
  explicit logic_error(const char*);

  logic_error(const logic_error&) noexcept;
  logic_error& operator=(const logic_error&) noexcept;

  ~logic_error() noexcept override;

  const char* what() const noexcept override;






};

class __attribute__((__visibility__("default"))) runtime_error : public exception {


private:
  std::__libcpp_refstring __imp_;

public:
  explicit runtime_error(const string&);
  explicit runtime_error(const char*);

  runtime_error(const runtime_error&) noexcept;
  runtime_error& operator=(const runtime_error&) noexcept;

  ~runtime_error() noexcept override;

  const char* what() const noexcept override;






};

class __attribute__((__visibility__("default"))) domain_error : public logic_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit domain_error(const string& __s) : logic_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit domain_error(const char* __s) : logic_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) domain_error(const domain_error&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) domain_error& operator=(const domain_error&) noexcept = default;
  ~domain_error() noexcept override;

};

class __attribute__((__visibility__("default"))) invalid_argument : public logic_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit invalid_argument(const string& __s) : logic_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit invalid_argument(const char* __s) : logic_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) invalid_argument(const invalid_argument&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) invalid_argument& operator=(const invalid_argument&) noexcept = default;
  ~invalid_argument() noexcept override;

};

class __attribute__((__visibility__("default"))) length_error : public logic_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit length_error(const string& __s) : logic_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit length_error(const char* __s) : logic_error(__s) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) length_error(const length_error&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) length_error& operator=(const length_error&) noexcept = default;
  ~length_error() noexcept override;

};

class __attribute__((__visibility__("default"))) out_of_range : public logic_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit out_of_range(const string& __s) : logic_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit out_of_range(const char* __s) : logic_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) out_of_range(const out_of_range&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) out_of_range& operator=(const out_of_range&) noexcept = default;
  ~out_of_range() noexcept override;

};

class __attribute__((__visibility__("default"))) range_error : public runtime_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit range_error(const string& __s) : runtime_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit range_error(const char* __s) : runtime_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) range_error(const range_error&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) range_error& operator=(const range_error&) noexcept = default;
  ~range_error() noexcept override;

};

class __attribute__((__visibility__("default"))) overflow_error : public runtime_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit overflow_error(const string& __s) : runtime_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit overflow_error(const char* __s) : runtime_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) overflow_error(const overflow_error&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) overflow_error& operator=(const overflow_error&) noexcept = default;
  ~overflow_error() noexcept override;

};

class __attribute__((__visibility__("default"))) underflow_error : public runtime_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit underflow_error(const string& __s) : runtime_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit underflow_error(const char* __s) : runtime_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) underflow_error(const underflow_error&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) underflow_error& operator=(const underflow_error&) noexcept = default;
  ~underflow_error() noexcept override;

};

}

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


[[noreturn]] __attribute__((__visibility__("default"))) void __throw_runtime_error(const char*);

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_logic_error(const char* __msg) {

  throw logic_error(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_domain_error(const char* __msg) {

  throw domain_error(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_invalid_argument(const char* __msg) {

  throw invalid_argument(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_length_error(const char* __msg) {

  throw length_error(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_out_of_range(const char* __msg) {

  throw out_of_range(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_range_error(const char* __msg) {

  throw range_error(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_overflow_error(const char* __msg) {

  throw overflow_error(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_underflow_error(const char* __msg) {

  throw underflow_error(__msg);



}

}}
# 140 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3






# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/data.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/data.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Cont>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto data(_Cont& __c) noexcept(noexcept(__c.data())) -> decltype(__c.data()) {
  return __c.data();
}

template <class _Cont>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto data(const _Cont& __c) noexcept(noexcept(__c.data())) -> decltype(__c.data()) {
  return __c.data();
}

template <class _Tp, size_t _Sz>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept {
  return __array;
}

template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Ep* data(initializer_list<_Ep> __il) noexcept {
  return __il.begin();
}



}}
# 147 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/empty.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/empty.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Cont>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto empty(const _Cont& __c)
    noexcept(noexcept(__c.empty())) -> decltype(__c.empty()) {
  return __c.empty();
}

template <class _Tp, size_t _Sz>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty(const _Tp (&)[_Sz]) noexcept {
  return false;
}

template <class _Ep>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty(initializer_list<_Ep> __il) noexcept {
  return __il.size() == 0;
}



}}
# 148 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_access.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/reverse_access.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np]) {
  return reverse_iterator<_Tp*>(__array + _Np);
}

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator<_Tp*> rend(_Tp (&__array)[_Np]) {
  return reverse_iterator<_Tp*>(__array);
}

template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il) {
  return reverse_iterator<const _Ep*>(__il.end());
}

template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il) {
  return reverse_iterator<const _Ep*>(__il.begin());
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto rbegin(_Cp& __c) -> decltype(__c.rbegin()) {
  return __c.rbegin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto rbegin(const _Cp& __c) -> decltype(__c.rbegin()) {
  return __c.rbegin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto rend(_Cp& __c) -> decltype(__c.rend()) {
  return __c.rend();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto rend(const _Cp& __c) -> decltype(__c.rend()) {
  return __c.rend();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto crbegin(const _Cp& __c) -> decltype(std::rbegin(__c)) {
  return std::rbegin(__c);
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto crend(const _Cp& __c) -> decltype(std::rend(__c)) {
  return std::rend(__c);
}



}}
# 149 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/size.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/size.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Cont>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto size(const _Cont& __c) noexcept(noexcept(__c.size())) -> decltype(__c.size()) {
  return __c.size();
}

template <class _Tp, size_t _Sz>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t size(const _Tp (&)[_Sz]) noexcept {
  return _Sz;
}


template <class _Cont>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto ssize(const _Cont& __c)
    noexcept(noexcept(static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(__c.size())>>>(__c.size())))
        -> common_type_t<ptrdiff_t, make_signed_t<decltype(__c.size())>> {
  return static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(__c.size())>>>(__c.size());
}



#pragma clang diagnostic push

template <class _Tp, ptrdiff_t _Sz>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr ptrdiff_t ssize(const _Tp (&)[_Sz]) noexcept {
  return _Sz;
}
#pragma clang diagnostic pop




}}
# 150 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/compare" 1 3
# 144 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/compare" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_partial_order_fallback.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_partial_order_fallback.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/partial_order.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/partial_order.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/weak_order.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/weak_order.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/strong_order.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/strong_order.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__bit/bit_cast.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__bit/bit_cast.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _ToType, class _FromType>
  requires(sizeof(_ToType) == sizeof(_FromType) && is_trivially_copyable_v<_ToType> &&
           is_trivially_copyable_v<_FromType>)
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ToType bit_cast(const _FromType& __from) noexcept {
  return __builtin_bit_cast(_ToType, __from);
}



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/strong_order.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__math/exponential_functions.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__math/exponential_functions.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/promote.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/promote.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __numeric_type {
  static void __test(...);
  static float __test(float);
  static double __test(char);
  static double __test(int);
  static double __test(unsigned);
  static double __test(long);
  static double __test(unsigned long);
  static double __test(long long);
  static double __test(unsigned long long);

  static double __test(__int128_t);
  static double __test(__uint128_t);

  static double __test(double);
  static long double __test(long double);

  typedef decltype(__test(std::declval<_Tp>())) type;
  static const bool value = _IsNotSame<type, void>::value;
};

template <>
struct __numeric_type<void> {
  static const bool value = true;
};

template <class _A1,
          class _A2 = void,
          class _A3 = void,
          bool = __numeric_type<_A1>::value && __numeric_type<_A2>::value && __numeric_type<_A3>::value>
class __promote_imp {
public:
  static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true> {
private:
  typedef typename __promote_imp<_A1>::type __type1;
  typedef typename __promote_imp<_A2>::type __type2;
  typedef typename __promote_imp<_A3>::type __type3;

public:
  typedef decltype(__type1() + __type2() + __type3()) type;
  static const bool value = true;
};

template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true> {
private:
  typedef typename __promote_imp<_A1>::type __type1;
  typedef typename __promote_imp<_A2>::type __type2;

public:
  typedef decltype(__type1() + __type2()) type;
  static const bool value = true;
};

template <class _A1>
class __promote_imp<_A1, void, void, true> {
public:
  typedef typename __numeric_type<_A1>::type type;
  static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};

}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__math/exponential_functions.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__math/exponential_functions.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) float exp(float __x) noexcept { return __builtin_expf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double exp(double __x) noexcept {
  return __builtin_exp(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long double exp(long double __x) noexcept { return __builtin_expl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double exp(_A1 __x) noexcept {
  return __builtin_exp((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) float frexp(float __x, int* __e) noexcept { return __builtin_frexpf(__x, __e); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double frexp(double __x, int* __e) noexcept {
  return __builtin_frexp(__x, __e);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long double frexp(long double __x, int* __e) noexcept {
  return __builtin_frexpl(__x, __e);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double frexp(_A1 __x, int* __e) noexcept {
  return __builtin_frexp((double)__x, __e);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) float ldexp(float __x, int __e) noexcept { return __builtin_ldexpf(__x, __e); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double ldexp(double __x, int __e) noexcept {
  return __builtin_ldexp(__x, __e);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long double ldexp(long double __x, int __e) noexcept {
  return __builtin_ldexpl(__x, __e);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double ldexp(_A1 __x, int __e) noexcept {
  return __builtin_ldexp((double)__x, __e);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) float exp2(float __x) noexcept { return __builtin_exp2f(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double exp2(double __x) noexcept {
  return __builtin_exp2(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long double exp2(long double __x) noexcept { return __builtin_exp2l(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double exp2(_A1 __x) noexcept {
  return __builtin_exp2((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) float expm1(float __x) noexcept { return __builtin_expm1f(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double expm1(double __x) noexcept {
  return __builtin_expm1(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long double expm1(long double __x) noexcept { return __builtin_expm1l(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double expm1(_A1 __x) noexcept {
  return __builtin_expm1((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) float scalbln(float __x, long __y) noexcept { return __builtin_scalblnf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double scalbln(double __x, long __y) noexcept {
  return __builtin_scalbln(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long double scalbln(long double __x, long __y) noexcept {
  return __builtin_scalblnl(__x, __y);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double scalbln(_A1 __x, long __y) noexcept {
  return __builtin_scalbln((double)__x, __y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) float scalbn(float __x, int __y) noexcept { return __builtin_scalbnf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double scalbn(double __x, int __y) noexcept {
  return __builtin_scalbn(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long double scalbn(long double __x, int __y) noexcept {
  return __builtin_scalbnl(__x, __y);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double scalbn(_A1 __x, int __y) noexcept {
  return __builtin_scalbn((double)__x, __y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) float pow(float __x, float __y) noexcept { return __builtin_powf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double pow(double __x, double __y) noexcept {
  return __builtin_pow(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long double pow(long double __x, long double __y) noexcept {
  return __builtin_powl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) typename __promote<_A1, _A2>::type pow(_A1 __x, _A2 __y) noexcept {
  using __result_type = typename __promote<_A1, _A2>::type;
  static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::pow((__result_type)__x, (__result_type)__y);
}

}

}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/strong_order.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__math/traits.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__math/traits.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

namespace __math {



template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool signbit(_A1 __x) noexcept {
  return __builtin_signbit(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value && is_signed<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool signbit(_A1 __x) noexcept {
  return __x < 0;
}

template <class _A1, __enable_if_t<is_integral<_A1>::value && !is_signed<_A1>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool signbit(_A1) noexcept {
  return false;
}



template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && numeric_limits<_A1>::has_infinity, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isfinite(_A1 __x) noexcept {
  return __builtin_isfinite((typename __promote<_A1>::type)__x);
}

template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && !numeric_limits<_A1>::has_infinity, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isfinite(_A1) noexcept {
  return true;
}



template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && numeric_limits<_A1>::has_infinity, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isinf(_A1 __x) noexcept {
  return __builtin_isinf((typename __promote<_A1>::type)__x);
}

template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && !numeric_limits<_A1>::has_infinity, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isinf(_A1) noexcept {
  return false;
}


[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isinf(float __x) noexcept {
  return __builtin_isinf(__x);
}

[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) bool
isinf(double __x) noexcept {
  return __builtin_isinf(__x);
}

[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isinf(long double __x) noexcept {
  return __builtin_isinf(__x);
}




template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isnan(_A1 __x) noexcept {
  return __builtin_isnan(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isnan(_A1) noexcept {
  return false;
}


[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isnan(float __x) noexcept {
  return __builtin_isnan(__x);
}

[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) bool
isnan(double __x) noexcept {
  return __builtin_isnan(__x);
}

[[__nodiscard__]] inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isnan(long double __x) noexcept {
  return __builtin_isnan(__x);
}




template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isnormal(_A1 __x) noexcept {
  return __builtin_isnormal(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
[[__nodiscard__]] constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isnormal(_A1 __x) noexcept {
  return __x != 0;
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isgreater(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isgreater((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isgreaterequal(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isgreaterequal((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isless(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isless((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool islessequal(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_islessequal((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool islessgreater(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_islessgreater((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool isunordered(_A1 __x, _A2 __y) noexcept {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isunordered((type)__x, (type)__y);
}

}

}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/strong_order.h" 2 3





# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/priority_tag.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/priority_tag.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <size_t _Ip>
struct __priority_tag : __priority_tag<_Ip - 1> {};
template <>
struct __priority_tag<0> {};

}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/strong_order.h" 2 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/strong_order.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/strong_order.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




namespace __strong_order {
struct __fn {

  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<2>) noexcept(
      noexcept(strong_ordering(strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
      -> decltype(strong_ordering(strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))) {
    return strong_ordering(strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)));
  }


  template <class _Tp, class _Up, class _Dp = decay_t<_Tp>>
    requires is_same_v<_Dp, decay_t<_Up>> && is_floating_point_v<_Dp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr strong_ordering __go(_Tp&& __t, _Up&& __u, __priority_tag<1>) noexcept {
    if constexpr (numeric_limits<_Dp>::is_iec559 && sizeof(_Dp) == sizeof(int32_t)) {
      int32_t __rx = std::bit_cast<int32_t>(__t);
      int32_t __ry = std::bit_cast<int32_t>(__u);
      __rx = (__rx < 0) ? (numeric_limits<int32_t>::min() - __rx - 1) : __rx;
      __ry = (__ry < 0) ? (numeric_limits<int32_t>::min() - __ry - 1) : __ry;
      return (__rx <=> __ry);
    } else if constexpr (numeric_limits<_Dp>::is_iec559 && sizeof(_Dp) == sizeof(int64_t)) {
      int64_t __rx = std::bit_cast<int64_t>(__t);
      int64_t __ry = std::bit_cast<int64_t>(__u);
      __rx = (__rx < 0) ? (numeric_limits<int64_t>::min() - __rx - 1) : __rx;
      __ry = (__ry < 0) ? (numeric_limits<int64_t>::min() - __ry - 1) : __ry;
      return (__rx <=> __ry);
    } else if (__t < __u) {
      return strong_ordering::less;
    } else if (__t > __u) {
      return strong_ordering::greater;
    } else if (__t == __u) {
      if constexpr (numeric_limits<_Dp>::radix == 2) {
        return __math::signbit(__u) <=> __math::signbit(__t);
      } else {



        if (__t == 0 || __math::isinf(__t)) {
          return __math::signbit(__u) <=> __math::signbit(__t);
        } else {
          int __texp, __uexp;
          (void)__math::frexp(__t, &__texp);
          (void)__math::frexp(__u, &__uexp);
          return (__t < 0) ? (__texp <=> __uexp) : (__uexp <=> __texp);
        }
      }
    } else {


      bool __t_is_nan = __math::isnan(__t);
      bool __u_is_nan = __math::isnan(__u);
      bool __t_is_negative = __math::signbit(__t);
      bool __u_is_negative = __math::signbit(__u);
      using _IntType =
          conditional_t< sizeof(__t) == sizeof(int32_t),
                         int32_t,
                         conditional_t< sizeof(__t) == sizeof(int64_t), int64_t, void> >;
      if constexpr (is_same_v<_IntType, void>) {
        static_assert(sizeof(_Dp) == 0, "std::strong_order is unimplemented for this floating-point type");
      } else if (__t_is_nan && __u_is_nan) {

        if (__t_is_negative != __u_is_negative) {
          return (__u_is_negative <=> __t_is_negative);
        } else {
          return std::bit_cast<_IntType>(__t) <=> std::bit_cast<_IntType>(__u);
        }
      } else if (__t_is_nan) {
        return __t_is_negative ? strong_ordering::less : strong_ordering::greater;
      } else {
        return __u_is_negative ? strong_ordering::greater : strong_ordering::less;
      }
    }
  }

  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<0>) noexcept(
      noexcept(strong_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
      -> decltype(strong_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))) {
    return strong_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)));
  }

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>())))
          -> decltype(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>())) {
    return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>());
  }
};
}

inline namespace __cpo {
inline constexpr auto strong_order = __strong_order::__fn{};
}



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/weak_order.h" 2 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/weak_order.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




namespace __weak_order {
struct __fn {

  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<3>) noexcept(
      noexcept(weak_ordering(weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
      -> decltype(weak_ordering(weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))) {
    return weak_ordering(weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)));
  }


  template <class _Tp, class _Up, class _Dp = decay_t<_Tp>>
    requires is_same_v<_Dp, decay_t<_Up>> && is_floating_point_v<_Dp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr weak_ordering __go(_Tp&& __t, _Up&& __u, __priority_tag<2>) noexcept {
    partial_ordering __po = (__t <=> __u);
    if (__po == partial_ordering::less) {
      return weak_ordering::less;
    } else if (__po == partial_ordering::equivalent) {
      return weak_ordering::equivalent;
    } else if (__po == partial_ordering::greater) {
      return weak_ordering::greater;
    } else {

      bool __t_is_nan = __math::isnan(__t);
      bool __u_is_nan = __math::isnan(__u);
      bool __t_is_negative = __math::signbit(__t);
      bool __u_is_negative = __math::signbit(__u);
      if (__t_is_nan && __u_is_nan) {
        return (__u_is_negative <=> __t_is_negative);
      } else if (__t_is_nan) {
        return __t_is_negative ? weak_ordering::less : weak_ordering::greater;
      } else {
        return __u_is_negative ? weak_ordering::greater : weak_ordering::less;
      }
    }
  }

  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<1>) noexcept(
      noexcept(weak_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
      -> decltype(weak_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))) {
    return weak_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)));
  }

  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<0>) noexcept(
      noexcept(weak_ordering(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
      -> decltype(weak_ordering(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))) {
    return weak_ordering(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)));
  }

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<3>())))
          -> decltype(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<3>())) {
    return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<3>());
  }
};
}

inline namespace __cpo {
inline constexpr auto weak_order = __weak_order::__fn{};
}



}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/partial_order.h" 2 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/partial_order.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




namespace __partial_order {
struct __fn {

  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<2>) noexcept(
      noexcept(partial_ordering(partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
      -> decltype(partial_ordering(partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))) {
    return partial_ordering(partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)));
  }


  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<1>) noexcept(
      noexcept(partial_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
      -> decltype(partial_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))) {
    return partial_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)));
  }

  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<0>) noexcept(
      noexcept(partial_ordering(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
      -> decltype(partial_ordering(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))) {
    return partial_ordering(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)));
  }

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>())))
          -> decltype(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>())) {
    return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>());
  }
};
}

inline namespace __cpo {
inline constexpr auto partial_order = __partial_order::__fn{};
}



}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_partial_order_fallback.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_partial_order_fallback.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




namespace __compare_partial_order_fallback {
struct __fn {
  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<1>) noexcept(
      noexcept(std::partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
      -> decltype(std::partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))) {
    return std::partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u));
  }

  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<0>) noexcept(noexcept(
      std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? partial_ordering::equivalent
      : std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? partial_ordering::less
      : std::forward<_Up>(__u) < std::forward<_Tp>(__t)
          ? partial_ordering::greater
          : partial_ordering::unordered))
      -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? partial_ordering::equivalent
                  : std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? partial_ordering::less
                  : std::forward<_Up>(__u) < std::forward<_Tp>(__t)
                      ? partial_ordering::greater
                      : partial_ordering::unordered) {
    return std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? partial_ordering::equivalent
         : std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? partial_ordering::less
         : std::forward<_Up>(__u) < std::forward<_Tp>(__t)
             ? partial_ordering::greater
             : partial_ordering::unordered;
  }

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())))
          -> decltype(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())) {
    return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>());
  }
};
}

inline namespace __cpo {
inline constexpr auto compare_partial_order_fallback = __compare_partial_order_fallback::__fn{};
}



}}
# 145 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/compare" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_strong_order_fallback.h" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_strong_order_fallback.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




namespace __compare_strong_order_fallback {
struct __fn {
  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<1>) noexcept(
      noexcept(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
      -> decltype(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))) {
    return std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u));
  }

  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<0>) noexcept(noexcept(
      std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? strong_ordering::equal
      : std::forward<_Tp>(__t) < std::forward<_Up>(__u)
          ? strong_ordering::less
          : strong_ordering::greater))
      -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? strong_ordering::equal
                  : std::forward<_Tp>(__t) < std::forward<_Up>(__u)
                      ? strong_ordering::less
                      : strong_ordering::greater) {
    return std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? strong_ordering::equal
         : std::forward<_Tp>(__t) < std::forward<_Up>(__u)
             ? strong_ordering::less
             : strong_ordering::greater;
  }

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())))
          -> decltype(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())) {
    return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>());
  }
};
}

inline namespace __cpo {
inline constexpr auto compare_strong_order_fallback = __compare_strong_order_fallback::__fn{};
}



}}
# 146 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/compare" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_weak_order_fallback.h" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/compare_weak_order_fallback.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




namespace __compare_weak_order_fallback {
struct __fn {
  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<1>) noexcept(
      noexcept(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
      -> decltype(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))) {
    return std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u));
  }

  template <class _Tp, class _Up>
    requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __go(_Tp&& __t, _Up&& __u, __priority_tag<0>) noexcept(noexcept(
      std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? weak_ordering::equivalent
      : std::forward<_Tp>(__t) < std::forward<_Up>(__u)
          ? weak_ordering::less
          : weak_ordering::greater))
      -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? weak_ordering::equivalent
                  : std::forward<_Tp>(__t) < std::forward<_Up>(__u)
                      ? weak_ordering::less
                      : weak_ordering::greater) {
    return std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? weak_ordering::equivalent
         : std::forward<_Tp>(__t) < std::forward<_Up>(__u)
             ? weak_ordering::less
             : weak_ordering::greater;
  }

  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())))
          -> decltype(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())) {
    return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>());
  }
};
}

inline namespace __cpo {
inline constexpr auto compare_weak_order_fallback = __compare_weak_order_fallback::__fn{};
}



}}
# 149 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/compare" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/is_eq.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__compare/is_eq.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr bool is_eq(partial_ordering __c) noexcept { return __c == 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr bool is_neq(partial_ordering __c) noexcept { return __c != 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr bool is_lt(partial_ordering __c) noexcept { return __c < 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr bool is_lteq(partial_ordering __c) noexcept { return __c <= 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr bool is_gt(partial_ordering __c) noexcept { return __c > 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr bool is_gteq(partial_ordering __c) noexcept { return __c >= 0; }



}}
# 150 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/compare" 2 3
# 161 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/compare" 3
# 153 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3
# 161 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 165 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, size_t _Size>
struct array {

  using __self = array;
  using value_type = _Tp;
  using reference = value_type&;
  using const_reference = const value_type&;
  using pointer = value_type*;
  using const_pointer = const value_type*;




  using iterator = pointer;
  using const_iterator = const_pointer;

  using size_type = size_t;
  using difference_type = ptrdiff_t;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;

  _Tp __elems_[_Size];


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void fill(const value_type& __u) {
    std::fill_n(data(), _Size, __u);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(array& __a)
      noexcept(__is_nothrow_swappable<_Tp>::value) {
    std::swap_ranges(data(), data() + _Size, __a.data());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator begin() noexcept { return iterator(data()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator begin() const noexcept {
    return const_iterator(data());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator end() noexcept { return iterator(data() + _Size); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator end() const noexcept {
    return const_iterator(data() + _Size);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator crend() const noexcept { return rend(); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type size() const noexcept { return _Size; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type max_size() const noexcept { return _Size; }
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty() const noexcept {
    return _Size == 0;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator[](size_type __n) noexcept {
    ((void)0);
    return __elems_[__n];
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference operator[](size_type __n) const noexcept {
    ((void)0);
    return __elems_[__n];
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference at(size_type __n) {
    if (__n >= _Size)
      __throw_out_of_range("array::at");
    return __elems_[__n];
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference at(size_type __n) const {
    if (__n >= _Size)
      __throw_out_of_range("array::at");
    return __elems_[__n];
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference front() noexcept { return (*this)[0]; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference front() const noexcept { return (*this)[0]; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference back() noexcept { return (*this)[_Size - 1]; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference back() const noexcept {
    return (*this)[_Size - 1];
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr value_type* data() noexcept { return __elems_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const value_type* data() const noexcept { return __elems_; }
};

template <class _Tp>
struct array<_Tp, 0> {

  typedef array __self;
  typedef _Tp value_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  typedef __conditional_t<is_const<_Tp>::value, const __empty, __empty> _EmptyType;

  struct _ArrayInStructT {
    _Tp __data_[1];
  };
  alignas(_ArrayInStructT) _EmptyType __elems_[sizeof(_ArrayInStructT)];

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr value_type* data() noexcept { return nullptr; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const value_type* data() const noexcept { return nullptr; }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void fill(const value_type&) {
    static_assert(!is_const<_Tp>::value, "cannot fill zero-sized array of type 'const T'");
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(array&) noexcept {
    static_assert(!is_const<_Tp>::value, "cannot swap zero-sized array of type 'const T'");
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator begin() noexcept { return iterator(data()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator begin() const noexcept {
    return const_iterator(data());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator end() noexcept { return iterator(data()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator end() const noexcept {
    return const_iterator(data());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator crend() const noexcept { return rend(); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type size() const noexcept { return 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type max_size() const noexcept { return 0; }
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty() const noexcept { return true; }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator[](size_type) noexcept {
    ((void)0);
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference operator[](size_type) const noexcept {
    ((void)0);
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference at(size_type) {
    __throw_out_of_range("array<T, 0>::at");
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference at(size_type) const {
    __throw_out_of_range("array<T, 0>::at");
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference front() noexcept {
    ((void)0);
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference front() const noexcept {
    ((void)0);
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference back() noexcept {
    ((void)0);
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference back() const noexcept {
    ((void)0);
    __libcpp_unreachable();
  }
};


template <class _Tp, class... _Args, class = enable_if_t<__all<_IsSame<_Tp, _Args>::value...>::value> >
array(_Tp, _Args...) -> array<_Tp, 1 + sizeof...(_Args)>;


template <class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
  return std::equal(__x.begin(), __x.end(), __y.begin());
}
# 423 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/array" 3
template <class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __synth_three_way_result<_Tp>
operator<=>(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
  return std::lexicographical_compare_three_way(
      __x.begin(), __x.end(), __y.begin(), __y.end(), std::__synth_three_way<_Tp, _Tp>);
}



template <class _Tp, size_t _Size, __enable_if_t<_Size == 0 || __is_swappable<_Tp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(array<_Tp, _Size>& __x, array<_Tp, _Size>& __y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

template <class _Tp, size_t _Size>
struct tuple_size<array<_Tp, _Size> > : public integral_constant<size_t, _Size> {};

template <size_t _Ip, class _Tp, size_t _Size>
struct tuple_element<_Ip, array<_Tp, _Size> > {
  static_assert(_Ip < _Size, "Index out of bounds in std::tuple_element<> (std::array)");
  typedef _Tp type;
};

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& get(array<_Tp, _Size>& __a) noexcept {
  static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array)");
  return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp& get(const array<_Tp, _Size>& __a) noexcept {
  static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array)");
  return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp&& get(array<_Tp, _Size>&& __a) noexcept {
  static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array &&)");
  return std::move(__a.__elems_[_Ip]);
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp&& get(const array<_Tp, _Size>&& __a) noexcept {
  static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array &&)");
  return std::move(__a.__elems_[_Ip]);
}



template <typename _Tp, size_t _Size, size_t... _Index>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr array<remove_cv_t<_Tp>, _Size>
__to_array_lvalue_impl(_Tp (&__arr)[_Size], index_sequence<_Index...>) {
  return {{__arr[_Index]...}};
}

template <typename _Tp, size_t _Size, size_t... _Index>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr array<remove_cv_t<_Tp>, _Size>
__to_array_rvalue_impl(_Tp (&&__arr)[_Size], index_sequence<_Index...>) {
  return {{std::move(__arr[_Index])...}};
}

template <typename _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr array<remove_cv_t<_Tp>, _Size>
to_array(_Tp (&__arr)[_Size]) noexcept(is_nothrow_constructible_v<_Tp, _Tp&>) {
  static_assert(!is_array_v<_Tp>, "[array.creation]/1: to_array does not accept multidimensional arrays.");
  static_assert(is_constructible_v<_Tp, _Tp&>, "[array.creation]/1: to_array requires copy constructible elements.");
  return std::__to_array_lvalue_impl(__arr, make_index_sequence<_Size>());
}

template <typename _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr array<remove_cv_t<_Tp>, _Size>
to_array(_Tp (&&__arr)[_Size]) noexcept(is_nothrow_move_constructible_v<_Tp>) {
  static_assert(!is_array_v<_Tp>, "[array.creation]/4: to_array does not accept multidimensional arrays.");
  static_assert(is_move_constructible_v<_Tp>, "[array.creation]/4: to_array requires move constructible elements.");
  return std::__to_array_rvalue_impl(std::move(__arr), make_index_sequence<_Size>());
}



}}
# 4 "/data/data/com.termux/files/home/github/rs/projgeom-rs/cpp_ai/include/projgeom/pch.hpp" 2
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/concepts" 1 3
# 137 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/concepts" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_with.h" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__concepts/common_with.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {






template <class _Tp, class _Up>
concept common_with =
    same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>> &&
    requires {
        static_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>());
        static_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>());
    } &&
    common_reference_with<
        add_lvalue_reference_t<const _Tp>,
        add_lvalue_reference_t<const _Up>> &&
    common_reference_with<
        add_lvalue_reference_t<common_type_t<_Tp, _Up>>,
        common_reference_t<
            add_lvalue_reference_t<const _Tp>,
            add_lvalue_reference_t<const _Up>>>;




}}
# 138 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/concepts" 2 3
# 163 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/concepts" 3
# 5 "/data/data/com.termux/files/home/github/rs/projgeom-rs/cpp_ai/include/projgeom/pch.hpp" 2

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 1 3
# 428 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/aligned_storage.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/aligned_storage.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __align_type {
  static const size_t value = __alignof(_Tp);
  typedef _Tp type;
};

struct __struct_double {
  long double __lx;
};
struct __struct_double4 {
  double __lx[4];
};


typedef __type_list<__align_type<unsigned char>,
        __type_list<__align_type<unsigned short>,
        __type_list<__align_type<unsigned int>,
        __type_list<__align_type<unsigned long>,
        __type_list<__align_type<unsigned long long>,
        __type_list<__align_type<double>,
        __type_list<__align_type<long double>,
        __type_list<__align_type<__struct_double>,
        __type_list<__align_type<__struct_double4>,
        __type_list<__align_type<int*>,
        __nat
        > > > > > > > > > > __all_types;


template <size_t _Align>
struct alignas(_Align) __fallback_overaligned {};

template <class _TL, size_t _Align>
struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align> {
  typedef __conditional_t<_Align == _Hp::value, typename _Hp::type, __fallback_overaligned<_Align> > type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align> {
  typedef __conditional_t<_Align == _Hp::value, typename _Hp::type, typename __find_pod<_Tp, _Align>::type> type;
};

template <class _TL, size_t _Len>
struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align {
private:
  static const size_t __min = _A2 < _A1 ? _A2 : _A1;
  static const size_t __max = _A1 < _A2 ? _A2 : _A1;

public:
  static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__((__deprecated__)) aligned_storage {
  typedef typename __find_pod<__all_types, _Align>::type _Aligner;
  union type {
    _Aligner __align;
    unsigned char __data[(_Len + _Align - 1) / _Align * _Align];
  };
};



#pragma GCC diagnostic push
# 100 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/aligned_storage.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 100 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/aligned_storage.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
using aligned_storage_t __attribute__((__deprecated__)) = typename aligned_storage<_Len, _Align>::type;
#pragma GCC diagnostic pop
# 115 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/aligned_storage.h" 3
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x1> { struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1) / 0x1 * 0x1]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x2> { struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1) / 0x2 * 0x2]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x4> { struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1) / 0x4 * 0x4]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x8> { struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1) / 0x8 * 0x8]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x10> { struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1) / 0x10 * 0x10]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x20> { struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1) / 0x20 * 0x20]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x40> { struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1) / 0x40 * 0x40]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x80> { struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1) / 0x80 * 0x80]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x100> { struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1) / 0x100 * 0x100]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x200> { struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1) / 0x200 * 0x200]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x400> { struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1) / 0x400 * 0x400]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x800> { struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1) / 0x800 * 0x800]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x1000> { struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1) / 0x1000 * 0x1000]; }; };
template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x2000> { struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1) / 0x2000 * 0x2000]; }; };


template <size_t _Len> struct __attribute__((__deprecated__)) aligned_storage<_Len, 0x4000> { struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1) / 0x4000 * 0x4000]; }; };




}}
# 429 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/aligned_union.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/aligned_union.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <size_t _I0, size_t... _In>
struct __static_max;

template <size_t _I0>
struct __static_max<_I0> {
  static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t... _In>
struct __static_max<_I0, _I1, _In...> {
  static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value : __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class... _Types>
struct __attribute__((__deprecated__)) aligned_union {
  static const size_t alignment_value =
      __static_max<__alignof(_Type0), __alignof(_Types)...>::value;
  static const size_t __len = __static_max<_Len, sizeof(_Type0), sizeof(_Types)...>::value;
  typedef typename aligned_storage<__len, alignment_value>::type type;
};


template <size_t _Len, class... _Types>
using aligned_union_t __attribute__((__deprecated__)) = typename aligned_union<_Len, _Types...>::type;


}}
# 430 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/alignment_of.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/alignment_of.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct alignment_of : public integral_constant<size_t, alignof(_Tp)> {};


template <class _Tp>
inline constexpr size_t alignment_of_v = alignof(_Tp);


}}
# 431 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/can_extract_key.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/can_extract_key.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_const_ref.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/remove_const_ref.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
using __remove_const_ref_t = __remove_const_t<__libcpp_remove_reference_t<_Tp> >;

}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/can_extract_key.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/can_extract_key.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key, class _RawValTy = __remove_const_ref_t<_ValTy> >
struct __can_extract_key
    : __conditional_t<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag, __extract_key_fail_tag> {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second> >
    : __conditional_t<_IsSame<__remove_const_t<_First>, _Key>::value, __extract_key_first_tag, __extract_key_fail_tag> {
};




template <class _ValTy, class _Key, class _ContainerValueTy, class _RawValTy = __remove_const_ref_t<_ValTy> >
struct __can_extract_map_key : integral_constant<bool, _IsSame<_RawValTy, _Key>::value> {};



template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy> : false_type {};

}}
# 433 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3





# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/dependent_type.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/dependent_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, bool>
struct __dependent_type : public _Tp {};

}}
# 439 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/has_unique_object_representation.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/has_unique_object_representation.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct has_unique_object_representations
    : public integral_constant<bool, __has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {};

template <class _Tp>
inline constexpr bool has_unique_object_representations_v = has_unique_object_representations<_Tp>::value;



}}
# 443 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/has_virtual_destructor.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/has_virtual_destructor.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};


template <class _Tp>
inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Tp);


}}
# 444 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_abstract.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_abstract.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {};


template <class _Tp>
inline constexpr bool is_abstract_v = __is_abstract(_Tp);


}}
# 447 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_aggregate.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_aggregate.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};

template <class _Tp>
inline constexpr bool is_aggregate_v = __is_aggregate(_Tp);



}}
# 448 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3




# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_bounded_array.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_bounded_array.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class>
struct __libcpp_is_bounded_array : false_type {};
template <class _Tp, size_t _Np>
struct __libcpp_is_bounded_array<_Tp[_Np]> : true_type {};



template <class>
struct is_bounded_array : false_type {};
template <class _Tp, size_t _Np>
struct is_bounded_array<_Tp[_Np]> : true_type {};

template <class _Tp>
inline constexpr bool is_bounded_array_v = is_bounded_array<_Tp>::value;



}}
# 453 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_char_like_type.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_char_like_type.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_standard_layout.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_standard_layout.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {};


template <class _Tp>
inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_char_like_type.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivial.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivial.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {};


template <class _Tp>
inline constexpr bool is_trivial_v = __is_trivial(_Tp);


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_char_like_type.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_char_like_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _CharT>
using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;

}}
# 455 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_compound.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_compound.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_fundamental.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_fundamental.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_fundamental : _BoolConstant<__is_fundamental(_Tp)> {};


template <class _Tp>
inline constexpr bool is_fundamental_v = __is_fundamental(_Tp);
# 46 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_fundamental.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_compound.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_compound.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_compound : _BoolConstant<__is_compound(_Tp)> {};


template <class _Tp>
inline constexpr bool is_compound_v = __is_compound(_Tp);
# 44 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_compound.h" 3
}}
# 457 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_empty.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_empty.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {};


template <class _Tp>
inline constexpr bool is_empty_v = __is_empty(_Tp);


}}
# 466 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3







# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_literal_type.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_literal_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_literal_type.h" 3
}}
# 474 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3







# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_convertible.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_convertible.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/lazy.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/lazy.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <template <class...> class _Func, class... _Args>
struct _Lazy : _Func<_Args...> {};

}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_convertible.h" 2 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_convertible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class _Up>
struct is_nothrow_convertible : bool_constant<__is_nothrow_convertible(_Tp, _Up)> {};

template <class _Tp, class _Up>
inline constexpr bool is_nothrow_convertible_v = __is_nothrow_convertible(_Tp, _Up);
# 60 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_nothrow_convertible.h" 3
}}
# 482 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_pod.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_pod.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_pod : public integral_constant<bool, __is_pod(_Tp)> {};


template <class _Tp>
inline constexpr bool is_pod_v = __is_pod(_Tp);


}}
# 491 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_polymorphic.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_polymorphic.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {};


template <class _Tp>
inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);


}}
# 493 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3





# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scoped_enum.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_scoped_enum.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp, bool = is_enum_v<_Tp> >
struct __is_scoped_enum_helper : false_type {};

template <class _Tp>
struct __is_scoped_enum_helper<_Tp, true> : public bool_constant<!is_convertible_v<_Tp, underlying_type_t<_Tp> > > {};

template <class _Tp>
struct is_scoped_enum : public __is_scoped_enum_helper<_Tp> {};

template <class _Tp>
inline constexpr bool is_scoped_enum_v = is_scoped_enum<_Tp>::value;


}}
# 499 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_specialization.h" 1 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_specialization.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp, template <class...> class _Template>
inline constexpr bool __is_specialization_v = false;

template <template <class...> class _Template, class... _Args>
inline constexpr bool __is_specialization_v<_Template<_Args...>, _Template> = true;



}}
# 501 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_assignable.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Arg>
struct is_trivially_assignable : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)> {};


template <class _Tp, class _Arg>
inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_Tp, _Arg);


}}
# 505 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_constructible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class... _Args>
struct is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)> {};


template <class _Tp, class... _Args>
inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Tp, _Args...);


}}
# 506 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copy_assignable.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copy_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_trivially_copy_assignable
    : public integral_constant<bool,
                               __is_trivially_assignable(__add_lvalue_reference_t<_Tp>,
                                                         __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};


template <class _Tp>
inline constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Tp>::value;


}}
# 507 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copy_constructible.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_copy_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_trivially_copy_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp, __add_lvalue_reference_t<const _Tp>)> {};


template <class _Tp>
inline constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Tp>::value;


}}
# 508 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_default_constructible.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_default_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_trivially_default_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp)> {};


template <class _Tp>
inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Tp);


}}
# 510 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_destructible.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_destructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
struct is_trivially_destructible
    : public integral_constant<bool, __is_trivially_destructible(_Tp)> {};
# 41 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_destructible.h" 3
template <class _Tp>
inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Tp>::value;


}}
# 511 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_move_assignable.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_move_assignable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_trivially_move_assignable
    : public integral_constant<
          bool,
          __is_trivially_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {};


template <class _Tp>
inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Tp>::value;


}}
# 512 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_move_constructible.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_move_constructible.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct is_trivially_move_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};


template <class _Tp>
inline constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Tp>::value;


}}
# 513 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unbounded_array.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_unbounded_array.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class>
struct __libcpp_is_unbounded_array : false_type {};
template <class _Tp>
struct __libcpp_is_unbounded_array<_Tp[]> : true_type {};



template <class>
struct is_unbounded_array : false_type {};
template <class _Tp>
struct is_unbounded_array<_Tp[]> : true_type {};

template <class _Tp>
inline constexpr bool is_unbounded_array_v = is_unbounded_array<_Tp>::value;



}}
# 514 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3







# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/maybe_const.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/maybe_const.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <bool _Const, class _Tp>
using __maybe_const = __conditional_t<_Const, const _Tp, _Tp>;

}}
# 522 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/negation.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/negation.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Pred>
struct _Not : _BoolConstant<!_Pred::value> {};


template <class _Tp>
struct negation : _Not<_Tp> {};
template <class _Tp>
inline constexpr bool negation_v = !_Tp::value;


}}
# 523 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/rank.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/rank.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/rank.h" 3
template <class _Tp>
struct rank : public integral_constant<size_t, 0> {};
template <class _Tp>
struct rank<_Tp[]> : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np>
struct rank<_Tp[_Np]> : public integral_constant<size_t, rank<_Tp>::value + 1> {};




template <class _Tp>
inline constexpr size_t rank_v = rank<_Tp>::value;


}}
# 524 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/result_of.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/result_of.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/result_of.h" 3
}}
# 533 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/type_identity.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/type_identity.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __type_identity {
  typedef _Tp type;
};

template <class _Tp>
using __type_identity_t __attribute__((__nodebug__)) = typename __type_identity<_Tp>::type;


template <class _Tp>
struct type_identity {
  typedef _Tp type;
};
template <class _Tp>
using type_identity_t = typename type_identity<_Tp>::type;


}}
# 534 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 2 3
# 544 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/type_traits" 3
# 7 "/data/data/com.termux/files/home/github/rs/projgeom-rs/cpp_ai/include/projgeom/pch.hpp" 2
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/utility" 1 3
# 250 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/utility" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/as_const.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/as_const.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept {
  return __t;
}

template <class _Tp>
void as_const(const _Tp&&) = delete;


}}
# 251 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/utility" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/as_lvalue.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/as_lvalue.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/as_lvalue.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp& __as_lvalue([[_Clang::__lifetimebound__]] _Tp&& __t) {
  return static_cast<_Tp&>(__t);
}



}}
# 252 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/utility" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/cmp.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/cmp.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/cmp.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <__libcpp_integer _Tp, __libcpp_integer _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool cmp_equal(_Tp __t, _Up __u) noexcept {
  if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
    return __t == __u;
  else if constexpr (is_signed_v<_Tp>)
    return __t < 0 ? false : make_unsigned_t<_Tp>(__t) == __u;
  else
    return __u < 0 ? false : __t == make_unsigned_t<_Up>(__u);
}

template <__libcpp_integer _Tp, __libcpp_integer _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool cmp_not_equal(_Tp __t, _Up __u) noexcept {
  return !std::cmp_equal(__t, __u);
}

template <__libcpp_integer _Tp, __libcpp_integer _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool cmp_less(_Tp __t, _Up __u) noexcept {
  if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
    return __t < __u;
  else if constexpr (is_signed_v<_Tp>)
    return __t < 0 ? true : make_unsigned_t<_Tp>(__t) < __u;
  else
    return __u < 0 ? false : __t < make_unsigned_t<_Up>(__u);
}

template <__libcpp_integer _Tp, __libcpp_integer _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool cmp_greater(_Tp __t, _Up __u) noexcept {
  return std::cmp_less(__u, __t);
}

template <__libcpp_integer _Tp, __libcpp_integer _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool cmp_less_equal(_Tp __t, _Up __u) noexcept {
  return !std::cmp_greater(__t, __u);
}

template <__libcpp_integer _Tp, __libcpp_integer _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool cmp_greater_equal(_Tp __t, _Up __u) noexcept {
  return !std::cmp_less(__t, __u);
}

template <__libcpp_integer _Tp, __libcpp_integer _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool in_range(_Up __u) noexcept {
  return std::cmp_less_equal(__u, numeric_limits<_Tp>::max()) &&
         std::cmp_greater_equal(__u, numeric_limits<_Tp>::min());
}



}}
# 254 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/utility" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exception_guard.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exception_guard.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exception_guard.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 64 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/exception_guard.h" 3
template <class _Rollback>
struct __exception_guard_exceptions {
  __exception_guard_exceptions() = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __exception_guard_exceptions(_Rollback __rollback)
      : __rollback_(std::move(__rollback)), __completed_(false) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  __exception_guard_exceptions(__exception_guard_exceptions&& __other)
      noexcept(is_nothrow_move_constructible<_Rollback>::value)
      : __rollback_(std::move(__other.__rollback_)), __completed_(__other.__completed_) {
    __other.__completed_ = true;
  }

  __exception_guard_exceptions(__exception_guard_exceptions const&) = delete;
  __exception_guard_exceptions& operator=(__exception_guard_exceptions const&) = delete;
  __exception_guard_exceptions& operator=(__exception_guard_exceptions&&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __complete() noexcept { __completed_ = true; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr ~__exception_guard_exceptions() {
    if (!__completed_)
      __rollback_();
  }

private:
  _Rollback __rollback_;
  bool __completed_;
};

template <class... _Tag> [[maybe_unused]] __exception_guard_exceptions(typename _Tag::__allow_ctad...)->__exception_guard_exceptions<_Tag...>;

template <class _Rollback>
struct __exception_guard_noexceptions {
  __exception_guard_noexceptions() = delete;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
      __attribute__((__nodebug__)) explicit __exception_guard_noexceptions(_Rollback) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __attribute__((__nodebug__))
  __exception_guard_noexceptions(__exception_guard_noexceptions&& __other)
      noexcept(is_nothrow_move_constructible<_Rollback>::value)
      : __completed_(__other.__completed_) {
    __other.__completed_ = true;
  }

  __exception_guard_noexceptions(__exception_guard_noexceptions const&) = delete;
  __exception_guard_noexceptions& operator=(__exception_guard_noexceptions const&) = delete;
  __exception_guard_noexceptions& operator=(__exception_guard_noexceptions&&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __attribute__((__nodebug__)) void __complete() noexcept {
    __completed_ = true;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __attribute__((__nodebug__)) ~__exception_guard_noexceptions() {
    ((void)0);
  }

private:
  bool __completed_ = false;
};

template <class... _Tag> [[maybe_unused]] __exception_guard_noexceptions(typename _Tag::__allow_ctad...)->__exception_guard_noexceptions<_Tag...>;





template <class _Rollback>
using __exception_guard = __exception_guard_exceptions<_Rollback>;


template <class _Rollback>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __exception_guard<_Rollback> __make_exception_guard(_Rollback __rollback) {
  return __exception_guard<_Rollback>(std::move(__rollback));
}

}}
# 256 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/utility" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/forward_like.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/forward_like.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Ap, class _Bp>
using _CopyConst = _If<is_const_v<_Ap>, const _Bp, _Bp>;

template <class _Ap, class _Bp>
using _OverrideRef = _If<is_rvalue_reference_v<_Ap>, remove_reference_t<_Bp>&&, _Bp&>;

template <class _Ap, class _Bp>
using _ForwardLike = _OverrideRef<_Ap&&, _CopyConst<remove_reference_t<_Ap>, remove_reference_t<_Bp>>>;

template <class _Tp, class _Up>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto forward_like([[_Clang::__lifetimebound__]] _Up&& __ux) noexcept
    -> _ForwardLike<_Tp, _Up> {
  return static_cast<_ForwardLike<_Tp, _Up>>(__ux);
}



}}
# 259 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/utility" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/in_place.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/in_place.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



struct __attribute__((__visibility__("default"))) in_place_t {
  explicit in_place_t() = default;
};
inline constexpr in_place_t in_place{};

template <class _Tp>
struct in_place_type_t {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit in_place_type_t() = default;
};
template <class _Tp>
inline constexpr in_place_type_t<_Tp> in_place_type{};

template <size_t _Idx>
struct in_place_index_t {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit in_place_index_t() = default;
};
template <size_t _Idx>
inline constexpr in_place_index_t<_Idx> in_place_index{};

template <class _Tp>
struct __is_inplace_type_imp : false_type {};
template <class _Tp>
struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {};

template <class _Tp>
using __is_inplace_type = __is_inplace_type_imp<__remove_cvref_t<_Tp>>;

template <class _Tp>
struct __is_inplace_index_imp : false_type {};
template <size_t _Idx>
struct __is_inplace_index_imp<in_place_index_t<_Idx>> : true_type {};

template <class _Tp>
using __is_inplace_index = __is_inplace_index_imp<__remove_cvref_t<_Tp>>;



}}
# 260 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/utility" 2 3





# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/rel_ops.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/rel_ops.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

namespace rel_ops {

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator!=(const _Tp& __x, const _Tp& __y) {
  return !(__x == __y);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator>(const _Tp& __x, const _Tp& __y) {
  return __y < __x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator<=(const _Tp& __x, const _Tp& __y) {
  return !(__y < __x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator>=(const _Tp& __x, const _Tp& __y) {
  return !(__x < __y);
}

}

}}
# 266 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/utility" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/to_underlying.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/to_underlying.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename underlying_type<_Tp>::type __to_underlying(_Tp __val) noexcept {
  return static_cast<typename underlying_type<_Tp>::type>(__val);
}



template <class _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr underlying_type_t<_Tp> to_underlying(_Tp __val) noexcept {
  return std::__to_underlying(__val);
}


}}
# 268 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/utility" 2 3
# 283 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/utility" 3
# 8 "/data/data/com.termux/files/home/github/rs/projgeom-rs/cpp_ai/include/projgeom/pch.hpp" 2

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/iostream" 1 3
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/iostream" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/ios" 1 3
# 220 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/ios" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/ios.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/ios.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ios;

using ios = basic_ios<char>;

using wios = basic_ios<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ios))) __attribute__((__preferred_name__(wios))) basic_ios;





using streamoff = long long;


}}
# 221 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/ios" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ios/fpos.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ios/fpos.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _StateT>
class fpos {
private:
  _StateT __st_;
  streamoff __off_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) operator streamoff() const { return __off_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _StateT state() const { return __st_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void state(_StateT __st) { __st_ = __st; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) fpos& operator+=(streamoff __off) {
    __off_ += __off;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) fpos operator+(streamoff __off) const {
    fpos __t(*this);
    __t += __off;
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) fpos& operator-=(streamoff __off) {
    __off_ -= __off;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) fpos operator-(streamoff __off) const {
    fpos __t(*this);
    __t -= __off;
    return __t;
  }
};

template <class _StateT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y) {
  return streamoff(__x) - streamoff(__y);
}

template <class _StateT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y) {
  return streamoff(__x) == streamoff(__y);
}

template <class _StateT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y) {
  return streamoff(__x) != streamoff(__y);
}

}}
# 222 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/ios" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale_dir/locale_base_api.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale_dir/locale_base_api.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale_dir/locale_base_api/android.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale_dir/locale_base_api/android.h" 3
extern "C" {


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdlib.h" 1 3
# 91 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdlib.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/alloca.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/wait.h" 1 3 4
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/wait.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/wait.h" 1 3 4
# 39 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/wait.h" 2 3 4
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 1 3 4
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3 4
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdio.h" 1 3 4
# 105 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdio.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 1 3 4
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/types.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/types.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/types.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/types.h" 1 3 4








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/types.h" 1 3 4






# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/types.h" 1 3 4








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/int-ll64.h" 1 3 4








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/bitsperlong.h" 1 3 4
# 10 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/bitsperlong.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/bitsperlong.h" 1 3 4
# 11 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/bitsperlong.h" 2 3 4
# 10 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/int-ll64.h" 2 3 4

typedef __signed__ char __s8;
typedef unsigned char __u8;
typedef __signed__ short __s16;
typedef unsigned short __u16;
typedef __signed__ int __s32;
typedef unsigned int __u32;

__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 10 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/types.h" 2 3 4
# 8 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/types.h" 2 3 4
# 10 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/types.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/posix_types.h" 1 3 4








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/stddef.h" 1 3 4








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/compiler_types.h" 1 3 4
# 11 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/compiler_types.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/compiler.h" 1 3 4
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/compiler_types.h" 2 3 4
# 10 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/stddef.h" 2 3 4
# 10 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/posix_types.h" 2 3 4


typedef struct {
  unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;
typedef void(* __kernel_sighandler_t) (int);
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/posix_types.h" 1 3 4








typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/posix_types.h" 1 3 4
# 11 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;


typedef __kernel_ulong_t __kernel_ino_t;


typedef unsigned int __kernel_mode_t;


typedef int __kernel_pid_t;


typedef int __kernel_ipc_pid_t;


typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;


typedef __kernel_long_t __kernel_suseconds_t;


typedef int __kernel_daddr_t;


typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;






typedef unsigned int __kernel_old_dev_t;







typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;



typedef struct {
  int val[2];
} __kernel_fsid_t;

typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_old_time_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/posix_types.h" 2 3 4
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/posix_types.h" 2 3 4
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/types.h" 2 3 4

typedef __signed__ __int128 __s128 __attribute__((aligned(16)));
typedef unsigned __int128 __u128 __attribute__((aligned(16)));



typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
typedef __u16 __sum16;
typedef __u32 __wsum;



typedef unsigned __poll_t;
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/types.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/pthread_types.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/pthread_types.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/types.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/pthread_types.h" 2 3 4

typedef struct {
  uint32_t flags;
  void* stack_base;
  size_t stack_size;
  size_t guard_size;
  int32_t sched_policy;
  int32_t sched_priority;

  char __reserved[16];

} pthread_attr_t;

typedef struct {

  int64_t __private[4];



} pthread_barrier_t;

typedef int pthread_barrierattr_t;

typedef struct {

  int32_t __private[12];



} pthread_cond_t;

typedef long pthread_condattr_t;

typedef int pthread_key_t;

typedef struct {

  int32_t __private[10];



} pthread_mutex_t;

typedef long pthread_mutexattr_t;

typedef int pthread_once_t;

typedef struct {

  int32_t __private[14];



} pthread_rwlock_t;

typedef long pthread_rwlockattr_t;

typedef struct {

  int64_t __private;



} pthread_spinlock_t;

typedef long pthread_t;
# 41 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/types.h" 2 3 4


typedef __kernel_gid32_t __gid_t;
typedef __gid_t gid_t;
typedef __kernel_uid32_t __uid_t;
typedef __uid_t uid_t;
typedef __kernel_pid_t __pid_t;
typedef __pid_t pid_t;
typedef uint32_t __id_t;
typedef __id_t id_t;

typedef unsigned long blkcnt_t;
typedef unsigned long blksize_t;
typedef __kernel_caddr_t caddr_t;
typedef __kernel_clock_t clock_t;

typedef __kernel_clockid_t __clockid_t;
typedef __clockid_t clockid_t;

typedef __kernel_daddr_t daddr_t;
typedef unsigned long fsblkcnt_t;
typedef unsigned long fsfilcnt_t;

typedef __kernel_mode_t __mode_t;
typedef __mode_t mode_t;

typedef __kernel_key_t __key_t;
typedef __key_t key_t;

typedef __kernel_ino_t __ino_t;
typedef __ino_t ino_t;

typedef uint64_t ino64_t;

typedef uint32_t __nlink_t;
typedef __nlink_t nlink_t;

typedef void* __timer_t;
typedef __timer_t timer_t;

typedef __kernel_suseconds_t __suseconds_t;
typedef __suseconds_t suseconds_t;


typedef uint32_t __useconds_t;
typedef __useconds_t useconds_t;





typedef uint64_t dev_t;



typedef __kernel_time_t __time_t;
typedef __time_t time_t;




typedef int64_t off_t;
typedef off_t loff_t;
typedef loff_t off64_t;
# 116 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/types.h" 3 4
typedef uint32_t __socklen_t;

typedef __socklen_t socklen_t;

typedef __builtin_va_list __va_list;
# 129 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/types.h" 3 4
typedef __kernel_ssize_t ssize_t;


typedef unsigned int uint_t;
typedef unsigned int uint;


typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;

typedef uint32_t u_int32_t;
typedef uint16_t u_int16_t;
typedef uint8_t u_int8_t;
typedef uint64_t u_int64_t;
# 43 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/stdarg.h" 1 3 4
# 47 "/data/data/com.termux/files/usr/lib/clang/21/include/stdarg.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stdarg_header_macro.h" 1 3 4
# 48 "/data/data/com.termux/files/usr/lib/clang/21/include/stdarg.h" 2 3 4



# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stdarg___gnuc_va_list.h" 1 3 4
# 12 "/data/data/com.termux/files/usr/lib/clang/21/include/__stdarg___gnuc_va_list.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 52 "/data/data/com.termux/files/usr/lib/clang/21/include/stdarg.h" 2 3 4




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stdarg_va_list.h" 1 3 4
# 12 "/data/data/com.termux/files/usr/lib/clang/21/include/__stdarg_va_list.h" 3 4
typedef __builtin_va_list va_list;
# 57 "/data/data/com.termux/files/usr/lib/clang/21/include/stdarg.h" 2 3 4




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stdarg_va_arg.h" 1 3 4
# 62 "/data/data/com.termux/files/usr/lib/clang/21/include/stdarg.h" 2 3 4




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stdarg___va_copy.h" 1 3 4
# 67 "/data/data/com.termux/files/usr/lib/clang/21/include/stdarg.h" 2 3 4




# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stdarg_va_copy.h" 1 3 4
# 72 "/data/data/com.termux/files/usr/lib/clang/21/include/stdarg.h" 2 3 4
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3 4
# 46 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string.h" 1 3 4
# 58 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/xlocale.h" 1 3 4
# 44 "/data/data/com.termux/files/usr/bin/../../usr/include/xlocale.h" 3 4
struct __locale_t;




typedef struct __locale_t* locale_t;
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/strcasecmp.h" 1 3 4
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/strcasecmp.h" 3 4
extern "C" {
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/strcasecmp.h" 3 4
int strcasecmp(const char* _Nonnull __s1, const char* _Nonnull __s2) __attribute__((__pure__));






int strcasecmp_l(const char* _Nonnull __s1, const char* _Nonnull __s2, locale_t _Nonnull __l) __attribute__((__pure__)) __attribute__((__availability__(android,strict,introduced=23 )));
# 68 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/strcasecmp.h" 3 4
int strncasecmp(const char* _Nonnull __s1, const char* _Nonnull __s2, size_t __n) __attribute__((__pure__));






int strncasecmp_l(const char* _Nonnull __s1, const char* _Nonnull __s2, size_t __n, locale_t _Nonnull __l) __attribute__((__pure__)) __attribute__((__availability__(android,strict,introduced=23 )));



}
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 2 3 4

extern "C" {


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/strings.h" 1 3 4
# 61 "/data/data/com.termux/files/usr/bin/../../usr/include/strings.h" 3 4
extern "C" {



static __inline__ __attribute__((__always_inline__)) void __bionic_bcopy(const void* _Nonnull b1, void* _Nonnull b2, size_t len) {
  __builtin_memmove(b2, b1, len);
}



static __inline__ __attribute__((__always_inline__)) void __bionic_bzero(void* _Nonnull b, size_t len) {
  __builtin_memset(b, 0, len);
}
# 82 "/data/data/com.termux/files/usr/bin/../../usr/include/strings.h" 3 4
static __inline__ int ffs(int __n) {
  return __builtin_ffs(__n);
}
# 93 "/data/data/com.termux/files/usr/bin/../../usr/include/strings.h" 3 4
static __inline__ int ffsl(long __n) {
  return __builtin_ffsl(__n);
}
# 104 "/data/data/com.termux/files/usr/bin/../../usr/include/strings.h" 3 4
static __inline__ int ffsll(long long __n) {
  return __builtin_ffsll(__n);
}





}
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 2 3 4


void* _Nullable memccpy(void* _Nonnull __dst, const void* _Nonnull __src, int __stop_char, size_t __n);
void* _Nullable memchr(const void* _Nonnull __s, int __ch, size_t __n) __attribute__((__pure__));

extern "C++" void* _Nullable memrchr(void* _Nonnull __s, int __ch, size_t __n) __asm__("memrchr") __attribute__((__pure__));
extern "C++" const void* _Nullable memrchr(const void* _Nonnull __s, int __ch, size_t __n) __asm__("memrchr") __attribute__((__pure__));



int memcmp(const void* _Nonnull __lhs, const void* _Nonnull __rhs, size_t __n) __attribute__((__pure__));
void* _Nonnull memcpy(void* _Nonnull, const void* _Nonnull, size_t);



void* _Nonnull mempcpy(void* _Nonnull __dst, const void* _Nonnull __src, size_t __n) __attribute__((__availability__(android,strict,introduced=23 )));



void* _Nonnull memmove(void* _Nonnull __dst, const void* _Nonnull __src, size_t __n);







void* _Nonnull memset(void* _Nonnull __dst, int __ch, size_t __n);
# 84 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 3 4
void* _Nullable memmem(const void* _Nonnull __haystack, size_t __haystack_size, const void* _Nonnull __needle, size_t __needle_size) __attribute__((__pure__));

char* _Nullable strchr(const char* _Nonnull __s, int __ch) __attribute__((__pure__));
char* _Nullable __strchr_chk(const char* _Nonnull __s, int __ch, size_t __n);




extern "C++" char* _Nonnull strchrnul(char* _Nonnull __s, int __ch) __asm__("strchrnul") __attribute__((__pure__)) __attribute__((__availability__(android,strict,introduced=24 )));
extern "C++" const char* _Nonnull strchrnul(const char* _Nonnull __s, int __ch) __asm__("strchrnul") __attribute__((__pure__)) __attribute__((__availability__(android,strict,introduced=24 )));
# 105 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 3 4
char* _Nullable strrchr(const char* _Nonnull __s, int __ch) __attribute__((__pure__));
char* _Nullable __strrchr_chk(const char* _Nonnull __s, int __ch, size_t __n);

size_t strlen(const char* _Nonnull __s) __attribute__((__pure__));
size_t __strlen_chk(const char* _Nonnull __s, size_t __n);

int strcmp(const char* _Nonnull __lhs, const char* _Nonnull __rhs) __attribute__((__pure__));
char* _Nonnull stpcpy(char* _Nonnull __dst, const char* _Nonnull __src);
char* _Nonnull strcpy(char* _Nonnull __dst, const char* _Nonnull __src);
char* _Nonnull strcat(char* _Nonnull __dst, const char* _Nonnull __src);
char* _Nullable strdup(const char* _Nonnull __s);

char* _Nullable strstr(const char* _Nonnull __haystack, const char* _Nonnull __needle) __attribute__((__pure__));

extern "C++" char* _Nullable strcasestr(char* _Nonnull, const char* _Nonnull) __asm__("strcasestr") __attribute__((__pure__));
extern "C++" const char* _Nullable strcasestr(const char* _Nonnull, const char* _Nonnull) __asm__("strcasestr") __attribute__((__pure__));



char* _Nullable strtok(char* _Nullable __s, const char* _Nonnull __delimiter);
char* _Nullable strtok_r(char* _Nullable __s, const char* _Nonnull __delimiter, char* _Nonnull * _Nonnull __pos_ptr);
# 138 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 3 4
char* _Nonnull strerror(int __errno_value);




char* _Nonnull strerror_l(int __errno_value, locale_t _Nonnull __l) __asm__("strerror");
# 157 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 3 4
char* _Nonnull strerror_r(int __errno_value, char* _Nullable __buf, size_t __n) __asm__("__gnu_strerror_r") __attribute__((__availability__(android,strict,introduced=23 )));
# 190 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 3 4
const char* _Nonnull strerrordesc_np(int __errno_value) __asm__("strerror");


size_t strnlen(const char* _Nonnull __s, size_t __n) __attribute__((__pure__));
char* _Nonnull strncat(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);
char* _Nullable strndup(const char* _Nonnull __s, size_t __n);
int strncmp(const char* _Nonnull __lhs, const char* _Nonnull __rhs, size_t __n) __attribute__((__pure__));
char* _Nonnull stpncpy(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);
char* _Nonnull strncpy(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);

size_t strlcat(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);
size_t strlcpy(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);

size_t strcspn(const char* _Nonnull __s, const char* _Nonnull __reject) __attribute__((__pure__));
char* _Nullable strpbrk(const char* _Nonnull __s, const char* _Nonnull __accept) __attribute__((__pure__));
char* _Nullable strsep(char* _Nullable * _Nonnull __s_ptr, const char* _Nonnull __delimiter);
size_t strspn(const char* _Nonnull __s, const char* _Nonnull __accept);

char* _Nonnull strsignal(int __signal);

int strcoll(const char* _Nonnull __lhs, const char* _Nonnull __rhs) __attribute__((__pure__));
size_t strxfrm(char* _Null_unspecified __dst, const char* _Nonnull __src, size_t __n);

int strcoll_l(const char* _Nonnull __lhs, const char* _Nonnull __rhs, locale_t _Nonnull __l) __attribute__((__pure__));
size_t strxfrm_l(char* _Null_unspecified __dst, const char* _Nonnull __src, size_t __n, locale_t _Nonnull __l);
# 224 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 3 4
extern "C++" char* _Nonnull basename(char* _Nullable __path) __asm__("__gnu_basename") __attribute__((__availability__(android,strict,introduced=23 )));
extern "C++" const char* _Nonnull basename(const char* _Nonnull __path) __asm__("__gnu_basename") __attribute__((__availability__(android,strict,introduced=23 )));
# 247 "/data/data/com.termux/files/usr/bin/../../usr/include/string.h" 3 4
extern "C++" {
inline __attribute__((__always_inline__))
void* _Nullable __bionic_memchr(const void* _Nonnull const s , int c, size_t n) {
    return memchr(s, c, n);
}

inline __attribute__((__always_inline__))
const void* _Nullable memchr(const void* _Nonnull const s , int c, size_t n)
        __attribute__((__enable_if__(true, ""))) {
    return __bionic_memchr(s, c, n);
}

inline __attribute__((__always_inline__))
void* _Nullable memchr(void* _Nonnull const s , int c, size_t n) __attribute__((__enable_if__(true, ""))) {
    return __bionic_memchr(s, c, n);
}

inline __attribute__((__always_inline__))
char* _Nullable __bionic_strchr(const char* _Nonnull const s , int c) {
    return strchr(s, c);
}

inline __attribute__((__always_inline__))
const char* _Nullable strchr(const char* _Nonnull const s , int c)
        __attribute__((__enable_if__(true, ""))) {
    return __bionic_strchr(s, c);
}

inline __attribute__((__always_inline__))
char* _Nullable strchr(char* _Nonnull const s , int c)
        __attribute__((__enable_if__(true, ""))) {
    return __bionic_strchr(s, c);
}

inline __attribute__((__always_inline__))
char* _Nullable __bionic_strrchr(const char* _Nonnull const s , int c) {
    return strrchr(s, c);
}

inline __attribute__((__always_inline__))
const char* _Nullable strrchr(const char* _Nonnull const s , int c) __attribute__((__enable_if__(true, ""))) {
    return __bionic_strrchr(s, c);
}

inline __attribute__((__always_inline__))
char* _Nullable strrchr(char* _Nonnull const s , int c) __attribute__((__enable_if__(true, ""))) {
    return __bionic_strrchr(s, c);
}


inline __attribute__((__always_inline__))
char* _Nullable __bionic_strstr(const char* _Nonnull h, const char* _Nonnull n) { return strstr(h, n); }

inline __attribute__((__always_inline__))
const char* _Nullable strstr(const char* _Nonnull h, const char* _Nonnull n) __attribute__((__enable_if__(true, ""))) {
    return __bionic_strstr(h, n);
}

inline __attribute__((__always_inline__))
char* _Nullable strstr(char* _Nonnull h, const char* _Nonnull n) __attribute__((__enable_if__(true, ""))) {
    return __bionic_strstr(h, n);
}

inline __attribute__((__always_inline__))
char* _Nullable __bionic_strpbrk(const char* _Nonnull h, const char* _Nonnull n) { return strpbrk(h, n); }

inline __attribute__((__always_inline__))
char* _Nullable strpbrk(char* _Nonnull h, const char* _Nonnull n) __attribute__((__enable_if__(true, ""))) {
    return __bionic_strpbrk(h, n);
}

inline __attribute__((__always_inline__))
const char* _Nullable strpbrk(const char* _Nonnull h, const char* _Nonnull n) __attribute__((__enable_if__(true, ""))) {
    return __bionic_strpbrk(h, n);
}
}



}
# 62 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string.h" 2 3
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/fcntl.h" 1 3 4
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/fcntl.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/fcntl.h" 1 3 4








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/flock64.h" 1 3 4
# 10 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/fcntl.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/flock.h" 1 3 4
# 39 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/flock.h" 3 4
extern "C" {
# 60 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/flock.h" 3 4
struct flock { short l_type; short l_whence; off64_t l_start; off64_t l_len; pid_t l_pid; };
struct flock64 { short l_type; short l_whence; off64_t l_start; off64_t l_len; pid_t l_pid; };




}
# 11 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/fcntl.h" 2 3 4
# 110 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/fcntl.h" 3 4
struct f_owner_ex {
  int type;
  __kernel_pid_t pid;
};
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/fcntl.h" 2 3 4
# 51 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/seek_constants.h" 1 3 4
# 53 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 2 3 4





extern "C" {

typedef off_t fpos_t;
typedef off64_t fpos64_t;

struct __sFILE;
typedef struct __sFILE FILE;


extern FILE* _Nonnull stdin __attribute__((__availability__(android,strict,introduced=23 )));
extern FILE* _Nonnull stdout __attribute__((__availability__(android,strict,introduced=23 )));
extern FILE* _Nonnull stderr __attribute__((__availability__(android,strict,introduced=23 )));
# 111 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 3 4
void clearerr(FILE* _Nonnull __fp);
int fclose(FILE* _Nonnull __fp);
__attribute__((__warn_unused_result__)) int feof(FILE* _Nonnull __fp);
__attribute__((__warn_unused_result__)) int ferror(FILE* _Nonnull __fp);
int fflush(FILE* _Nullable __fp);
__attribute__((__warn_unused_result__)) int fgetc(FILE* _Nonnull __fp);
char* _Nullable fgets(char* _Nonnull __buf, int __size, FILE* _Nonnull __fp);
int fprintf(FILE* _Nonnull __fp , const char* _Nonnull __fmt, ...) __attribute__((__format__(printf, 2, 3)));
int fputc(int __ch, FILE* _Nonnull __fp);
int fputs(const char* _Nonnull __s, FILE* _Nonnull __fp);
size_t fread(void* _Nonnull __buf, size_t __size, size_t __count, FILE* _Nonnull __fp);
int fscanf(FILE* _Nonnull __fp, const char* _Nonnull __fmt, ...) __attribute__((__format__(scanf, 2, 3)));
size_t fwrite(const void* _Nonnull __buf, size_t __size, size_t __count, FILE* _Nonnull __fp);
__attribute__((__warn_unused_result__)) int getc(FILE* _Nonnull __fp);
__attribute__((__warn_unused_result__)) int getchar(void);
ssize_t getdelim(char* _Nullable * _Nonnull __line_ptr, size_t* _Nonnull __line_length_ptr, int __delimiter, FILE* _Nonnull __fp);
ssize_t getline(char* _Nullable * _Nonnull __line_ptr, size_t* _Nonnull __line_length_ptr, FILE* _Nonnull __fp);

void perror(const char* _Nullable __msg);
int printf(const char* _Nonnull __fmt, ...) __attribute__((__format__(printf, 1, 2)));
int putc(int __ch, FILE* _Nonnull __fp);
int putchar(int __ch);
int puts(const char* _Nonnull __s);
int remove(const char* _Nonnull __path);
void rewind(FILE* _Nonnull __fp);
int scanf(const char* _Nonnull __fmt, ...) __attribute__((__format__(scanf, 1, 2)));
void setbuf(FILE* _Nonnull __fp, char* _Nullable __buf);
int setvbuf(FILE* _Nonnull __fp, char* _Nullable __buf, int __mode, size_t __size);
int sscanf(const char* _Nonnull __s, const char* _Nonnull __fmt, ...) __attribute__((__format__(scanf, 2, 3)));
int ungetc(int __ch, FILE* _Nonnull __fp);
int vfprintf(FILE* _Nonnull __fp, const char* _Nonnull __fmt, va_list __args) __attribute__((__format__(printf, 2, 0)));
int vprintf(const char* _Nonnull __fp, va_list __args) __attribute__((__format__(printf, 1, 0)));

int dprintf(int __fd, const char* _Nonnull __fmt, ...) __attribute__((__format__(printf, 2, 3)));
int vdprintf(int __fd, const char* _Nonnull __fmt, va_list __args) __attribute__((__format__(printf, 2, 0)));





int sprintf(char* _Null_unspecified __s, const char* _Nonnull __fmt, ...)
    __attribute__((__format__(printf, 2, 3))) ;
int vsprintf(char* _Null_unspecified __s, const char* _Nonnull __fmt, va_list __args)
    __attribute__((__format__(printf, 2, 0))) ;
char* _Nullable tmpnam(char* _Nullable __s)
    __attribute__((__deprecated__("tmpnam is unsafe, use mkstemp or tmpfile instead")));

char* _Nullable tempnam(const char* _Nullable __dir, const char* _Nullable __prefix)
    __attribute__((__deprecated__("tempnam is unsafe, use mkstemp or tmpfile instead")));







int rename(const char* _Nonnull __old_path, const char* _Nonnull __new_path);







int renameat(int __old_dir_fd, const char* _Nonnull __old_path, int __new_dir_fd, const char* _Nonnull __new_path);
# 212 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 3 4
int fseek(FILE* _Nonnull __fp, long __offset, int __whence);
__attribute__((__warn_unused_result__)) long ftell(FILE* _Nonnull __fp);
# 238 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 3 4
int fgetpos(FILE* _Nonnull __fp, fpos_t* _Nonnull __pos);
int fsetpos(FILE* _Nonnull __fp, const fpos_t* _Nonnull __pos);
int fseeko(FILE* _Nonnull __fp, off_t __offset, int __whence);
__attribute__((__warn_unused_result__)) off_t ftello(FILE* _Nonnull __fp);


__attribute__((__warn_unused_result__)) FILE* _Nullable funopen(const void* _Nullable __cookie,
              int (* _Null_unspecified __read_fn)(void* _Nonnull, char* _Nonnull, int),
              int (* _Null_unspecified __write_fn)(void* _Nonnull, const char* _Nonnull, int),
              fpos_t (* _Nullable __seek_fn)(void* _Nonnull, fpos_t, int),
              int (* _Nullable __close_fn)(void* _Nonnull));




int fgetpos64(FILE* _Nonnull __fp, fpos64_t* _Nonnull __pos) __attribute__((__availability__(android,strict,introduced=24 )));
int fsetpos64(FILE* _Nonnull __fp, const fpos64_t* _Nonnull __pos) __attribute__((__availability__(android,strict,introduced=24 )));
int fseeko64(FILE* _Nonnull __fp, off64_t __offset, int __whence) __attribute__((__availability__(android,strict,introduced=24 )));
__attribute__((__warn_unused_result__)) off64_t ftello64(FILE* _Nonnull __fp) __attribute__((__availability__(android,strict,introduced=24 )));






__attribute__((__warn_unused_result__)) FILE* _Nullable funopen64(const void* _Nullable __cookie,
                int (* _Null_unspecified __read_fn)(void* _Nonnull, char* _Nonnull, int),
                int (* _Null_unspecified __write_fn)(void* _Nonnull, const char* _Nonnull, int),
                fpos64_t (* _Nullable __seek_fn)(void* _Nonnull, fpos64_t, int),
                int (* _Nullable __close_fn)(void* _Nonnull)) __attribute__((__availability__(android,strict,introduced=24 )));




__attribute__((__warn_unused_result__)) FILE* _Nullable fopen(const char* _Nonnull __path, const char* _Nonnull __mode);


__attribute__((__warn_unused_result__)) FILE* _Nullable fopen64(const char* _Nonnull __path, const char* _Nonnull __mode) __attribute__((__availability__(android,strict,introduced=24 )));


FILE* _Nullable freopen(const char* _Nullable __path, const char* _Nonnull __mode, FILE* _Nonnull __fp);


FILE* _Nullable freopen64(const char* _Nullable __path, const char* _Nonnull __mode, FILE* _Nonnull __fp) __attribute__((__availability__(android,strict,introduced=24 )));



__attribute__((__warn_unused_result__)) FILE* _Nullable tmpfile64(void) __attribute__((__availability__(android,strict,introduced=24 )));



int snprintf(char* _Null_unspecified __buf, size_t __size, const char* _Nonnull __fmt, ...) __attribute__((__format__(printf, 3, 4)));
int vfscanf(FILE* _Nonnull __fp, const char* _Nonnull __fmt, va_list __args) __attribute__((__format__(scanf, 2, 0)));
int vscanf(const char* _Nonnull __fmt , va_list __args) __attribute__((__format__(scanf, 1, 0)));
int vsnprintf(char* _Null_unspecified __buf, size_t __size, const char* _Nonnull __fmt, va_list __args) __attribute__((__format__(printf, 3, 0)));
int vsscanf(const char* _Nonnull __s, const char* _Nonnull __fmt, va_list __args) __attribute__((__format__(scanf, 2, 0)));
# 302 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 3 4
static __inline__ char* _Nonnull ctermid(char* _Nullable s) {
 if (s == 0) return (char*) "/dev/tty";
 strcpy(s, "/dev/tty");
 return s;
}



__attribute__((__warn_unused_result__)) FILE* _Nullable fdopen(int __fd, const char* _Nonnull __mode);
__attribute__((__warn_unused_result__)) int fileno(FILE* _Nonnull __fp);
int pclose(FILE* _Nonnull __fp);
__attribute__((__warn_unused_result__)) FILE* _Nullable popen(const char* _Nonnull __command, const char* _Nonnull __mode);
void flockfile(FILE* _Nonnull __fp);
int ftrylockfile(FILE* _Nonnull __fp);
void funlockfile(FILE* _Nonnull __fp);
__attribute__((__warn_unused_result__)) int getc_unlocked(FILE* _Nonnull __fp);
__attribute__((__warn_unused_result__)) int getchar_unlocked(void);
int putc_unlocked(int __ch, FILE* _Nonnull __fp);
int putchar_unlocked(int __ch);



__attribute__((__warn_unused_result__)) FILE* _Nullable fmemopen(void* _Nullable __buf, size_t __size, const char* _Nonnull __mode) __attribute__((__availability__(android,strict,introduced=23 )));
__attribute__((__warn_unused_result__)) FILE* _Nullable open_memstream(char* _Nonnull * _Nonnull __ptr, size_t* _Nonnull __size_ptr) __attribute__((__availability__(android,strict,introduced=23 )));




int asprintf(char* _Nullable * _Nonnull __s_ptr, const char* _Nonnull __fmt, ...) __attribute__((__format__(printf, 2, 3)));
char* _Nullable fgetln(FILE* _Nonnull __fp, size_t* _Nonnull __length_ptr);
int fpurge(FILE* _Nonnull __fp);
void setbuffer(FILE* _Nonnull __fp, char* _Nullable __buf, int __size);
int setlinebuf(FILE* _Nonnull __fp);
int vasprintf(char* _Nullable * _Nonnull __s_ptr, const char* _Nonnull __fmt, va_list __args) __attribute__((__format__(printf, 2, 0)));


void clearerr_unlocked(FILE* _Nonnull __fp) __attribute__((__availability__(android,strict,introduced=23 )));
__attribute__((__warn_unused_result__)) int feof_unlocked(FILE* _Nonnull __fp) __attribute__((__availability__(android,strict,introduced=23 )));
__attribute__((__warn_unused_result__)) int ferror_unlocked(FILE* _Nonnull __fp) __attribute__((__availability__(android,strict,introduced=23 )));




__attribute__((__warn_unused_result__)) int fileno_unlocked(FILE* _Nonnull __fp) __attribute__((__availability__(android,strict,introduced=24 )));
# 377 "/data/data/com.termux/files/usr/bin/../../usr/include/stdio.h" 3 4
int open(const char*, int, ...);
extern pid_t getpid();
extern int unlink(const char*);
void free(void* p);
uint32_t arc4random(void);
static __inline__ FILE* _Nullable tmpfile() {
 int p = getpid();
 char* path;
 int i;
 for (i = 0; i < 100; i++) {
  unsigned int r = arc4random();
  if (asprintf(&path, "/data/data/com.termux/files/usr/tmp/tmpfile.%d-%u", p, r) == -1) return __null;
  int fd = open(path, 00000002 | 00000100 | 00000200 | 0400000, 0600);
  if (fd >= 0) {
   FILE* result = fdopen(fd, "w+");
   unlink(path);
   free(path);
   return result;
  }
  free(path);
 }
 return __null;
}

}
# 109 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdio.h" 2 3
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 2 3 4

extern "C" {
# 58 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 3 4
__attribute__((__warn_unused_result__)) void* _Nullable malloc(size_t __byte_count) __attribute__((__malloc__)) __attribute__((__alloc_size__(1)));
# 67 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 3 4
__attribute__((__warn_unused_result__)) void* _Nullable calloc(size_t __item_count, size_t __item_size) __attribute__((__malloc__)) __attribute__((__alloc_size__(1,2)));
# 77 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 3 4
__attribute__((__warn_unused_result__)) void* _Nullable realloc(void* _Nullable __ptr, size_t __byte_count) __attribute__((__alloc_size__(2)));
# 108 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 3 4
void free(void* _Nullable __ptr);
# 119 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 3 4
__attribute__((__warn_unused_result__)) void* _Nullable memalign(size_t __alignment, size_t __byte_count) __attribute__((__malloc__)) __attribute__((__alloc_size__(2)));





__attribute__((__warn_unused_result__)) size_t malloc_usable_size(const void* _Nullable __ptr);
# 151 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 3 4
struct mallinfo { size_t arena; size_t ordblks; size_t smblks; size_t hblks; size_t hblkhd; size_t usmblks; size_t fsmblks; size_t uordblks; size_t fordblks; size_t keepcost; };







struct mallinfo mallinfo(void);




struct mallinfo2 { size_t arena; size_t ordblks; size_t smblks; size_t hblks; size_t hblkhd; size_t usmblks; size_t fsmblks; size_t uordblks; size_t fordblks; size_t keepcost; };






struct mallinfo2 mallinfo2(void) __asm__("mallinfo");
# 200 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 3 4
int malloc_info(int __must_be_zero, FILE* _Nonnull __fp) __attribute__((__availability__(android,strict,introduced=23 )));
# 329 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 3 4
enum HeapTaggingLevel {




  M_HEAP_TAGGING_LEVEL_NONE = 0,






  M_HEAP_TAGGING_LEVEL_TBI = 1,





  M_HEAP_TAGGING_LEVEL_ASYNC = 2,





  M_HEAP_TAGGING_LEVEL_SYNC = 3,

};
# 429 "/data/data/com.termux/files/usr/bin/../../usr/include/malloc.h" 3 4
}
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3 4
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 2 3 4





extern "C" {




__attribute__((__noreturn__)) void abort(void) __attribute__((__nomerge__));
__attribute__((__noreturn__)) void exit(int __status);
__attribute__((__noreturn__)) void _Exit(int __status);

int atexit(void (* _Nonnull __fn)(void));

int at_quick_exit(void (* _Nonnull __fn)(void));
void quick_exit(int __status) __attribute__((__noreturn__));

char* _Nullable getenv(const char* _Nonnull __name);
int putenv(char* _Nonnull __assignment);
int setenv(const char* _Nonnull __name, const char* _Nonnull __value, int __overwrite);
int unsetenv(const char* _Nonnull __name);
int clearenv(void);

char* _Nullable mkdtemp(char* _Nonnull __template);
char* _Nullable mktemp(char* _Nonnull __template) __attribute__((__deprecated__("mktemp is unsafe, use mkstemp or tmpfile instead")));



int mkostemp64(char* _Nonnull __template, int __flags) __attribute__((__availability__(android,strict,introduced=23 )));
int mkostemp(char* _Nonnull __template, int __flags) __attribute__((__availability__(android,strict,introduced=23 )));
int mkostemps64(char* _Nonnull __template, int __suffix_length, int __flags) __attribute__((__availability__(android,strict,introduced=23 )));
int mkostemps(char* _Nonnull __template, int __suffix_length, int __flags) __attribute__((__availability__(android,strict,introduced=23 )));


int mkstemp64(char* _Nonnull __template);
int mkstemp(char* _Nonnull __template);


int mkstemps64(char* _Nonnull __template, int __flags) __attribute__((__availability__(android,strict,introduced=23 )));


int mkstemps(char* _Nonnull __template, int __flags);

int posix_memalign(void* _Nullable * _Nullable __memptr, size_t __alignment, size_t __size);
# 100 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
__attribute__((__warn_unused_result__)) char* _Nullable realpath(const char* _Nonnull __path, char* _Nullable __resolved);
# 117 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
int system(const char* _Nonnull __command);
# 126 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
__attribute__((__warn_unused_result__)) void* _Nullable bsearch(const void* _Nonnull __key, const void* _Nullable __base, size_t __nmemb, size_t __size, int (* _Nonnull __comparator)(const void* _Nonnull __lhs, const void* _Nonnull __rhs));





void qsort(void* _Nullable __array, size_t __n, size_t __size, int (* _Nonnull __comparator)(const void* _Nullable __lhs, const void* _Nullable __rhs));
# 147 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
uint32_t arc4random(void);
uint32_t arc4random_uniform(uint32_t __upper_bound);
void arc4random_buf(void* _Nonnull __buf, size_t __n);



int rand_r(unsigned int* _Nonnull __seed_ptr);

double drand48(void);
double erand48(unsigned short __xsubi[_Nonnull 3]);
long jrand48(unsigned short __xsubi[_Nonnull 3]);


void lcong48(unsigned short __param[_Nonnull 7]) __attribute__((__availability__(android,strict,introduced=23 )));


long lrand48(void);
long mrand48(void);
long nrand48(unsigned short __xsubi[_Nonnull 3]);
unsigned short* _Nonnull seed48(unsigned short __seed16v[_Nonnull 3]);
void srand48(long __seed);

char* _Nullable initstate(unsigned int __seed, char* _Nonnull __state, size_t __n);
char* _Nullable setstate(char* _Nonnull __state);

int getpt(void);
int posix_openpt(int __flags);
char* _Nullable ptsname(int __fd);
int ptsname_r(int __fd, char* _Nonnull __buf, size_t __n);
int unlockpt(int __fd);







typedef struct {
  int quot;
  int rem;
} div_t;

div_t div(int __numerator, int __denominator) __attribute__((__const__));

typedef struct {
  long int quot;
  long int rem;
} ldiv_t;

ldiv_t ldiv(long __numerator, long __denominator) __attribute__((__const__));

typedef struct {
  long long int quot;
  long long int rem;
} lldiv_t;

lldiv_t lldiv(long long __numerator, long long __denominator) __attribute__((__const__));
# 219 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
const char* _Nullable getprogname(void);
void setprogname(const char* _Nonnull __name);


int mblen(const char* _Nullable __s, size_t __n);

size_t mbstowcs(wchar_t* _Nullable __dst, const char* _Nullable __src, size_t __n);
int mbtowc(wchar_t* _Nullable __wc_ptr, const char* _Nullable __s, size_t __n);
int wctomb(char* _Nullable __dst, wchar_t __wc);

size_t wcstombs(char* _Nullable __dst, const wchar_t* _Nullable __src, size_t __n);







int abs(int __x) __attribute__((__const__));
long labs(long __x) __attribute__((__const__));
long long llabs(long long __x) __attribute__((__const__));

int rand(void);
void srand(unsigned int __seed);
long random(void);
void srandom(unsigned int __seed);
int grantpt(int __fd);







double atof(const char* _Nonnull __s) __attribute__((__pure__));







int atoi(const char* _Nonnull __s) __attribute__((__pure__));







long atol(const char* _Nonnull __s) __attribute__((__pure__));







long long atoll(const char* _Nonnull __s) __attribute__((__pure__));
# 287 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
long strtol(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);


long strtol_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int, locale_t _Nonnull __l) __asm__("strtol");
# 300 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
long long strtoll(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);


long long strtoll_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
# 313 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
unsigned long strtoul(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);


unsigned long strtoul_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __asm__("strtoul");
# 326 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
unsigned long long strtoull(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);


unsigned long long strtoull_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
# 339 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
float strtof(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr);
# 349 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
double strtod(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr);
# 359 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
long double strtold(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr);


long double strtold_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l);
# 373 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 3 4
}

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/android/legacy_stdlib_inlines.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/android/legacy_stdlib_inlines.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/stdlib_inlines.h" 1 3 4
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/stdlib_inlines.h" 3 4
extern "C" {

static __inline__ double strtod_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) {
  return strtod(__s, __end_ptr);
}

static __inline__ float strtof_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) {
  return strtof(__s, __end_ptr);
}

}
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/android/legacy_stdlib_inlines.h" 2 3 4
# 376 "/data/data/com.termux/files/usr/bin/../../usr/include/stdlib.h" 2 3 4
# 95 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdlib.h" 2 3



extern "C++" {
# 114 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdlib.h" 3
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long abs(long __x) noexcept { return __builtin_labs(__x); }
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long long abs(long long __x) noexcept {
  return __builtin_llabs(__x);
}


[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) float abs(float __lcpp_x) noexcept {
  return __builtin_fabsf(__lcpp_x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) double abs(double __lcpp_x) noexcept {
  return __builtin_fabs(__lcpp_x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long double abs(long double __lcpp_x) noexcept {
  return __builtin_fabsl(__lcpp_x);
}
# 147 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdlib.h" 3
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) ldiv_t div(long __x, long __y) noexcept { return ::ldiv(__x, __y); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) lldiv_t div(long long __x, long long __y) noexcept { return ::lldiv(__x, __y); }


}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale_dir/locale_base_api/android.h" 2 3



}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale_dir/locale_base_api.h" 2 3
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale_dir/locale_base_api.h" 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/binary_function.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/binary_function.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/binary_function.h" 3
template <class _Arg1, class _Arg2, class _Result>
struct __binary_function_keep_layout_base {





};
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/binary_function.h" 3
template <class _Arg1, class _Arg2, class _Result>
using __binary_function = __binary_function_keep_layout_base<_Arg1, _Arg2, _Result>;


}}
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/operations.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/operations.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/unary_function.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/unary_function.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/unary_function.h" 3
template <class _Arg, class _Result>
struct __unary_function_keep_layout_base {




};
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/unary_function.h" 3
template <class _Arg, class _Result>
using __unary_function = __unary_function_keep_layout_base<_Arg, _Result>;


}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/operations.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/operations.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




template <class _Tp = void>



struct plus : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x + __y;
  }
};
template <class... _Tag> [[maybe_unused]] plus(typename _Tag::__allow_ctad...)->plus<_Tag...>;



template <class _Tp>
struct __desugars_to<__plus_tag, plus<_Tp>, _Tp, _Tp> : true_type {};

template <class _Tp, class _Up>
struct __desugars_to<__plus_tag, plus<void>, _Tp, _Up> : true_type {};


template <>
struct plus<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) + std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) + std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) + std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct minus : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x - __y;
  }
};
template <class... _Tag> [[maybe_unused]] minus(typename _Tag::__allow_ctad...)->minus<_Tag...>;


template <>
struct minus<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) - std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) - std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) - std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct multiplies : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x * __y;
  }
};
template <class... _Tag> [[maybe_unused]] multiplies(typename _Tag::__allow_ctad...)->multiplies<_Tag...>;


template <>
struct multiplies<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) * std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) * std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) * std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct divides : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x / __y;
  }
};
template <class... _Tag> [[maybe_unused]] divides(typename _Tag::__allow_ctad...)->divides<_Tag...>;


template <>
struct divides<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) / std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) / std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) / std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct modulus : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x % __y;
  }
};
template <class... _Tag> [[maybe_unused]] modulus(typename _Tag::__allow_ctad...)->modulus<_Tag...>;


template <>
struct modulus<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) % std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) % std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) % std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct negate : __unary_function<_Tp, _Tp> {
  typedef _Tp __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp operator()(const _Tp& __x) const { return -__x; }
};
template <class... _Tag> [[maybe_unused]] negate(typename _Tag::__allow_ctad...)->negate<_Tag...>;


template <>
struct negate<void> {
  template <class _Tp>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_Tp&& __x) const
      noexcept(noexcept(-std::forward<_Tp>(__x))) -> decltype(-std::forward<_Tp>(__x)) {
    return -std::forward<_Tp>(__x);
  }
  typedef void is_transparent;
};





template <class _Tp = void>



struct bit_and : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x & __y;
  }
};
template <class... _Tag> [[maybe_unused]] bit_and(typename _Tag::__allow_ctad...)->bit_and<_Tag...>;


template <>
struct bit_and<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) & std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) & std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) & std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>
struct bit_not : __unary_function<_Tp, _Tp> {
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp operator()(const _Tp& __x) const { return ~__x; }
};
template <class... _Tag> [[maybe_unused]] bit_not(typename _Tag::__allow_ctad...)->bit_not<_Tag...>;

template <>
struct bit_not<void> {
  template <class _Tp>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_Tp&& __x) const
      noexcept(noexcept(~std::forward<_Tp>(__x))) -> decltype(~std::forward<_Tp>(__x)) {
    return ~std::forward<_Tp>(__x);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct bit_or : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x | __y;
  }
};
template <class... _Tag> [[maybe_unused]] bit_or(typename _Tag::__allow_ctad...)->bit_or<_Tag...>;


template <>
struct bit_or<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) | std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) | std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) | std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct bit_xor : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x ^ __y;
  }
};
template <class... _Tag> [[maybe_unused]] bit_xor(typename _Tag::__allow_ctad...)->bit_xor<_Tag...>;


template <>
struct bit_xor<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) ^ std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) ^ std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) ^ std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};





template <class _Tp = void>



struct equal_to : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x == __y;
  }
};
template <class... _Tag> [[maybe_unused]] equal_to(typename _Tag::__allow_ctad...)->equal_to<_Tag...>;


template <>
struct equal_to<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) == std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) == std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) == std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};




template <class _Tp>
struct __desugars_to<__equal_tag, equal_to<_Tp>, _Tp, _Tp> : true_type {};


template <class _Tp, class _Up>
struct __desugars_to<__equal_tag, equal_to<void>, _Tp, _Up> : true_type {};


template <class _Tp = void>



struct not_equal_to : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x != __y;
  }
};
template <class... _Tag> [[maybe_unused]] not_equal_to(typename _Tag::__allow_ctad...)->not_equal_to<_Tag...>;


template <>
struct not_equal_to<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) != std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) != std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) != std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct less : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x < __y;
  }
};
template <class... _Tag> [[maybe_unused]] less(typename _Tag::__allow_ctad...)->less<_Tag...>;


template <>
struct less<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) < std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) < std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) < std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct less_equal : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x <= __y;
  }
};
template <class... _Tag> [[maybe_unused]] less_equal(typename _Tag::__allow_ctad...)->less_equal<_Tag...>;


template <>
struct less_equal<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) <= std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) <= std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) <= std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct greater_equal : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x >= __y;
  }
};
template <class... _Tag> [[maybe_unused]] greater_equal(typename _Tag::__allow_ctad...)->greater_equal<_Tag...>;


template <>
struct greater_equal<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) >= std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) >= std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) >= std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct greater : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x > __y;
  }
};
template <class... _Tag> [[maybe_unused]] greater(typename _Tag::__allow_ctad...)->greater<_Tag...>;


template <>
struct greater<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) > std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) > std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) > std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};





template <class _Tp = void>



struct logical_and : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x && __y;
  }
};
template <class... _Tag> [[maybe_unused]] logical_and(typename _Tag::__allow_ctad...)->logical_and<_Tag...>;


template <>
struct logical_and<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) && std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) && std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) && std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct logical_not : __unary_function<_Tp, bool> {
  typedef bool __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const _Tp& __x) const { return !__x; }
};
template <class... _Tag> [[maybe_unused]] logical_not(typename _Tag::__allow_ctad...)->logical_not<_Tag...>;


template <>
struct logical_not<void> {
  template <class _Tp>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_Tp&& __x) const
      noexcept(noexcept(!std::forward<_Tp>(__x))) -> decltype(!std::forward<_Tp>(__x)) {
    return !std::forward<_Tp>(__x);
  }
  typedef void is_transparent;
};



template <class _Tp = void>



struct logical_or : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x || __y;
  }
};
template <class... _Tag> [[maybe_unused]] logical_or(typename _Tag::__allow_ctad...)->logical_or<_Tag...>;


template <>
struct logical_or<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) auto operator()(_T1&& __t, _T2&& __u) const
      noexcept(noexcept(std::forward<_T1>(__t) || std::forward<_T2>(__u)))
          -> decltype(std::forward<_T1>(__t) || std::forward<_T2>(__u)) {
    return std::forward<_T1>(__t) || std::forward<_T2>(__u);
  }
  typedef void is_transparent;
};


}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/reference_wrapper.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/reference_wrapper.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/weak_result_type.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/weak_result_type.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __has_result_type {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type __test(typename _Up::result_type* = 0);

public:
  static const bool value = decltype(__test<_Tp>(0))::value;
};



template <class _Tp>
struct __derives_from_unary_function {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  static __two __test(...);
  template <class _Ap, class _Rp>
  static __unary_function<_Ap, _Rp> __test(const volatile __unary_function<_Ap, _Rp>*);

public:
  static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
  typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  static __two __test(...);
  template <class _A1, class _A2, class _Rp>
  static __binary_function<_A1, _A2, _Rp> __test(const volatile __binary_function<_A1, _A2, _Rp>*);

public:
  static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
  typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type {};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false> {};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type {};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false> {};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp> {



};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>, public __maybe_derive_from_binary_function<_Tp> {};

template <class _Tp>
struct __weak_result_type : public __weak_result_type_imp<_Tp> {};



template <class _Rp>
struct __weak_result_type<_Rp()> {



};

template <class _Rp>
struct __weak_result_type<_Rp (&)()> {



};

template <class _Rp>
struct __weak_result_type<_Rp (*)()> {



};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp(_A1)> : public __unary_function<_A1, _Rp> {};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)> : public __unary_function<_A1, _Rp> {};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)> : public __unary_function<_A1, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()> : public __unary_function<_Cp*, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const> : public __unary_function<const _Cp*, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile> : public __unary_function<volatile _Cp*, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile> : public __unary_function<const volatile _Cp*, _Rp> {};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp(_A1, _A2)> : public __binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)> : public __binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)> : public __binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)> : public __binary_function<_Cp*, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const> : public __binary_function<const _Cp*, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile> : public __binary_function<volatile _Cp*, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile> : public __binary_function<const volatile _Cp*, _A1, _Rp> {
};



template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp(_A1, _A2, _A3, _A4...)> {



};

template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)> {



};

template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)> {



};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)> {



};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const> {



};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile> {



};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile> {



};

template <class _Tp, class... _Args>
struct __invoke_return {
  typedef decltype(std::__invoke(std::declval<_Tp>(), std::declval<_Args>()...)) type;
};

}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/reference_wrapper.h" 2 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/reference_wrapper.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
class reference_wrapper : public __weak_result_type<_Tp> {
public:

  typedef _Tp type;

private:
  type* __f_;

  static void __fun(_Tp&) noexcept;
  static void __fun(_Tp&&) = delete;

public:
  template <class _Up,
            class = __void_t<decltype(__fun(std::declval<_Up>()))>,
            __enable_if_t<!__is_same_uncvref<_Up, reference_wrapper>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference_wrapper(_Up&& __u)
      noexcept(noexcept(__fun(std::declval<_Up>()))) {
    type& __f = static_cast<_Up&&>(__u);
    __f_ = std::addressof(__f);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator type&() const noexcept { return *__f_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr type& get() const noexcept { return *__f_; }


  template <class... _ArgTypes>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename __invoke_of<type&, _ArgTypes...>::type
  operator()(_ArgTypes&&... __args) const



      noexcept(is_nothrow_invocable_v<_Tp&, _ArgTypes...>)

  {
    return std::__invoke(get(), std::forward<_ArgTypes>(__args)...);
  }
};


template <class _Tp>
reference_wrapper(_Tp&) -> reference_wrapper<_Tp>;


template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference_wrapper<_Tp> ref(_Tp& __t) noexcept {
  return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept {
  return __t;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference_wrapper<const _Tp> cref(const _Tp& __t) noexcept {
  return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept {
  return __t;
}

template <class _Tp>
void ref(const _Tp&&) = delete;
template <class _Tp>
void cref(const _Tp&&) = delete;

}}
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/ostream.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/ostream.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ostream;

using ostream = basic_ostream<char>;


using wostream = basic_ostream<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ostream))) __attribute__((__preferred_name__(wostream))) basic_ostream;

}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocation_guard.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocation_guard.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 1 3
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 44 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
template <class _Tp, class = void> struct __has_pointer : false_type {}; template <class _Tp> struct __has_pointer<_Tp, __void_t<typename _Tp::pointer > > : true_type {};
template <class _Tp,
          class _Alloc,
          class _RawAlloc = __libcpp_remove_reference_t<_Alloc>,
          bool = __has_pointer<_RawAlloc>::value>
struct __pointer {
  using type __attribute__((__nodebug__)) = typename _RawAlloc::pointer;
};
template <class _Tp, class _Alloc, class _RawAlloc>
struct __pointer<_Tp, _Alloc, _RawAlloc, false> {
  using type __attribute__((__nodebug__)) = _Tp*;
};


template <class _Tp, class = void> struct __has_const_pointer : false_type {}; template <class _Tp> struct __has_const_pointer<_Tp, __void_t<typename _Tp::const_pointer > > : true_type {};
template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer {
  using type __attribute__((__nodebug__)) = typename _Alloc::const_pointer;
};
template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false> {



  using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::template rebind<const _Tp>;

};


template <class _Tp, class = void> struct __has_void_pointer : false_type {}; template <class _Tp> struct __has_void_pointer<_Tp, __void_t<typename _Tp::void_pointer > > : true_type {};
template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer {
  using type __attribute__((__nodebug__)) = typename _Alloc::void_pointer;
};
template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false> {



  using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::template rebind<void>;

};


template <class _Tp, class = void> struct __has_const_void_pointer : false_type {}; template <class _Tp> struct __has_const_void_pointer<_Tp, __void_t<typename _Tp::const_void_pointer > > : true_type {};
template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer {
  using type __attribute__((__nodebug__)) = typename _Alloc::const_void_pointer;
};
template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false> {



  using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::template rebind<const void>;

};


template <class _Tp, class = void> struct __has_size_type : false_type {}; template <class _Tp> struct __has_size_type<_Tp, __void_t<typename _Tp::size_type > > : true_type {};
template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type : make_unsigned<_DiffType> {};
template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::size_type;
};


template <class _Tp, class = void> struct __has_alloc_traits_difference_type : false_type {}; template <class _Tp> struct __has_alloc_traits_difference_type<_Tp, __void_t<typename _Tp::difference_type > > : true_type {};
template <class _Alloc, class _Ptr, bool = __has_alloc_traits_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type {
  using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::difference_type;
};
template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::difference_type;
};


template <class _Tp, class = void> struct __has_propagate_on_container_copy_assignment : false_type {}; template <class _Tp> struct __has_propagate_on_container_copy_assignment<_Tp, __void_t<typename _Tp::propagate_on_container_copy_assignment > > : true_type {};
template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment : false_type {};
template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_copy_assignment;
};


template <class _Tp, class = void> struct __has_propagate_on_container_move_assignment : false_type {}; template <class _Tp> struct __has_propagate_on_container_move_assignment<_Tp, __void_t<typename _Tp::propagate_on_container_move_assignment > > : true_type {};
template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment : false_type {};
template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_move_assignment;
};


template <class _Tp, class = void> struct __has_propagate_on_container_swap : false_type {}; template <class _Tp> struct __has_propagate_on_container_swap<_Tp, __void_t<typename _Tp::propagate_on_container_swap > > : true_type {};
template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap : false_type {};
template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_swap;
};


template <class _Tp, class = void> struct __has_is_always_equal : false_type {}; template <class _Tp> struct __has_is_always_equal<_Tp, __void_t<typename _Tp::is_always_equal > > : true_type {};
template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal : is_empty<_Alloc> {};
template <class _Alloc>
struct __is_always_equal<_Alloc, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::is_always_equal;
};


#pragma GCC diagnostic push
# 159 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 159 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _Up, class = void>
struct __has_rebind_other : false_type {};
template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>::other> > : true_type {};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind {
  static_assert(__has_rebind_other<_Tp, _Up>::value, "This allocator has to implement rebind");
  using type __attribute__((__nodebug__)) = typename _Tp::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class... _Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class... _Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false> {
  using type __attribute__((__nodebug__)) = _Alloc<_Up, _Args...>;
};
#pragma GCC diagnostic pop

template <class _Alloc, class _Tp>
using __allocator_traits_rebind_t = typename __allocator_traits_rebind<_Alloc, _Tp>::type;

#pragma GCC diagnostic push
# 183 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 183 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


template <class _Alloc, class _SizeType, class _ConstVoidPtr, class = void>
struct __has_allocate_hint : false_type {};

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint<
    _Alloc,
    _SizeType,
    _ConstVoidPtr,
    decltype((void)std::declval<_Alloc>().allocate(std::declval<_SizeType>(), std::declval<_ConstVoidPtr>()))>
    : true_type {};


template <class, class _Alloc, class... _Args>
struct __has_construct_impl : false_type {};

template <class _Alloc, class... _Args>
struct __has_construct_impl<decltype((void)std::declval<_Alloc>().construct(std::declval<_Args>()...)),
                            _Alloc,
                            _Args...> : true_type {};

template <class _Alloc, class... _Args>
struct __has_construct : __has_construct_impl<void, _Alloc, _Args...> {};


template <class _Alloc, class _Pointer, class = void>
struct __has_destroy : false_type {};

template <class _Alloc, class _Pointer>
struct __has_destroy<_Alloc, _Pointer, decltype((void)std::declval<_Alloc>().destroy(std::declval<_Pointer>()))>
    : true_type {};


template <class _Alloc, class = void>
struct __has_max_size : false_type {};

template <class _Alloc>
struct __has_max_size<_Alloc, decltype((void)std::declval<_Alloc&>().max_size())> : true_type {};


template <class _Alloc, class = void>
struct __has_select_on_container_copy_construction : false_type {};

template <class _Alloc>
struct __has_select_on_container_copy_construction<
    _Alloc,
    decltype((void)std::declval<_Alloc>().select_on_container_copy_construction())> : true_type {};

#pragma GCC diagnostic pop



template <class _Pointer, class _SizeType = size_t>
struct allocation_result {
  _Pointer ptr;
  _SizeType count;
};
template <class... _Tag> [[maybe_unused]] allocation_result(typename _Tag::__allow_ctad...)->allocation_result<_Tag...>;



template <class _Alloc>
struct allocator_traits {
  using allocator_type = _Alloc;
  using value_type = typename allocator_type::value_type;
  using pointer = typename __pointer<value_type, allocator_type>::type;
  using const_pointer = typename __const_pointer<value_type, pointer, allocator_type>::type;
  using void_pointer = typename __void_pointer<pointer, allocator_type>::type;
  using const_void_pointer = typename __const_void_pointer<pointer, allocator_type>::type;
  using difference_type = typename __alloc_traits_difference_type<allocator_type, pointer>::type;
  using size_type = typename __size_type<allocator_type, difference_type>::type;
  using propagate_on_container_copy_assignment =
      typename __propagate_on_container_copy_assignment<allocator_type>::type;
  using propagate_on_container_move_assignment =
      typename __propagate_on_container_move_assignment<allocator_type>::type;
  using propagate_on_container_swap = typename __propagate_on_container_swap<allocator_type>::type;
  using is_always_equal = typename __is_always_equal<allocator_type>::type;


  template <class _Tp>
  using rebind_alloc = __allocator_traits_rebind_t<allocator_type, _Tp>;
  template <class _Tp>
  using rebind_traits = allocator_traits<rebind_alloc<_Tp> >;
# 279 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static pointer
  allocate(allocator_type& __a, size_type __n) {
    return __a.allocate(__n);
  }

  template <class _Ap = _Alloc, __enable_if_t<__has_allocate_hint<_Ap, size_type, const_void_pointer>::value, int> = 0>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static pointer
  allocate(allocator_type& __a, size_type __n, const_void_pointer __hint) {
#pragma GCC diagnostic push
# 287 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 287 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    return __a.allocate(__n, __hint);
#pragma GCC diagnostic pop
  }
  template <class _Ap = _Alloc,
            class = void,
            __enable_if_t<!__has_allocate_hint<_Ap, size_type, const_void_pointer>::value, int> = 0>
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static pointer
  allocate(allocator_type& __a, size_type __n, const_void_pointer) {
    return __a.allocate(__n);
  }


  template <class _Ap = _Alloc>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr allocation_result<pointer, size_type>
  allocate_at_least(_Ap& __alloc, size_type __n) {
    if constexpr (requires { __alloc.allocate_at_least(__n); }) {
      return __alloc.allocate_at_least(__n);
    } else {
      return {__alloc.allocate(__n), __n};
    }
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void
  deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept {
    __a.deallocate(__p, __n);
  }

  template <class _Tp, class... _Args, __enable_if_t<__has_construct<allocator_type, _Tp*, _Args...>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void
  construct(allocator_type& __a, _Tp* __p, _Args&&... __args) {
#pragma GCC diagnostic push
# 319 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 319 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    __a.construct(__p, std::forward<_Args>(__args)...);
#pragma GCC diagnostic pop
  }
  template <class _Tp,
            class... _Args,
            class = void,
            __enable_if_t<!__has_construct<allocator_type, _Tp*, _Args...>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void
  construct(allocator_type&, _Tp* __p, _Args&&... __args) {
    std::__construct_at(__p, std::forward<_Args>(__args)...);
  }

  template <class _Tp, __enable_if_t<__has_destroy<allocator_type, _Tp*>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void destroy(allocator_type& __a, _Tp* __p) {
#pragma GCC diagnostic push
# 334 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 334 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    __a.destroy(__p);
#pragma GCC diagnostic pop
  }
  template <class _Tp, class = void, __enable_if_t<!__has_destroy<allocator_type, _Tp*>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static void destroy(allocator_type&, _Tp* __p) {
    std::__destroy_at(__p);
  }

  template <class _Ap = _Alloc, __enable_if_t<__has_max_size<const _Ap>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static size_type max_size(const allocator_type& __a) noexcept {
#pragma GCC diagnostic push
# 345 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 345 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    return __a.max_size();
#pragma GCC diagnostic pop
  }
  template <class _Ap = _Alloc, class = void, __enable_if_t<!__has_max_size<const _Ap>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static size_type max_size(const allocator_type&) noexcept {
    return numeric_limits<size_type>::max() / sizeof(value_type);
  }

  template <class _Ap = _Alloc, __enable_if_t<__has_select_on_container_copy_construction<const _Ap>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static allocator_type
  select_on_container_copy_construction(const allocator_type& __a) {
    return __a.select_on_container_copy_construction();
  }
  template <class _Ap = _Alloc,
            class = void,
            __enable_if_t<!__has_select_on_container_copy_construction<const _Ap>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static allocator_type
  select_on_container_copy_construction(const allocator_type& __a) {
    return __a;
  }
};


template <class _Traits, class _Tp>
using __rebind_alloc __attribute__((__nodebug__)) = typename _Traits::template rebind_alloc<_Tp>;






template <class _Tp>
struct __is_default_allocator : false_type {};

template <class>
class allocator;

template <class _Tp>
struct __is_default_allocator<allocator<_Tp> > : true_type {};


template <class _Alloc, class = void>
struct __is_cpp17_move_insertable : is_move_constructible<typename _Alloc::value_type> {};

template <class _Alloc>
struct __is_cpp17_move_insertable<
    _Alloc,
    __enable_if_t< !__is_default_allocator<_Alloc>::value &&
                   __has_construct<_Alloc, typename _Alloc::value_type*, typename _Alloc::value_type&&>::value > >
    : true_type {};


template <class _Alloc, class = void>
struct __is_cpp17_copy_insertable
    : integral_constant<bool,
                        is_copy_constructible<typename _Alloc::value_type>::value &&
                            __is_cpp17_move_insertable<_Alloc>::value > {};

template <class _Alloc>
struct __is_cpp17_copy_insertable<
    _Alloc,
    __enable_if_t< !__is_default_allocator<_Alloc>::value &&
                   __has_construct<_Alloc, typename _Alloc::value_type*, const typename _Alloc::value_type&>::value > >
    : __is_cpp17_move_insertable<_Alloc> {};
# 425 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_traits.h" 3
}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocation_guard.h" 2 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocation_guard.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocation_guard.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 47 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocation_guard.h" 3
template <class _Alloc>
struct __allocation_guard {
  using _Pointer = typename allocator_traits<_Alloc>::pointer;
  using _Size = typename allocator_traits<_Alloc>::size_type;

  template <class _AllocT>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __allocation_guard(_AllocT __alloc, _Size __n)
      : __alloc_(std::move(__alloc)),
        __n_(__n),
        __ptr_(allocator_traits<_Alloc>::allocate(__alloc_, __n_))
  {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) ~__allocation_guard() noexcept { __destroy(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __allocation_guard(const __allocation_guard&) = delete;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __allocation_guard(__allocation_guard&& __other) noexcept
      : __alloc_(std::move(__other.__alloc_)),
        __n_(__other.__n_),
        __ptr_(__other.__ptr_) {
    __other.__ptr_ = nullptr;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __allocation_guard& operator=(const __allocation_guard& __other) = delete;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __allocation_guard& operator=(__allocation_guard&& __other) noexcept {
    if (std::addressof(__other) != this) {
      __destroy();

      __alloc_ = std::move(__other.__alloc_);
      __n_ = __other.__n_;
      __ptr_ = __other.__ptr_;
      __other.__ptr_ = nullptr;
    }

    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Pointer
  __release_ptr() noexcept {
    _Pointer __tmp = __ptr_;
    __ptr_ = nullptr;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Pointer __get() const noexcept { return __ptr_; }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __destroy() noexcept {
    if (__ptr_ != nullptr) {
      allocator_traits<_Alloc>::deallocate(__alloc_, __ptr_, __n_);
    }
  }

  _Alloc __alloc_;
  _Size __n_;
  _Pointer __ptr_;
};

}}
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocate_at_least.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocate_at_least.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Alloc>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto __allocate_at_least(_Alloc& __alloc, size_t __n) {
  return std::allocator_traits<_Alloc>::allocate_at_least(__alloc, __n);
}
# 46 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocate_at_least.h" 3
}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator.h" 2 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
class allocator;
# 88 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator.h" 3
template <bool _Cond, class _Unique>
struct __non_trivial_if {};

template <class _Unique>
struct __non_trivial_if<true, _Unique> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __non_trivial_if() noexcept {}
};






template <class _Tp>
class allocator : private __non_trivial_if<!is_void<_Tp>::value, allocator<_Tp> > {
  static_assert(!is_volatile<_Tp>::value, "std::allocator does not support volatile types");

public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp value_type;
  typedef true_type propagate_on_container_move_assignment;

  __attribute__((__deprecated__)) typedef true_type is_always_equal;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr allocator() noexcept = default;

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr allocator(const allocator<_Up>&) noexcept {}

  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* allocate(size_t __n) {
    if (__n > allocator_traits<allocator>::max_size(*this))
      __throw_bad_array_new_length();
    if (__libcpp_is_constant_evaluated()) {
      return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
    } else {
      return static_cast<_Tp*>(std::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
    }
  }


  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr allocation_result<_Tp*> allocate_at_least(size_t __n) {
    return {allocate(__n), __n};
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void deallocate(_Tp* __p, size_t __n) noexcept {
    if (__libcpp_is_constant_evaluated()) {
      ::operator delete(__p);
    } else {
      std::__libcpp_deallocate((void*)__p, __n * sizeof(_Tp), alignof(_Tp));
    }
  }
# 178 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator.h" 3
};

template <class _Tp>
class allocator<const _Tp>
    : private __non_trivial_if<!is_void<_Tp>::value, allocator<const _Tp> > {
  static_assert(!is_volatile<_Tp>::value, "std::allocator does not support volatile types");

public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef const _Tp value_type;
  typedef true_type propagate_on_container_move_assignment;

  __attribute__((__deprecated__)) typedef true_type is_always_equal;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr allocator() noexcept = default;

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr allocator(const allocator<_Up>&) noexcept {}

  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp* allocate(size_t __n) {
    if (__n > allocator_traits<allocator>::max_size(*this))
      __throw_bad_array_new_length();
    if (__libcpp_is_constant_evaluated()) {
      return static_cast<const _Tp*>(::operator new(__n * sizeof(_Tp)));
    } else {
      return static_cast<const _Tp*>(std::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
    }
  }


  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr allocation_result<const _Tp*> allocate_at_least(size_t __n) {
    return {allocate(__n), __n};
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void deallocate(const _Tp* __p, size_t __n) {
    if (__libcpp_is_constant_evaluated()) {
      ::operator delete(const_cast<_Tp*>(__p));
    } else {
      std::__libcpp_deallocate((void*)const_cast<_Tp*>(__p), __n * sizeof(_Tp), alignof(_Tp));
    }
  }
# 255 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator.h" 3
};

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const allocator<_Tp>&, const allocator<_Up>&) noexcept {
  return true;
}
# 272 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator.h" 3
}}
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_destructor.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_destructor.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Alloc>
class __allocator_destructor {
  typedef __attribute__((__nodebug__)) allocator_traits<_Alloc> __alloc_traits;

public:
  typedef __attribute__((__nodebug__)) typename __alloc_traits::pointer pointer;
  typedef __attribute__((__nodebug__)) typename __alloc_traits::size_type size_type;

private:
  _Alloc& __alloc_;
  size_type __s_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __allocator_destructor(_Alloc& __a, size_type __s) noexcept : __alloc_(__a), __s_(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void operator()(pointer __p) noexcept { __alloc_traits::deallocate(__alloc_, __p, __s_); }
};

}}
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/auto_ptr.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/auto_ptr.h" 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/compressed_pair.h" 1 3
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/compressed_pair.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/compressed_pair.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


struct __default_init_tag {};
struct __value_init_tag {};

template <class _Tp, int _Idx, bool _CanBeEmptyBase = is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  using _ParamT = _Tp;
  using reference = _Tp&;
  using const_reference = const _Tp&;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __compressed_pair_elem(__default_init_tag) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __compressed_pair_elem(__value_init_tag) : __value_() {}

  template <class _Up, __enable_if_t<!is_same<__compressed_pair_elem, __decay_t<_Up> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __compressed_pair_elem(_Up&& __u)
      : __value_(std::forward<_Up>(__u)) {}


  template <class... _Args, size_t... _Indices>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __compressed_pair_elem(
      piecewise_construct_t, tuple<_Args...> __args, __tuple_indices<_Indices...>)
      : __value_(std::forward<_Args>(std::get<_Indices>(__args))...) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference __get() noexcept { return __value_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference __get() const noexcept { return __value_; }

private:
  _Tp __value_;
};

template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  using _ParamT = _Tp;
  using reference = _Tp&;
  using const_reference = const _Tp&;
  using __value_type = _Tp;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __compressed_pair_elem() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __compressed_pair_elem(__default_init_tag) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __compressed_pair_elem(__value_init_tag) : __value_type() {}

  template <class _Up, __enable_if_t<!is_same<__compressed_pair_elem, __decay_t<_Up> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __compressed_pair_elem(_Up&& __u)
      : __value_type(std::forward<_Up>(__u)) {}


  template <class... _Args, size_t... _Indices>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args, __tuple_indices<_Indices...>)
      : __value_type(std::forward<_Args>(std::get<_Indices>(__args))...) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference __get() noexcept { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference __get() const noexcept { return *this; }
};

template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>, private __compressed_pair_elem<_T2, 1> {
public:




  static_assert(
      (!is_same<_T1, _T2>::value),
      "__compressed_pair cannot be instantiated when T1 and T2 are the same type; "
      "The current implementation is NOT ABI-compatible with the previous implementation for this configuration");

  using _Base1 __attribute__((__nodebug__)) = __compressed_pair_elem<_T1, 0>;
  using _Base2 __attribute__((__nodebug__)) = __compressed_pair_elem<_T2, 1>;

  template <bool _Dummy = true,
            __enable_if_t< __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
                               __dependent_type<is_default_constructible<_T2>, _Dummy>::value,
                           int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __compressed_pair()
      : _Base1(__value_init_tag()), _Base2(__value_init_tag()) {}

  template <class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __compressed_pair(_U1&& __t1, _U2&& __t2)
      : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}


  template <class... _Args1, class... _Args2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __compressed_pair(
      piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
      : _Base1(__pc, std::move(__first_args), typename __make_tuple_indices<sizeof...(_Args1)>::type()),
        _Base2(__pc, std::move(__second_args), typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename _Base1::reference first() noexcept {
    return static_cast<_Base1&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename _Base1::const_reference first() const noexcept {
    return static_cast<_Base1 const&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename _Base2::reference second() noexcept {
    return static_cast<_Base2&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename _Base2::const_reference second() const noexcept {
    return static_cast<_Base2 const&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static _Base1* __get_first_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base1*>(__pair);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static _Base2* __get_second_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base2*>(__pair);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(__compressed_pair& __x)
      noexcept(__is_nothrow_swappable<_T1>::value&& __is_nothrow_swappable<_T2>::value) {
    using std::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value&& __is_nothrow_swappable<_T2>::value) {
  __x.swap(__y);
}

}}
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy_move_common.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy_move_common.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_range.h" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_range.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_range.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {






template <class _Iter, class _Sent>
struct __unwrap_range_impl {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __unwrap(_Iter __first, _Sent __sent)
    requires random_access_iterator<_Iter> && sized_sentinel_for<_Sent, _Iter>
  {
    auto __last = ranges::next(__first, __sent);
    return pair{std::__unwrap_iter(std::move(__first)), std::__unwrap_iter(std::move(__last))};
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __unwrap(_Iter __first, _Sent __last) {
    return pair{std::move(__first), std::move(__last)};
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto
  __rewrap(_Iter __orig_iter, decltype(std::__unwrap_iter(std::move(__orig_iter))) __iter)
    requires random_access_iterator<_Iter> && sized_sentinel_for<_Sent, _Iter>
  {
    return std::__rewrap_iter(std::move(__orig_iter), std::move(__iter));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __rewrap(const _Iter&, _Iter __iter)
    requires(!(random_access_iterator<_Iter> && sized_sentinel_for<_Sent, _Iter>))
  {
    return __iter;
  }
};

template <class _Iter>
struct __unwrap_range_impl<_Iter, _Iter> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto __unwrap(_Iter __first, _Iter __last) {
    return pair{std::__unwrap_iter(std::move(__first)), std::__unwrap_iter(std::move(__last))};
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr auto
  __rewrap(_Iter __orig_iter, decltype(std::__unwrap_iter(__orig_iter)) __iter) {
    return std::__rewrap_iter(std::move(__orig_iter), std::move(__iter));
  }
};

template <class _Iter, class _Sent>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto __unwrap_range(_Iter __first, _Sent __last) {
  return __unwrap_range_impl<_Iter, _Sent>::__unwrap(std::move(__first), std::move(__last));
}

template < class _Sent, class _Iter, class _Unwrapped>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter __rewrap_range(_Iter __orig_iter, _Unwrapped __iter) {
  return __unwrap_range_impl<_Iter, _Sent>::__rewrap(std::move(__orig_iter), std::move(__iter));
}
# 95 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/unwrap_range.h" 3
}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy_move_common.h" 2 3
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy_move_common.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy_move_common.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _From, class _To>
struct __can_lower_copy_assignment_to_memmove {
  static const bool value =

      __is_always_bitcastable<_From, _To>::value &&

      is_trivially_assignable<_To&, const _From&>::value &&

      !is_volatile<_From>::value && !is_volatile<_To>::value;
};

template <class _From, class _To>
struct __can_lower_move_assignment_to_memmove {
  static const bool value =
      __is_always_bitcastable<_From, _To>::value && is_trivially_assignable<_To&, _From&&>::value &&
      !is_volatile<_From>::value && !is_volatile<_To>::value;
};



template <class _In, class _Out>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_In*, _Out*>
__copy_trivial_impl(_In* __first, _In* __last, _Out* __result) {
  const size_t __n = static_cast<size_t>(__last - __first);

  std::__constexpr_memmove(__result, __first, __element_count(__n));

  return std::make_pair(__last, __result + __n);
}

template <class _In, class _Out>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_In*, _Out*>
__copy_backward_trivial_impl(_In* __first, _In* __last, _Out* __result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  __result -= __n;

  std::__constexpr_memmove(__result, __first, __element_count(__n));

  return std::make_pair(__last, __result);
}



template <class _F1, class _F2>
struct __overload : _F1, _F2 {
  using _F1::operator();
  using _F2::operator();
};

template <class _InIter, class _Sent, class _OutIter, class = void>
struct __can_rewrap : false_type {};

template <class _InIter, class _Sent, class _OutIter>
struct __can_rewrap<_InIter,
                    _Sent,
                    _OutIter,

                    __enable_if_t< is_copy_constructible<_InIter>::value && is_copy_constructible<_OutIter>::value > >
    : true_type {};

template <class _Algorithm,
          class _InIter,
          class _Sent,
          class _OutIter,
          __enable_if_t<__can_rewrap<_InIter, _Sent, _OutIter>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter>
__unwrap_and_dispatch(_InIter __first, _Sent __last, _OutIter __out_first) {
  auto __range = std::__unwrap_range(__first, std::move(__last));
  auto __result = _Algorithm()(std::move(__range.first), std::move(__range.second), std::__unwrap_iter(__out_first));
  return std::make_pair(std::__rewrap_range<_Sent>(std::move(__first), std::move(__result.first)),
                        std::__rewrap_iter(std::move(__out_first), std::move(__result.second)));
}

template <class _Algorithm,
          class _InIter,
          class _Sent,
          class _OutIter,
          __enable_if_t<!__can_rewrap<_InIter, _Sent, _OutIter>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter>
__unwrap_and_dispatch(_InIter __first, _Sent __last, _OutIter __out_first) {
  return _Algorithm()(std::move(__first), std::move(__last), std::move(__out_first));
}

template <class _AlgPolicy,
          class _NaiveAlgorithm,
          class _OptimizedAlgorithm,
          class _InIter,
          class _Sent,
          class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter>
__dispatch_copy_or_move(_InIter __first, _Sent __last, _OutIter __out_first) {
  using _Algorithm = __overload<_NaiveAlgorithm, _OptimizedAlgorithm>;
  return std::__unwrap_and_dispatch<_Algorithm>(std::move(__first), std::move(__last), std::move(__out_first));
}

}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/for_each_segment.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/for_each_segment.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _SegmentedIterator, class _Functor>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__for_each_segment(_SegmentedIterator __first, _SegmentedIterator __last, _Functor __func) {
  using _Traits = __segmented_iterator_traits<_SegmentedIterator>;

  auto __sfirst = _Traits::__segment(__first);
  auto __slast = _Traits::__segment(__last);


  if (__sfirst == __slast) {
    __func(_Traits::__local(__first), _Traits::__local(__last));
    return;
  }


  __func(_Traits::__local(__first), _Traits::__end(__sfirst));
  ++__sfirst;

  while (__sfirst != __slast) {
    __func(_Traits::__begin(__sfirst), _Traits::__end(__sfirst));
    ++__sfirst;
  }

  __func(_Traits::__begin(__sfirst), _Traits::__local(__last));
}

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy.h" 2 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter> __copy(_InIter, _Sent, _OutIter);

template <class _AlgPolicy>
struct __copy_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    while (__first != __last) {
      *__result = *__first;
      ++__first;
      ++__result;
    }

    return std::make_pair(std::move(__first), std::move(__result));
  }

  template <class _InIter, class _OutIter>
  struct _CopySegment {
    using _Traits = __segmented_iterator_traits<_InIter>;

    _OutIter& __result_;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit _CopySegment(_OutIter& __result)
        : __result_(__result) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
    operator()(typename _Traits::__local_iterator __lfirst, typename _Traits::__local_iterator __llast) {
      __result_ = std::__copy<_AlgPolicy>(__lfirst, __llast, std::move(__result_)).second;
    }
  };

  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    std::__for_each_segment(__first, __last, _CopySegment<_InIter, _OutIter>(__result));
    return std::make_pair(__last, std::move(__result));
  }

  template <class _InIter,
            class _OutIter,
            __enable_if_t<__has_random_access_iterator_category<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;

    if (__first == __last)
      return std::make_pair(std::move(__first), std::move(__result));

    auto __local_first = _Traits::__local(__result);
    auto __segment_iterator = _Traits::__segment(__result);
    while (true) {
      auto __local_last = _Traits::__end(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iters = std::__copy<_AlgPolicy>(__first, __first + __size, __local_first);
      __first = std::move(__iters.first);

      if (__first == __last)
        return std::make_pair(std::move(__first), _Traits::__compose(__segment_iterator, std::move(__iters.second)));

      __local_first = _Traits::__begin(++__segment_iterator);
    }
  }
};

struct __copy_trivial {

  template <class _In, class _Out, __enable_if_t<__can_lower_copy_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_trivial_impl(__first, __last, __result);
  }
};

template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
pair<_InIter, _OutIter> inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
__copy(_InIter __first, _Sent __last, _OutIter __result) {
  return std::__dispatch_copy_or_move<_AlgPolicy, __copy_loop<_AlgPolicy>, __copy_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  return std::__copy<_ClassicAlgPolicy>(__first, __last, __result).second;
}

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/move.h" 1 3
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/move.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/move.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter>
__move(_InIter __first, _Sent __last, _OutIter __result);

template <class _AlgPolicy>
struct __move_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    while (__first != __last) {
      *__result = _IterOps<_AlgPolicy>::__iter_move(__first);
      ++__first;
      ++__result;
    }
    return std::make_pair(std::move(__first), std::move(__result));
  }

  template <class _InIter, class _OutIter>
  struct _MoveSegment {
    using _Traits = __segmented_iterator_traits<_InIter>;

    _OutIter& __result_;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit _MoveSegment(_OutIter& __result)
        : __result_(__result) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
    operator()(typename _Traits::__local_iterator __lfirst, typename _Traits::__local_iterator __llast) {
      __result_ = std::__move<_AlgPolicy>(__lfirst, __llast, std::move(__result_)).second;
    }
  };

  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    std::__for_each_segment(__first, __last, _MoveSegment<_InIter, _OutIter>(__result));
    return std::make_pair(__last, std::move(__result));
  }

  template <class _InIter,
            class _OutIter,
            __enable_if_t<__has_random_access_iterator_category<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;

    if (__first == __last)
      return std::make_pair(std::move(__first), std::move(__result));

    auto __local_first = _Traits::__local(__result);
    auto __segment_iterator = _Traits::__segment(__result);
    while (true) {
      auto __local_last = _Traits::__end(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iters = std::__move<_AlgPolicy>(__first, __first + __size, __local_first);
      __first = std::move(__iters.first);

      if (__first == __last)
        return std::make_pair(std::move(__first), _Traits::__compose(__segment_iterator, std::move(__iters.second)));

      __local_first = _Traits::__begin(++__segment_iterator);
    }
  }
};

struct __move_trivial {

  template <class _In, class _Out, __enable_if_t<__can_lower_move_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_trivial_impl(__first, __last, __result);
  }
};

template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_InIter, _OutIter>
__move(_InIter __first, _Sent __last, _OutIter __result) {
  return std::__dispatch_copy_or_move<_AlgPolicy, __move_loop<_AlgPolicy>, __move_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  static_assert(is_copy_constructible<_InputIterator>::value, "Iterators has to be copy constructible.");
  static_assert(is_copy_constructible<_OutputIterator>::value, "The output iterator has to be copy constructible.");

  return std::__move<_ClassicAlgPolicy>(std::move(__first), std::move(__last), std::move(__result)).second;
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 2 3
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_relocatable.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_trivially_relocatable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <class _Tp, class = void>
struct __libcpp_is_trivially_relocatable : integral_constant<bool, __is_trivially_relocatable(_Tp)> {};





template <class _Tp>
struct __libcpp_is_trivially_relocatable<_Tp,
                                         __enable_if_t<is_same<_Tp, typename _Tp::__trivially_relocatable>::value> >
    : true_type {};

}}
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 2 3
# 44 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

struct __always_false {
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(_Args&&...) const noexcept {
    return false;
  }
};



template <class _ValueType, class _InputIterator, class _Sentinel1, class _ForwardIterator, class _EndPredicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) pair<_InputIterator, _ForwardIterator> __uninitialized_copy(
    _InputIterator __ifirst, _Sentinel1 __ilast, _ForwardIterator __ofirst, _EndPredicate __stop_copying) {
  _ForwardIterator __idx = __ofirst;

  try {

    for (; __ifirst != __ilast && !__stop_copying(__idx); ++__ifirst, (void)++__idx)
      ::new (std::__voidify(*__idx)) _ValueType(*__ifirst);

  } catch (...) {
    std::__destroy(__ofirst, __idx);
    throw;
  }


  return pair<_InputIterator, _ForwardIterator>(std::move(__ifirst), std::move(__idx));
}

template <class _InputIterator, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator
uninitialized_copy(_InputIterator __ifirst, _InputIterator __ilast, _ForwardIterator __ofirst) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  auto __result = std::__uninitialized_copy<_ValueType>(
      std::move(__ifirst), std::move(__ilast), std::move(__ofirst), __always_false());
  return std::move(__result.second);
}



template <class _ValueType, class _InputIterator, class _Size, class _ForwardIterator, class _EndPredicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) pair<_InputIterator, _ForwardIterator>
__uninitialized_copy_n(_InputIterator __ifirst, _Size __n, _ForwardIterator __ofirst, _EndPredicate __stop_copying) {
  _ForwardIterator __idx = __ofirst;

  try {

    for (; __n > 0 && !__stop_copying(__idx); ++__ifirst, (void)++__idx, (void)--__n)
      ::new (std::__voidify(*__idx)) _ValueType(*__ifirst);

  } catch (...) {
    std::__destroy(__ofirst, __idx);
    throw;
  }


  return pair<_InputIterator, _ForwardIterator>(std::move(__ifirst), std::move(__idx));
}

template <class _InputIterator, class _Size, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator
uninitialized_copy_n(_InputIterator __ifirst, _Size __n, _ForwardIterator __ofirst) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  auto __result =
      std::__uninitialized_copy_n<_ValueType>(std::move(__ifirst), __n, std::move(__ofirst), __always_false());
  return std::move(__result.second);
}



template <class _ValueType, class _ForwardIterator, class _Sentinel, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator
__uninitialized_fill(_ForwardIterator __first, _Sentinel __last, const _Tp& __x) {
  _ForwardIterator __idx = __first;

  try {

    for (; __idx != __last; ++__idx)
      ::new (std::__voidify(*__idx)) _ValueType(__x);

  } catch (...) {
    std::__destroy(__first, __idx);
    throw;
  }


  return __idx;
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void
uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __x) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  (void)std::__uninitialized_fill<_ValueType>(__first, __last, __x);
}



template <class _ValueType, class _ForwardIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator
__uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x) {
  _ForwardIterator __idx = __first;

  try {

    for (; __n > 0; ++__idx, (void)--__n)
      ::new (std::__voidify(*__idx)) _ValueType(__x);

  } catch (...) {
    std::__destroy(__first, __idx);
    throw;
  }


  return __idx;
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator
uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  return std::__uninitialized_fill_n<_ValueType>(__first, __n, __x);
}





template <class _ValueType, class _ForwardIterator, class _Sentinel>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator
__uninitialized_default_construct(_ForwardIterator __first, _Sentinel __last) {
  auto __idx = __first;

  try {

    for (; __idx != __last; ++__idx)
      ::new (std::__voidify(*__idx)) _ValueType;

  } catch (...) {
    std::__destroy(__first, __idx);
    throw;
  }


  return __idx;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {
  using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
  (void)std::__uninitialized_default_construct<_ValueType>(std::move(__first), std::move(__last));
}



template <class _ValueType, class _ForwardIterator, class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator __uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {
  auto __idx = __first;

  try {

    for (; __n > 0; ++__idx, (void)--__n)
      ::new (std::__voidify(*__idx)) _ValueType;

  } catch (...) {
    std::__destroy(__first, __idx);
    throw;
  }


  return __idx;
}

template <class _ForwardIterator, class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {
  using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
  return std::__uninitialized_default_construct_n<_ValueType>(std::move(__first), __n);
}



template <class _ValueType, class _ForwardIterator, class _Sentinel>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator
__uninitialized_value_construct(_ForwardIterator __first, _Sentinel __last) {
  auto __idx = __first;

  try {

    for (; __idx != __last; ++__idx)
      ::new (std::__voidify(*__idx)) _ValueType();

  } catch (...) {
    std::__destroy(__first, __idx);
    throw;
  }


  return __idx;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {
  using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
  (void)std::__uninitialized_value_construct<_ValueType>(std::move(__first), std::move(__last));
}



template <class _ValueType, class _ForwardIterator, class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator __uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {
  auto __idx = __first;

  try {

    for (; __n > 0; ++__idx, (void)--__n)
      ::new (std::__voidify(*__idx)) _ValueType();

  } catch (...) {
    std::__destroy(__first, __idx);
    throw;
  }


  return __idx;
}

template <class _ForwardIterator, class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {
  using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
  return std::__uninitialized_value_construct_n<_ValueType>(std::move(__first), __n);
}



template <class _ValueType,
          class _InputIterator,
          class _Sentinel1,
          class _ForwardIterator,
          class _EndPredicate,
          class _IterMove>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) pair<_InputIterator, _ForwardIterator> __uninitialized_move(
    _InputIterator __ifirst,
    _Sentinel1 __ilast,
    _ForwardIterator __ofirst,
    _EndPredicate __stop_moving,
    _IterMove __iter_move) {
  auto __idx = __ofirst;

  try {

    for (; __ifirst != __ilast && !__stop_moving(__idx); ++__idx, (void)++__ifirst) {
      ::new (std::__voidify(*__idx)) _ValueType(__iter_move(__ifirst));
    }

  } catch (...) {
    std::__destroy(__ofirst, __idx);
    throw;
  }


  return {std::move(__ifirst), std::move(__idx)};
}

template <class _InputIterator, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ForwardIterator
uninitialized_move(_InputIterator __ifirst, _InputIterator __ilast, _ForwardIterator __ofirst) {
  using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
  auto __iter_move = [](auto&& __iter) -> decltype(auto) { return std::move(*__iter); };

  auto __result = std::__uninitialized_move<_ValueType>(
      std::move(__ifirst), std::move(__ilast), std::move(__ofirst), __always_false(), __iter_move);
  return std::move(__result.second);
}



template <class _ValueType,
          class _InputIterator,
          class _Size,
          class _ForwardIterator,
          class _EndPredicate,
          class _IterMove>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) pair<_InputIterator, _ForwardIterator> __uninitialized_move_n(
    _InputIterator __ifirst, _Size __n, _ForwardIterator __ofirst, _EndPredicate __stop_moving, _IterMove __iter_move) {
  auto __idx = __ofirst;

  try {

    for (; __n > 0 && !__stop_moving(__idx); ++__idx, (void)++__ifirst, --__n)
      ::new (std::__voidify(*__idx)) _ValueType(__iter_move(__ifirst));

  } catch (...) {
    std::__destroy(__ofirst, __idx);
    throw;
  }


  return {std::move(__ifirst), std::move(__idx)};
}

template <class _InputIterator, class _Size, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) pair<_InputIterator, _ForwardIterator>
uninitialized_move_n(_InputIterator __ifirst, _Size __n, _ForwardIterator __ofirst) {
  using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
  auto __iter_move = [](auto&& __iter) -> decltype(auto) { return std::move(*__iter); };

  return std::__uninitialized_move_n<_ValueType>(
      std::move(__ifirst), __n, std::move(__ofirst), __always_false(), __iter_move);
}
# 367 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 3
template <class _Alloc,
          class _BidirIter,
          __enable_if_t<__has_bidirectional_iterator_category<_BidirIter>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__allocator_destroy_multidimensional(_Alloc& __alloc, _BidirIter __first, _BidirIter __last) noexcept {
  using _ValueType = typename iterator_traits<_BidirIter>::value_type;
  static_assert(is_same_v<typename allocator_traits<_Alloc>::value_type, _ValueType>,
                "The allocator should already be rebound to the correct type");

  if (__first == __last)
    return;

  if constexpr (is_array_v<_ValueType>) {
    static_assert(!__libcpp_is_unbounded_array<_ValueType>::value,
                  "arrays of unbounded arrays don't exist, but if they did we would mess up here");

    using _Element = remove_extent_t<_ValueType>;
    __allocator_traits_rebind_t<_Alloc, _Element> __elem_alloc(__alloc);
    do {
      --__last;
      decltype(auto) __array = *__last;
      std::__allocator_destroy_multidimensional(__elem_alloc, __array, __array + extent_v<_ValueType>);
    } while (__last != __first);
  } else {
    do {
      --__last;
      allocator_traits<_Alloc>::destroy(__alloc, std::addressof(*__last));
    } while (__last != __first);
  }
}
# 405 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 3
template <class _Alloc, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __allocator_construct_at_multidimensional(_Alloc& __alloc, _Tp* __loc) {
  static_assert(is_same_v<typename allocator_traits<_Alloc>::value_type, _Tp>,
                "The allocator should already be rebound to the correct type");

  if constexpr (is_array_v<_Tp>) {
    using _Element = remove_extent_t<_Tp>;
    __allocator_traits_rebind_t<_Alloc, _Element> __elem_alloc(__alloc);
    size_t __i = 0;
    _Tp& __array = *__loc;


    auto __guard = std::__make_exception_guard([&]() {
      std::__allocator_destroy_multidimensional(__elem_alloc, __array, __array + __i);
    });

    for (; __i != extent_v<_Tp>; ++__i) {
      std::__allocator_construct_at_multidimensional(__elem_alloc, std::addressof(__array[__i]));
    }
    __guard.__complete();
  } else {
    allocator_traits<_Alloc>::construct(__alloc, __loc);
  }
}
# 440 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 3
template <class _Alloc, class _Tp, class _Arg>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__allocator_construct_at_multidimensional(_Alloc& __alloc, _Tp* __loc, _Arg const& __arg) {
  static_assert(is_same_v<typename allocator_traits<_Alloc>::value_type, _Tp>,
                "The allocator should already be rebound to the correct type");

  if constexpr (is_array_v<_Tp>) {
    static_assert(is_array_v<_Arg>,
                  "Provided non-array initialization argument to __allocator_construct_at_multidimensional when "
                  "trying to construct an array.");

    using _Element = remove_extent_t<_Tp>;
    __allocator_traits_rebind_t<_Alloc, _Element> __elem_alloc(__alloc);
    size_t __i = 0;
    _Tp& __array = *__loc;


    auto __guard = std::__make_exception_guard([&]() {
      std::__allocator_destroy_multidimensional(__elem_alloc, __array, __array + __i);
    });
    for (; __i != extent_v<_Tp>; ++__i) {
      std::__allocator_construct_at_multidimensional(__elem_alloc, std::addressof(__array[__i]), __arg[__i]);
    }
    __guard.__complete();
  } else {
    allocator_traits<_Alloc>::construct(__alloc, __loc, __arg);
  }
}
# 476 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 3
template <class _Alloc,
          class _BidirIter,
          class _Tp,
          class _Size = typename iterator_traits<_BidirIter>::difference_type>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__uninitialized_allocator_fill_n_multidimensional(_Alloc& __alloc, _BidirIter __it, _Size __n, _Tp const& __value) {
  using _ValueType = typename iterator_traits<_BidirIter>::value_type;
  __allocator_traits_rebind_t<_Alloc, _ValueType> __value_alloc(__alloc);
  _BidirIter __begin = __it;


  auto __guard =
      std::__make_exception_guard([&]() { std::__allocator_destroy_multidimensional(__value_alloc, __begin, __it); });
  for (; __n != 0; --__n, ++__it) {
    std::__allocator_construct_at_multidimensional(__value_alloc, std::addressof(*__it), __value);
  }
  __guard.__complete();
}



template <class _Alloc, class _BidirIter, class _Size = typename iterator_traits<_BidirIter>::difference_type>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__uninitialized_allocator_value_construct_n_multidimensional(_Alloc& __alloc, _BidirIter __it, _Size __n) {
  using _ValueType = typename iterator_traits<_BidirIter>::value_type;
  __allocator_traits_rebind_t<_Alloc, _ValueType> __value_alloc(__alloc);
  _BidirIter __begin = __it;


  auto __guard =
      std::__make_exception_guard([&]() { std::__allocator_destroy_multidimensional(__value_alloc, __begin, __it); });
  for (; __n != 0; --__n, ++__it) {
    std::__allocator_construct_at_multidimensional(__value_alloc, std::addressof(*__it));
  }
  __guard.__complete();
}




template <class _Alloc, class _Iter, class _Sent>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__allocator_destroy(_Alloc& __alloc, _Iter __first, _Sent __last) {
  for (; __first != __last; ++__first)
    allocator_traits<_Alloc>::destroy(__alloc, std::__to_address(__first));
}

template <class _Alloc, class _Iter>
class _AllocatorDestroyRangeReverse {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  _AllocatorDestroyRangeReverse(_Alloc& __alloc, _Iter& __first, _Iter& __last)
      : __alloc_(__alloc), __first_(__first), __last_(__last) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()() const {
    std::__allocator_destroy(__alloc_, std::reverse_iterator<_Iter>(__last_), std::reverse_iterator<_Iter>(__first_));
  }

private:
  _Alloc& __alloc_;
  _Iter& __first_;
  _Iter& __last_;
};





template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter2
__uninitialized_allocator_copy_impl(_Alloc& __alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2) {
  auto __destruct_first = __first2;
  auto __guard =
      std::__make_exception_guard(_AllocatorDestroyRangeReverse<_Alloc, _Iter2>(__alloc, __destruct_first, __first2));
  while (__first1 != __last1) {
    allocator_traits<_Alloc>::construct(__alloc, std::__to_address(__first2), *__first1);
    ++__first1;
    ++__first2;
  }
  __guard.__complete();
  return __first2;
}

template <class _Alloc, class _Type>
struct __allocator_has_trivial_copy_construct : _Not<__has_construct<_Alloc, _Type*, const _Type&> > {};

template <class _Type>
struct __allocator_has_trivial_copy_construct<allocator<_Type>, _Type> : true_type {};

template <class _Alloc,
          class _In,
          class _RawTypeIn = __remove_const_t<_In>,
          class _Out,
          __enable_if_t<

              is_trivially_copy_constructible<_RawTypeIn>::value && is_trivially_copy_assignable<_RawTypeIn>::value &&
                  is_same<__remove_const_t<_In>, __remove_const_t<_Out> >::value &&
                  __allocator_has_trivial_copy_construct<_Alloc, _RawTypeIn>::value,
              int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Out*
__uninitialized_allocator_copy_impl(_Alloc&, _In* __first1, _In* __last1, _Out* __first2) {

  if (__libcpp_is_constant_evaluated()) {
    while (__first1 != __last1) {
      std::__construct_at(std::__to_address(__first2), *__first1);
      ++__first1;
      ++__first2;
    }
    return __first2;
  } else {
    return std::copy(__first1, __last1, const_cast<_RawTypeIn*>(__first2));
  }
}

template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter2
__uninitialized_allocator_copy(_Alloc& __alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2) {
  auto __unwrapped_range = std::__unwrap_range(__first1, __last1);
  auto __result = std::__uninitialized_allocator_copy_impl(
      __alloc, __unwrapped_range.first, __unwrapped_range.second, std::__unwrap_iter(__first2));
  return std::__rewrap_iter(__first2, __result);
}

template <class _Alloc, class _Type>
struct __allocator_has_trivial_move_construct : _Not<__has_construct<_Alloc, _Type*, _Type&&> > {};

template <class _Type>
struct __allocator_has_trivial_move_construct<allocator<_Type>, _Type> : true_type {};

template <class _Alloc, class _Tp>
struct __allocator_has_trivial_destroy : _Not<__has_destroy<_Alloc, _Tp*> > {};

template <class _Tp, class _Up>
struct __allocator_has_trivial_destroy<allocator<_Tp>, _Up> : true_type {};
# 623 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uninitialized_algorithms.h" 3
template <class _Alloc, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__uninitialized_allocator_relocate(_Alloc& __alloc, _Tp* __first, _Tp* __last, _Tp* __result) {
  static_assert(__is_cpp17_move_insertable<_Alloc>::value,
                "The specified type does not meet the requirements of Cpp17MoveInsertable");
  if (__libcpp_is_constant_evaluated() || !__libcpp_is_trivially_relocatable<_Tp>::value ||
      !__allocator_has_trivial_move_construct<_Alloc, _Tp>::value ||
      !__allocator_has_trivial_destroy<_Alloc, _Tp>::value) {
    auto __destruct_first = __result;
    auto __guard =
        std::__make_exception_guard(_AllocatorDestroyRangeReverse<_Alloc, _Tp*>(__alloc, __destruct_first, __result));
    auto __iter = __first;
    while (__iter != __last) {

      allocator_traits<_Alloc>::construct(__alloc, __result, std::move_if_noexcept(*__iter));



      ++__iter;
      ++__result;
    }
    __guard.__complete();
    std::__allocator_destroy(__alloc, __first, __last);
  } else {
    __builtin_memcpy(const_cast<__remove_const_t<_Tp>*>(__result), __first, sizeof(_Tp) * (__last - __first));
  }
}

}}
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/unique_ptr.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/unique_ptr.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/hash.h" 1 3
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/hash.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstring" 1 3
# 74 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstring" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

using ::size_t __attribute__((__using_if_exists__));
using ::memcpy __attribute__((__using_if_exists__));
using ::memmove __attribute__((__using_if_exists__));
using ::strcpy __attribute__((__using_if_exists__));
using ::strncpy __attribute__((__using_if_exists__));
using ::strcat __attribute__((__using_if_exists__));
using ::strncat __attribute__((__using_if_exists__));
using ::memcmp __attribute__((__using_if_exists__));
using ::strcmp __attribute__((__using_if_exists__));
using ::strncmp __attribute__((__using_if_exists__));
using ::strcoll __attribute__((__using_if_exists__));
using ::strxfrm __attribute__((__using_if_exists__));
using ::memchr __attribute__((__using_if_exists__));
using ::strchr __attribute__((__using_if_exists__));
using ::strcspn __attribute__((__using_if_exists__));
using ::strpbrk __attribute__((__using_if_exists__));
using ::strrchr __attribute__((__using_if_exists__));
using ::strspn __attribute__((__using_if_exists__));
using ::strstr __attribute__((__using_if_exists__));
using ::strtok __attribute__((__using_if_exists__));
using ::memset __attribute__((__using_if_exists__));
using ::strerror __attribute__((__using_if_exists__));
using ::strlen __attribute__((__using_if_exists__));

}}
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/hash.h" 2 3
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/hash.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Size __loadword(const void* __p) {
  _Size __r;
  std::memcpy(&__r, __p, sizeof(__r));
  return __r;
}




template <class _Size, size_t = sizeof(_Size) * 8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) _Size
  operator()(const void* __key, _Size __len) const {

    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4) {
      _Size __k = std::__loadword<_Size>(__data);
      __k *= __m;
      __k ^= __k >> __r;
      __k *= __m;
      __h *= __m;
      __h ^= __k;
    }
    switch (__len) {
    case 3:
      __h ^= static_cast<_Size>(__data[2] << 16);
      [[fallthrough]];
    case 2:
      __h ^= static_cast<_Size>(__data[1] << 8);
      [[fallthrough]];
    case 1:
      __h ^= __data[0];
      __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
  }
};

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64> {

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) _Size
  operator()(const void* __key, _Size __len) const {
    const char* __s = static_cast<const char*>(__key);
    if (__len <= 32) {
      if (__len <= 16) {
        return __hash_len_0_to_16(__s, __len);
      } else {
        return __hash_len_17_to_32(__s, __len);
      }
    } else if (__len <= 64) {
      return __hash_len_33_to_64(__s, __len);
    }



    _Size __x = std::__loadword<_Size>(__s + __len - 40);
    _Size __y = std::__loadword<_Size>(__s + __len - 16) + std::__loadword<_Size>(__s + __len - 56);
    _Size __z =
        __hash_len_16(std::__loadword<_Size>(__s + __len - 48) + __len, std::__loadword<_Size>(__s + __len - 24));
    pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
    pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
    __x = __x * __k1 + std::__loadword<_Size>(__s);


    __len = (__len - 1) & ~static_cast<_Size>(63);
    do {
      __x = __rotate(__x + __y + __v.first + std::__loadword<_Size>(__s + 8), 37) * __k1;
      __y = __rotate(__y + __v.second + std::__loadword<_Size>(__s + 48), 42) * __k1;
      __x ^= __w.second;
      __y += __v.first + std::__loadword<_Size>(__s + 40);
      __z = __rotate(__z + __w.first, 33) * __k1;
      __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
      __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second, __y + std::__loadword<_Size>(__s + 16));
      std::swap(__z, __x);
      __s += 64;
      __len -= 64;
    } while (__len != 0);
    return __hash_len_16(__hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
                         __hash_len_16(__v.second, __w.second) + __x);
  }

private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static _Size __shift_mix(_Size __val) { return __val ^ (__val >> 47); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static _Size __hash_len_16(_Size __u, _Size __v) {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static _Size
  __hash_len_0_to_16(const char* __s, _Size __len) {
    if (__len > 8) {
      const _Size __a = std::__loadword<_Size>(__s);
      const _Size __b = std::__loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = std::__loadword<uint32_t>(__s);
      const uint32_t __b = std::__loadword<uint32_t>(__s + __len - 4);



      return __hash_len_16(__len + (__a << 3), __b);

    }
    if (__len > 0) {
      const unsigned char __a = static_cast<unsigned char>(__s[0]);
      const unsigned char __b = static_cast<unsigned char>(__s[__len >> 1]);
      const unsigned char __c = static_cast<unsigned char>(__s[__len - 1]);
      const uint32_t __y = static_cast<uint32_t>(__a) + (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static _Size
  __hash_len_17_to_32(const char* __s, _Size __len) {
    const _Size __a = std::__loadword<_Size>(__s) * __k1;
    const _Size __b = std::__loadword<_Size>(__s + 8);
    const _Size __c = std::__loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = std::__loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(
        __rotate(__a - __b, 43) + __rotate(__c, 30) + __d, __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static pair<_Size, _Size>
  __weak_hash_len_32_with_seeds(_Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static pair<_Size, _Size>
  __weak_hash_len_32_with_seeds(const char* __s, _Size __a, _Size __b) {
    return __weak_hash_len_32_with_seeds(
        std::__loadword<_Size>(__s),
        std::__loadword<_Size>(__s + 8),
        std::__loadword<_Size>(__s + 16),
        std::__loadword<_Size>(__s + 24),
        __a,
        __b);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static _Size
  __hash_len_33_to_64(const char* __s, size_t __len) {
    _Size __z = std::__loadword<_Size>(__s + 24);
    _Size __a = std::__loadword<_Size>(__s) + (__len + std::__loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += std::__loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += std::__loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = std::__loadword<_Size>(__s + 16) + std::__loadword<_Size>(__s + __len - 32);
    __z += std::__loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += std::__loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += std::__loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0> : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      size_t __a;
    } __u;
    __u.__a = 0;
    __u.__t = __v;
    return __u.__a;
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1> : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      size_t __a;
    } __u;
    __u.__t = __v;
    return __u.__a;
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2> : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3> : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
        size_t __c;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4> : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
        size_t __c;
        size_t __d;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

struct _PairT {
  size_t first;
  size_t second;
};

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline size_t __hash_combine(size_t __lhs, size_t __rhs) noexcept {
  typedef __scalar_hash<_PairT> _HashT;
  const _PairT __p = {__lhs, __rhs};
  return _HashT()(__p);
}

template <class _Tp>
struct hash<_Tp*> : public __unary_function<_Tp*, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(_Tp* __v) const noexcept {
    union {
      _Tp* __t;
      size_t __a;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <>
struct hash<bool> : public __unary_function<bool, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(bool __v) const noexcept { return static_cast<size_t>(__v); }
};

template <>
struct hash<char> : public __unary_function<char, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(char __v) const noexcept { return static_cast<size_t>(__v); }
};

template <>
struct hash<signed char> : public __unary_function<signed char, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(signed char __v) const noexcept { return static_cast<size_t>(__v); }
};

template <>
struct hash<unsigned char> : public __unary_function<unsigned char, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(unsigned char __v) const noexcept { return static_cast<size_t>(__v); }
};


template <>
struct hash<char8_t> : public __unary_function<char8_t, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(char8_t __v) const noexcept { return static_cast<size_t>(__v); }
};


template <>
struct hash<char16_t> : public __unary_function<char16_t, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(char16_t __v) const noexcept { return static_cast<size_t>(__v); }
};

template <>
struct hash<char32_t> : public __unary_function<char32_t, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(char32_t __v) const noexcept { return static_cast<size_t>(__v); }
};


template <>
struct hash<wchar_t> : public __unary_function<wchar_t, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(wchar_t __v) const noexcept { return static_cast<size_t>(__v); }
};


template <>
struct hash<short> : public __unary_function<short, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(short __v) const noexcept { return static_cast<size_t>(__v); }
};

template <>
struct hash<unsigned short> : public __unary_function<unsigned short, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(unsigned short __v) const noexcept { return static_cast<size_t>(__v); }
};

template <>
struct hash<int> : public __unary_function<int, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(int __v) const noexcept { return static_cast<size_t>(__v); }
};

template <>
struct hash<unsigned int> : public __unary_function<unsigned int, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(unsigned int __v) const noexcept { return static_cast<size_t>(__v); }
};

template <>
struct hash<long> : public __unary_function<long, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(long __v) const noexcept { return static_cast<size_t>(__v); }
};

template <>
struct hash<unsigned long> : public __unary_function<unsigned long, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(unsigned long __v) const noexcept { return static_cast<size_t>(__v); }
};

template <>
struct hash<long long> : public __scalar_hash<long long> {};

template <>
struct hash<unsigned long long> : public __scalar_hash<unsigned long long> {};



template <>
struct hash<__int128_t> : public __scalar_hash<__int128_t> {};

template <>
struct hash<__uint128_t> : public __scalar_hash<__uint128_t> {};



template <>
struct hash<float> : public __scalar_hash<float> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(float __v) const noexcept {

    if (__v == 0.0f)
      return 0;
    return __scalar_hash<float>::operator()(__v);
  }
};

template <>
struct hash<double> : public __scalar_hash<double> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(double __v) const noexcept {

    if (__v == 0.0)
      return 0;
    return __scalar_hash<double>::operator()(__v);
  }
};

template <>
struct hash<long double> : public __scalar_hash<long double> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(long double __v) const noexcept {

    if (__v == 0.0L)
      return 0;
# 490 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__functional/hash.h" 3
    return __scalar_hash<long double>::operator()(__v);

  }
};

template <class _Tp, bool = is_enum<_Tp>::value>
struct __enum_hash : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(_Tp __v) const noexcept {
    typedef typename underlying_type<_Tp>::type type;
    return hash<type>()(static_cast<type>(__v));
  }
};
template <class _Tp>
struct __enum_hash<_Tp, false> {
  __enum_hash() = delete;
  __enum_hash(__enum_hash const&) = delete;
  __enum_hash& operator=(__enum_hash const&) = delete;
};

template <class _Tp>
struct hash : public __enum_hash<_Tp> {};



template <>
struct hash<nullptr_t> : public __unary_function<nullptr_t, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(nullptr_t) const noexcept { return 662607004ull; }
};



template <class _Key, class _Hash>
using __check_hash_requirements __attribute__((__nodebug__)) =
    integral_constant<bool,
                      is_copy_constructible<_Hash>::value && is_move_constructible<_Hash>::value &&
                          __invokable_r<size_t, _Hash, _Key const&>::value >;

template <class _Key, class _Hash = hash<_Key> >
using __has_enabled_hash __attribute__((__nodebug__)) =
    integral_constant<bool, __check_hash_requirements<_Key, _Hash>::value && is_default_constructible<_Hash>::value >;


template <class _Type, class>
using __enable_hash_helper_imp __attribute__((__nodebug__)) = _Type;

template <class _Type, class... _Keys>
using __enable_hash_helper __attribute__((__nodebug__)) =
    __enable_hash_helper_imp<_Type, __enable_if_t<__all<__has_enabled_hash<_Keys>::value...>::value> >;







}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/unique_ptr.h" 2 3
# 47 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/unique_ptr.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 51 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/unique_ptr.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct default_delete {
  static_assert(!is_function<_Tp>::value, "default_delete cannot be instantiated for function types");

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr default_delete() noexcept = default;



  template <class _Up, __enable_if_t<is_convertible<_Up*, _Tp*>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr default_delete(const default_delete<_Up>&) noexcept {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void operator()(_Tp* __ptr) const noexcept {
    static_assert(sizeof(_Tp) >= 0, "cannot delete an incomplete type");
    static_assert(!is_void<_Tp>::value, "cannot delete an incomplete type");
    delete __ptr;
  }
};

template <class _Tp>
struct default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible : enable_if<is_convertible<_Up (*)[], _Tp (*)[]>::value> {};

public:

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr default_delete() noexcept = default;




  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  default_delete(const default_delete<_Up[]>&, typename _EnableIfConvertible<_Up>::type* = 0) noexcept {}

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename _EnableIfConvertible<_Up>::type
  operator()(_Up* __ptr) const noexcept {
    static_assert(sizeof(_Up) >= 0, "cannot delete an incomplete type");
    delete[] __ptr;
  }
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};







template <class _Tp, class _Dp = default_delete<_Tp> >
class unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef __attribute__((__nodebug__)) typename __pointer<_Tp, deleter_type>::type pointer;

  static_assert(!is_rvalue_reference<deleter_type>::value, "the specified deleter type cannot be an rvalue reference");







  using __trivially_relocatable = __conditional_t<
      __libcpp_is_trivially_relocatable<pointer>::value && __libcpp_is_trivially_relocatable<deleter_type>::value,
      unique_ptr,
      void>;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  typedef __attribute__((__nodebug__)) __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type< __type_identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((__nodebug__)) =
      __enable_if_t<is_default_constructible<_Deleter>::value && !is_pointer<_Deleter>::value>;

  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((__nodebug__)) = __enable_if_t<is_constructible<deleter_type, _ArgType>::value>;

  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible __attribute__((__nodebug__)) =
      __enable_if_t< is_convertible<typename _UPtr::pointer, pointer>::value && !is_array<_Up>::value >;

  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((__nodebug__)) =
      __enable_if_t< (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
                     (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value) >;

  template <class _UDel>
  using _EnableIfDeleterAssignable = __enable_if_t< is_assignable<_Dp&, _UDel&&>::value >;

public:
  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr() noexcept : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(nullptr_t) noexcept
      : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit unique_ptr(pointer __p) noexcept
      : __ptr_(__p, __value_init_tag()) {}

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::move(__d)) {
    static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::forward<deleter_type>(__u.get_deleter())) {}

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::forward<_Ep>(__u.get_deleter())) {}







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<_Ep>(__u.get_deleter());
    return *this;
  }
# 249 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/unique_ptr.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr ~unique_ptr() { reset(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __add_lvalue_reference_t<_Tp> operator*() const {
    return *__ptr_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer operator->() const noexcept { return __ptr_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer get() const noexcept { return __ptr_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr deleter_type& get_deleter() noexcept { return __ptr_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void reset(pointer __p = pointer()) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(unique_ptr& __u) noexcept { __ptr_.swap(__u.__ptr_); }
};

template <class _Tp, class _Dp>
class unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer<_Tp, deleter_type>::type pointer;







  using __trivially_relocatable = __conditional_t<
      __libcpp_is_trivially_relocatable<pointer>::value && __libcpp_is_trivially_relocatable<deleter_type>::value,
      unique_ptr,
      void>;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};

  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<bool,
                          is_same<_FromElem*, pointer>::value ||
                              (is_same<pointer, element_type*>::value &&
                               is_convertible<_FromElem (*)[], element_type (*)[]>::value) > {};

  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type< __type_identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((__nodebug__)) =
      __enable_if_t<is_default_constructible<_Deleter>::value && !is_pointer<_Deleter>::value>;

  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((__nodebug__)) = __enable_if_t<is_constructible<deleter_type, _ArgType>::value>;

  template <class _Pp>
  using _EnableIfPointerConvertible __attribute__((__nodebug__)) = __enable_if_t< _CheckArrayPointerConversion<_Pp>::value >;

  template <class _UPtr, class _Up, class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible __attribute__((__nodebug__)) =
      __enable_if_t< is_array<_Up>::value && is_same<pointer, element_type*>::value &&
                     is_same<typename _UPtr::pointer, _ElemT*>::value &&
                     is_convertible<_ElemT (*)[], element_type (*)[]>::value >;

  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((__nodebug__)) =
      __enable_if_t< (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
                     (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value) >;

  template <class _UDel>
  using _EnableIfDeleterAssignable __attribute__((__nodebug__)) = __enable_if_t< is_assignable<_Dp&, _UDel&&>::value >;

public:
  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr() noexcept : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(nullptr_t) noexcept
      : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit unique_ptr(_Pp __p) noexcept
      : __ptr_(__p, __value_init_tag()) {}

  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, __d) {}

  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::move(__d)) {
    static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, std::move(__d)) {
    static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
  }

  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::forward<deleter_type>(__u.get_deleter())) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::forward<_Ep>(__u.get_deleter())) {}

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<_Ep>(__u.get_deleter());
    return *this;
  }






public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr ~unique_ptr() { reset(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __add_lvalue_reference_t<_Tp> operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer get() const noexcept { return __ptr_.first(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr deleter_type& get_deleter() noexcept { return __ptr_.second(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp, __enable_if_t<_CheckArrayPointerConversion<_Pp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void reset(_Pp __p) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void reset(nullptr_t = nullptr) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(unique_ptr& __u) noexcept { __ptr_.swap(__u.__ptr_); }
};

template <class _Tp, class _Dp, __enable_if_t<__is_swappable<_Dp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) noexcept {
  __x.swap(__y);
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return __x.get() == __y.get();
}
# 494 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/unique_ptr.h" 3
template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator<(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  typedef typename unique_ptr<_T2, _D2>::pointer _P2;
  typedef typename common_type<_P1, _P2>::type _Vp;
  return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator>(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return __y < __x;
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return !(__y < __x);
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return !(__x < __y);
}


template <class _T1, class _D1, class _T2, class _D2>
  requires three_way_comparable_with<typename unique_ptr<_T1, _D1>::pointer, typename unique_ptr<_T2, _D2>::pointer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
    compare_three_way_result_t<typename unique_ptr<_T1, _D1>::pointer, typename unique_ptr<_T2, _D2>::pointer>
    operator<=>(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return compare_three_way()(__x.get(), __y.get());
}


template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept {
  return !__x;
}
# 550 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/unique_ptr.h" 3
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return __x < nullptr;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return !(nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return !(nullptr < __x);
}


template <class _T1, class _D1>
  requires three_way_comparable< typename unique_ptr<_T1, _D1>::pointer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr compare_three_way_result_t<typename unique_ptr<_T1, _D1>::pointer>
operator<=>(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return compare_three_way()(__x.get(), static_cast<typename unique_ptr<_T1, _D1>::pointer>(nullptr));
}




template <class _Tp>
struct __unique_if {
  typedef unique_ptr<_Tp> __unique_single;
};

template <class _Tp>
struct __unique_if<_Tp[]> {
  typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;
};

template <class _Tp, size_t _Np>
struct __unique_if<_Tp[_Np]> {
  typedef void __unique_array_known_bound;
};

template <class _Tp, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename __unique_if<_Tp>::__unique_single
make_unique(_Args&&... __args) {
  return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...));
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique(size_t __n) {
  typedef __remove_extent_t<_Tp> _Up;
  return unique_ptr<_Tp>(new _Up[__n]());
}

template <class _Tp, class... _Args>
typename __unique_if<_Tp>::__unique_array_known_bound make_unique(_Args&&...) = delete;





template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename __unique_if<_Tp>::__unique_single
make_unique_for_overwrite() {
  return unique_ptr<_Tp>(new _Tp);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique_for_overwrite(size_t __n) {
  return unique_ptr<_Tp>(new __remove_extent_t<_Tp>[__n]);
}

template <class _Tp, class... _Args>
typename __unique_if<_Tp>::__unique_array_known_bound make_unique_for_overwrite(_Args&&...) = delete;



template <class _Tp>
struct hash;

template <class _Tp, class _Dp>



struct hash<__enable_hash_helper< unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer> >

{





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(const unique_ptr<_Tp, _Dp>& __ptr) const {
    typedef typename unique_ptr<_Tp, _Dp>::pointer pointer;
    return hash<pointer>()(__ptr.get());
  }
};

}}
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3
# 55 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/typeinfo" 1 3
# 69 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/typeinfo" 3






namespace std
{
# 185 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/typeinfo" 3
struct __type_info_implementations {
  struct __string_impl_base {
    typedef const char* __type_name_t;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) constexpr static const char*
    __type_name_to_string(__type_name_t __v) noexcept {
      return __v;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) constexpr static __type_name_t
    __string_to_type_name(const char* __v) noexcept {
      return __v;
    }
  };

  struct __unique_impl : __string_impl_base {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) static size_t __hash(__type_name_t __v) noexcept {
      return reinterpret_cast<size_t>(__v);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs < __rhs;
    }
  };

  struct __non_unique_impl : __string_impl_base {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) static size_t __hash(__type_name_t __ptr) noexcept {
      size_t __hash = 5381;
      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
        __hash = (__hash * 33) ^ __c;
      return __hash;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __builtin_strcmp(__lhs, __rhs) < 0;
    }
  };

  struct __non_unique_arm_rtti_bit_impl {
    typedef uintptr_t __type_name_t;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return reinterpret_cast<const char*>(__v & ~__non_unique_rtti_bit::value);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return reinterpret_cast<__type_name_t>(__v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) static size_t __hash(__type_name_t __v) noexcept {
      if (__is_type_name_unique(__v))
        return __v;
      return __non_unique_impl::__hash(__type_name_to_string(__v));
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__lhs == __rhs)
        return true;
      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))


        return false;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__always_inline__)) static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))
        return __lhs < __rhs;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) < 0;
    }

  private:


    typedef integral_constant<__type_name_t, (1ULL << ((8 * sizeof(__type_name_t)) - 1))>
        __non_unique_rtti_bit;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static bool __is_type_name_unique(__type_name_t __lhs) noexcept {
      return !(__lhs & __non_unique_rtti_bit::value);
    }
  };

  typedef

      __unique_impl







          __impl;
};

class __attribute__((__visibility__("default"))) type_info {
  type_info& operator=(const type_info&);
  type_info(const type_info&);

protected:
  typedef __type_info_implementations::__impl __impl;

  __impl::__type_name_t __type_name;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit type_info(const char* __n) : __type_name(__impl::__string_to_type_name(__n)) {}

public:
  virtual ~type_info();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const char* name() const noexcept { return __impl::__type_name_to_string(__type_name); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool before(const type_info& __arg) const noexcept {
    return __impl::__lt(__type_name, __arg.__type_name);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t hash_code() const noexcept { return __impl::__hash(__type_name); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator==(const type_info& __arg) const noexcept {


    if (__libcpp_is_constant_evaluated()) {
      return this == &__arg;
    }
    return __impl::__eq(__type_name, __arg.__type_name);
  }




};


class __attribute__((__visibility__("default"))) bad_cast : public exception {
public:
  bad_cast() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_cast(const bad_cast&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_cast& operator=(const bad_cast&) noexcept = default;
  ~bad_cast() noexcept override;
  const char* what() const noexcept override;
};

class __attribute__((__visibility__("default"))) bad_typeid : public exception {
public:
  bad_typeid() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_typeid(const bad_typeid&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_typeid& operator=(const bad_typeid&) noexcept = default;
  ~bad_typeid() noexcept override;
  const char* what() const noexcept override;
};

}
# 362 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/typeinfo" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_bad_cast() {

  throw bad_cast();



}
}}
# 56 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__atomic/memory_order.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__atomic/memory_order.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {




enum __legacy_memory_order { __mo_relaxed, __mo_consume, __mo_acquire, __mo_release, __mo_acq_rel, __mo_seq_cst };

using __memory_order_underlying_t = underlying_type<__legacy_memory_order>::type;



enum class memory_order : __memory_order_underlying_t {
  relaxed = __mo_relaxed,
  consume = __mo_consume,
  acquire = __mo_acquire,
  release = __mo_release,
  acq_rel = __mo_acq_rel,
  seq_cst = __mo_seq_cst
};

static_assert((is_same<underlying_type<memory_order>::type, __memory_order_underlying_t>::value),
              "unexpected underlying type for std::memory_order");

inline constexpr auto memory_order_relaxed = memory_order::relaxed;
inline constexpr auto memory_order_consume = memory_order::consume;
inline constexpr auto memory_order_acquire = memory_order::acquire;
inline constexpr auto memory_order_release = memory_order::release;
inline constexpr auto memory_order_acq_rel = memory_order::acq_rel;
inline constexpr auto memory_order_seq_cst = memory_order::seq_cst;
# 63 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__atomic/memory_order.h" 3
}}
# 58 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3
# 62 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 66 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 78 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _ValueType>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ValueType __libcpp_relaxed_load(_ValueType const* __value) {


  return __atomic_load_n(__value, 0);



}

template <class _ValueType>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ValueType __libcpp_acquire_load(_ValueType const* __value) {


  return __atomic_load_n(__value, 2);



}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp __libcpp_atomic_refcount_increment(_Tp& __t) noexcept {

  return __atomic_add_fetch(&__t, 1, 0);



}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp __libcpp_atomic_refcount_decrement(_Tp& __t) noexcept {

  return __atomic_add_fetch(&__t, -1, 4);



}

class __attribute__((__visibility__("default"))) bad_weak_ptr : public std::exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_weak_ptr() noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_weak_ptr(const bad_weak_ptr&) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bad_weak_ptr& operator=(const bad_weak_ptr&) noexcept = default;
  ~bad_weak_ptr() noexcept override;
  const char* what() const noexcept override;
};

[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_bad_weak_ptr() {

  throw bad_weak_ptr();



}

template <class _Tp>
class weak_ptr;

class __attribute__((__visibility__("default"))) __shared_count {
  __shared_count(const __shared_count&);
  __shared_count& operator=(const __shared_count&);

protected:
  long __shared_owners_;
  virtual ~__shared_count();

private:
  virtual void __on_zero_shared() noexcept = 0;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __shared_count(long __refs = 0) noexcept : __shared_owners_(__refs) {}





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __add_shared() noexcept { __libcpp_atomic_refcount_increment(__shared_owners_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool __release_shared() noexcept {
    if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
      __on_zero_shared();
      return true;
    }
    return false;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long use_count() const noexcept { return __libcpp_relaxed_load(&__shared_owners_) + 1; }
};

class __attribute__((__visibility__("default"))) __shared_weak_count : private __shared_count {
  long __shared_weak_owners_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __shared_weak_count(long __refs = 0) noexcept
      : __shared_count(__refs),
        __shared_weak_owners_(__refs) {}

protected:
  ~__shared_weak_count() override;

public:





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __add_shared() noexcept { __shared_count::__add_shared(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __add_weak() noexcept { __libcpp_atomic_refcount_increment(__shared_weak_owners_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __release_shared() noexcept {
    if (__shared_count::__release_shared())
      __release_weak();
  }

  void __release_weak() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long use_count() const noexcept { return __shared_count::use_count(); }
  __shared_weak_count* lock() noexcept;

  virtual const void* __get_deleter(const type_info&) const noexcept;

private:
  virtual void __on_zero_shared_weak() noexcept = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer : public __shared_weak_count {
  __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
      : __data_(__compressed_pair<_Tp, _Dp>(__p, std::move(__d)), std::move(__a)) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const void* __get_deleter(const type_info&) const noexcept override;


private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared() noexcept override;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared_weak() noexcept override;
};



template <class _Tp, class _Dp, class _Alloc>
const void* __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const noexcept {
  return __t == typeid(_Dp) ? std::addressof(__data_.first().second()) : nullptr;
}



template <class _Tp, class _Dp, class _Alloc>
void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept {
  __data_.first().second()(__data_.first().first());
  __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept {
  typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
  typedef allocator_traits<_Al> _ATraits;
  typedef pointer_traits<typename _ATraits::pointer> _PTraits;

  _Al __a(__data_.second());
  __data_.second().~_Alloc();
  __a.deallocate(_PTraits::pointer_to(*this), 1);
}




struct __for_overwrite_tag {};

template <class _Tp, class _Alloc>
struct __shared_ptr_emplace : __shared_weak_count {
  template <class... _Args,
            class _Allocator = _Alloc,
            __enable_if_t<is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __shared_ptr_emplace(_Alloc __a, _Args&&...) : __storage_(std::move(__a)) {
    static_assert(
        sizeof...(_Args) == 0, "No argument should be provided to the control block when using _for_overwrite");
    ::new ((void*)__get_elem()) _Tp;
  }

  template <class... _Args,
            class _Allocator = _Alloc,
            __enable_if_t<!is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __shared_ptr_emplace(_Alloc __a, _Args&&... __args) : __storage_(std::move(__a)) {
    using _TpAlloc = typename __allocator_traits_rebind<_Alloc, _Tp>::type;
    _TpAlloc __tmp(*__get_alloc());
    allocator_traits<_TpAlloc>::construct(__tmp, __get_elem(), std::forward<_Args>(__args)...);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Alloc* __get_alloc() noexcept { return __storage_.__get_alloc(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp* __get_elem() noexcept { return __storage_.__get_elem(); }

private:
  template <class _Allocator = _Alloc,
            __enable_if_t<is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __on_zero_shared_impl() noexcept {
    __get_elem()->~_Tp();
  }

  template <class _Allocator = _Alloc,
            __enable_if_t<!is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __on_zero_shared_impl() noexcept {
    using _TpAlloc = typename __allocator_traits_rebind<_Allocator, _Tp>::type;
    _TpAlloc __tmp(*__get_alloc());
    allocator_traits<_TpAlloc>::destroy(__tmp, __get_elem());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared() noexcept override { __on_zero_shared_impl(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared_weak() noexcept override {
    using _ControlBlockAlloc = typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type;
    using _ControlBlockPointer = typename allocator_traits<_ControlBlockAlloc>::pointer;
    _ControlBlockAlloc __tmp(*__get_alloc());
    __storage_.~_Storage();
    allocator_traits<_ControlBlockAlloc>::deallocate(__tmp, pointer_traits<_ControlBlockPointer>::pointer_to(*this), 1);
  }
# 305 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 3
  using _CompressedPair = __compressed_pair<_Alloc, _Tp>;
  struct alignas(_CompressedPair) _Storage {
    char __blob_[sizeof(_CompressedPair)];

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit _Storage(_Alloc&& __a) { ::new ((void*)__get_alloc()) _Alloc(std::move(__a)); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) ~_Storage() { __get_alloc()->~_Alloc(); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Alloc* __get_alloc() noexcept {
      _CompressedPair* __as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
      typename _CompressedPair::_Base1* __first = _CompressedPair::__get_first_base(__as_pair);
      _Alloc* __alloc = reinterpret_cast<_Alloc*>(__first);
      return __alloc;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__no_sanitize__("cfi"))) _Tp* __get_elem() noexcept {
      _CompressedPair* __as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
      typename _CompressedPair::_Base2* __second = _CompressedPair::__get_second_base(__as_pair);
      _Tp* __elem = reinterpret_cast<_Tp*>(__second);
      return __elem;
    }
  };

  static_assert(alignof(_Storage) == alignof(_CompressedPair), "");
  static_assert(sizeof(_Storage) == sizeof(_CompressedPair), "");
  _Storage __storage_;
};

struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class allocator<__shared_ptr_dummy_rebind_allocator_type> {
public:
  template <class _Other>
  struct rebind {
    typedef allocator<_Other> other;
  };
};

template <class _Tp>
class enable_shared_from_this;





template <class _Yp, class _Tp>
struct __bounded_convertible_to_unbounded : false_type {};

template <class _Up, std::size_t _Np, class _Tp>
struct __bounded_convertible_to_unbounded<_Up[_Np], _Tp> : is_same<__remove_cv_t<_Tp>, _Up[]> {};

template <class _Yp, class _Tp>
struct __compatible_with : _Or< is_convertible<_Yp*, _Tp*>, __bounded_convertible_to_unbounded<_Yp, _Tp> > {};
# 366 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Yp, class _Tp, class = void>
struct __raw_pointer_compatible_with : _And< _Not<is_array<_Tp>>, is_convertible<_Yp*, _Tp*> > {};

template <class _Yp, class _Up, std::size_t _Np>
struct __raw_pointer_compatible_with<_Yp, _Up[_Np], __enable_if_t< is_convertible<_Yp (*)[_Np], _Up (*)[_Np]>::value> >
    : true_type {};

template <class _Yp, class _Up>
struct __raw_pointer_compatible_with<_Yp, _Up[], __enable_if_t< is_convertible<_Yp (*)[], _Up (*)[]>::value> >
    : true_type {};






template <class _Ptr, class = void>
struct __is_deletable : false_type {};
template <class _Ptr>
struct __is_deletable<_Ptr, decltype(delete std::declval<_Ptr>())> : true_type {};

template <class _Ptr, class = void>
struct __is_array_deletable : false_type {};
template <class _Ptr>
struct __is_array_deletable<_Ptr, decltype(delete[] std::declval<_Ptr>())> : true_type {};

template <class _Dp, class _Pt, class = decltype(std::declval<_Dp>()(std::declval<_Pt>()))>
true_type __well_formed_deleter_test(int);

template <class, class>
false_type __well_formed_deleter_test(...);

template <class _Dp, class _Pt>
struct __well_formed_deleter : decltype(std::__well_formed_deleter_test<_Dp, _Pt>(0)) {};

template <class _Dp, class _Yp, class _Tp>
struct __shared_ptr_deleter_ctor_reqs {
  static const bool value = __raw_pointer_compatible_with<_Yp, _Tp>::value && is_move_constructible<_Dp>::value &&
                            __well_formed_deleter<_Dp, _Yp*>::value;
};







template <class _Tp>
class shared_ptr {
public:

  typedef weak_ptr<_Tp> weak_type;
  typedef remove_extent_t<_Tp> element_type;




private:
  element_type* __ptr_;
  __shared_weak_count* __cntrl_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr shared_ptr() noexcept : __ptr_(nullptr), __cntrl_(nullptr) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr shared_ptr(nullptr_t) noexcept : __ptr_(nullptr), __cntrl_(nullptr) {}

  template <class _Yp,
            __enable_if_t< _And< __raw_pointer_compatible_with<_Yp, _Tp>




                                 ,
                                 _If<is_array<_Tp>::value, __is_array_deletable<_Yp*>, __is_deletable<_Yp*> >

                                 >::value,
                           int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit shared_ptr(_Yp* __p) : __ptr_(__p) {
    unique_ptr<_Yp> __hold(__p);
    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __shared_ptr_pointer<_Yp*, __shared_ptr_default_delete<_Tp, _Yp>, _AllocT> _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete<_Tp, _Yp>(), _AllocT());
    __hold.release();
    __enable_weak_this(__p, __p);
  }

  template <class _Yp, class _Dp, __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(_Yp* __p, _Dp __d) : __ptr_(__p) {

    try {

      typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
      typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT> _CntrlBlk;

      __cntrl_ = new _CntrlBlk(__p, std::move(__d), _AllocT());



      __enable_weak_this(__p, __p);

    } catch (...) {
      __d(__p);
      throw;
    }

  }

  template <class _Yp,
            class _Dp,
            class _Alloc,
            __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(_Yp* __p, _Dp __d, _Alloc __a) : __ptr_(__p) {

    try {

      typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
      typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
      typedef __allocator_destructor<_A2> _D2;
      _A2 __a2(__a);
      unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
      ::new ((void*)std::addressof(*__hold2.get()))

          _CntrlBlk(__p, std::move(__d), __a);



      __cntrl_ = std::addressof(*__hold2.release());
      __enable_weak_this(__p, __p);

    } catch (...) {
      __d(__p);
      throw;
    }

  }

  template <class _Dp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(nullptr_t __p, _Dp __d) : __ptr_(nullptr) {

    try {

      typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
      typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT> _CntrlBlk;

      __cntrl_ = new _CntrlBlk(__p, std::move(__d), _AllocT());




    } catch (...) {
      __d(__p);
      throw;
    }

  }

  template <class _Dp, class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a) : __ptr_(nullptr) {

    try {

      typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
      typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
      typedef __allocator_destructor<_A2> _D2;
      _A2 __a2(__a);
      unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
      ::new ((void*)std::addressof(*__hold2.get()))

          _CntrlBlk(__p, std::move(__d), __a);



      __cntrl_ = std::addressof(*__hold2.release());

    } catch (...) {
      __d(__p);
      throw;
    }

  }

  template <class _Yp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept
      : __ptr_(__p),
        __cntrl_(__r.__cntrl_) {
    if (__cntrl_)
      __cntrl_->__add_shared();
  }




  template <class _Yp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(shared_ptr<_Yp>&& __r, element_type* __p) noexcept
      : __ptr_(__p), __cntrl_(__r.__cntrl_) {
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(const shared_ptr& __r) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
    if (__cntrl_)
      __cntrl_->__add_shared();
  }

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(const shared_ptr<_Yp>& __r) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
    if (__cntrl_)
      __cntrl_->__add_shared();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(shared_ptr&& __r) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
  }

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(shared_ptr<_Yp>&& __r) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
  }

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit shared_ptr(const weak_ptr<_Yp>& __r)
      : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_) {
    if (__cntrl_ == nullptr)
      __throw_bad_weak_ptr();
  }
# 605 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 3
  template <class _Yp,
            class _Dp,
            __enable_if_t<!is_lvalue_reference<_Dp>::value && __compatible_with<_Yp, _Tp>::value &&
                              is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(unique_ptr<_Yp, _Dp>&& __r) : __ptr_(__r.get()) {

    if (__ptr_ == nullptr)
      __cntrl_ = nullptr;
    else

    {
      typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
      typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer, _Dp, _AllocT> _CntrlBlk;
      __cntrl_ = new _CntrlBlk(__r.get(), std::move(__r.get_deleter()), _AllocT());
      __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
  }

  template <class _Yp,
            class _Dp,
            class = void,
            __enable_if_t<is_lvalue_reference<_Dp>::value && __compatible_with<_Yp, _Tp>::value &&
                              is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr(unique_ptr<_Yp, _Dp>&& __r) : __ptr_(__r.get()) {

    if (__ptr_ == nullptr)
      __cntrl_ = nullptr;
    else

    {
      typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
      typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer,
                                   reference_wrapper<__libcpp_remove_reference_t<_Dp> >,
                                   _AllocT>
          _CntrlBlk;
      __cntrl_ = new _CntrlBlk(__r.get(), std::ref(__r.get_deleter()), _AllocT());
      __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) ~shared_ptr() {
    if (__cntrl_)
      __cntrl_->__release_shared();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp>& operator=(const shared_ptr& __r) noexcept {
    shared_ptr(__r).swap(*this);
    return *this;
  }

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp>& operator=(const shared_ptr<_Yp>& __r) noexcept {
    shared_ptr(__r).swap(*this);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp>& operator=(shared_ptr&& __r) noexcept {
    shared_ptr(std::move(__r)).swap(*this);
    return *this;
  }

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp>& operator=(shared_ptr<_Yp>&& __r) {
    shared_ptr(std::move(__r)).swap(*this);
    return *this;
  }
# 686 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 3
  template <class _Yp,
            class _Dp,
            __enable_if_t<_And< __compatible_with<_Yp, _Tp>,
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*> >::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp>& operator=(unique_ptr<_Yp, _Dp>&& __r) {
    shared_ptr(std::move(__r)).swap(*this);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void swap(shared_ptr& __r) noexcept {
    std::swap(__ptr_, __r.__ptr_);
    std::swap(__cntrl_, __r.__cntrl_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void reset() noexcept { shared_ptr().swap(*this); }

  template <class _Yp, __enable_if_t<__raw_pointer_compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void reset(_Yp* __p) {
    shared_ptr(__p).swap(*this);
  }

  template <class _Yp, class _Dp, __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void reset(_Yp* __p, _Dp __d) {
    shared_ptr(__p, __d).swap(*this);
  }

  template <class _Yp,
            class _Dp,
            class _Alloc,
            __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void reset(_Yp* __p, _Dp __d, _Alloc __a) {
    shared_ptr(__p, __d, __a).swap(*this);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) element_type* get() const noexcept { return __ptr_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __add_lvalue_reference_t<element_type> operator*() const noexcept { return *__ptr_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) element_type* operator->() const noexcept {
    static_assert(!is_array<_Tp>::value, "std::shared_ptr<T>::operator-> is only valid when T is not an array type.");
    return __ptr_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long use_count() const noexcept { return __cntrl_ ? __cntrl_->use_count() : 0; }





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit operator bool() const noexcept { return get() != nullptr; }

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool owner_before(shared_ptr<_Up> const& __p) const noexcept {
    return __cntrl_ < __p.__cntrl_;
  }

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool owner_before(weak_ptr<_Up> const& __p) const noexcept {
    return __cntrl_ < __p.__cntrl_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool __owner_equivalent(const shared_ptr& __p) const { return __cntrl_ == __p.__cntrl_; }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __add_lvalue_reference_t<element_type> operator[](ptrdiff_t __i) const {
    static_assert(is_array<_Tp>::value, "std::shared_ptr<T>::operator[] is only valid when T is an array type.");
    return __ptr_[__i];
  }



  template <class _Dp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Dp* __get_deleter() const noexcept {
    return static_cast<_Dp*>(__cntrl_ ? const_cast<void*>(__cntrl_->__get_deleter(typeid(_Dp))) : nullptr);
  }


  template <class _Yp, class _CntrlBlk>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static shared_ptr<_Tp> __create_with_control_block(_Yp* __p, _CntrlBlk* __cntrl) noexcept {
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __p;
    __r.__cntrl_ = __cntrl;
    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
    return __r;
  }

private:
  template <class _Yp, bool = is_function<_Yp>::value>
  struct __shared_ptr_default_allocator {
    typedef allocator<_Yp> type;
  };

  template <class _Yp>
  struct __shared_ptr_default_allocator<_Yp, true> {
    typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
  };

  template <class _Yp,
            class _OrigPtr,
            __enable_if_t<is_convertible<_OrigPtr*, const enable_shared_from_this<_Yp>*>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __enable_weak_this(const enable_shared_from_this<_Yp>* __e, _OrigPtr* __ptr) noexcept {
    typedef __remove_cv_t<_Yp> _RawYp;
    if (__e && __e->__weak_this_.expired()) {
      __e->__weak_this_ = shared_ptr<_RawYp>(*this, const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
    }
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __enable_weak_this(...) noexcept {}

  template <class, class _Yp>
  struct __shared_ptr_default_delete : default_delete<_Yp> {};

  template <class _Yp, class _Un, size_t _Sz>
  struct __shared_ptr_default_delete<_Yp[_Sz], _Un> : default_delete<_Yp[]> {};

  template <class _Yp, class _Un>
  struct __shared_ptr_default_delete<_Yp[], _Un> : default_delete<_Yp[]> {};

  template <class _Up>
  friend class shared_ptr;
  template <class _Up>
  friend class weak_ptr;
};


template <class _Tp>
shared_ptr(weak_ptr<_Tp>) -> shared_ptr<_Tp>;
template <class _Tp, class _Dp>
shared_ptr(unique_ptr<_Tp, _Dp>) -> shared_ptr<_Tp>;





template <class _Tp, class _Alloc, class... _Args, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> allocate_shared(const _Alloc& __a, _Args&&... __args) {
  using _ControlBlock = __shared_ptr_emplace<_Tp, _Alloc>;
  using _ControlBlockAllocator = typename __allocator_traits_rebind<_Alloc, _ControlBlock>::type;
  __allocation_guard<_ControlBlockAllocator> __guard(__a, 1);
  ::new ((void*)std::addressof(*__guard.__get())) _ControlBlock(__a, std::forward<_Args>(__args)...);
  auto __control_block = __guard.__release_ptr();
  return shared_ptr<_Tp>::__create_with_control_block(
      (*__control_block).__get_elem(), std::addressof(*__control_block));
}

template <class _Tp, class... _Args, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> make_shared(_Args&&... __args) {
  return std::allocate_shared<_Tp>(allocator<_Tp>(), std::forward<_Args>(__args)...);
}



template <class _Tp, class _Alloc, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> allocate_shared_for_overwrite(const _Alloc& __a) {
  using _ForOverwriteAllocator = __allocator_traits_rebind_t<_Alloc, __for_overwrite_tag>;
  _ForOverwriteAllocator __alloc(__a);
  return std::allocate_shared<_Tp>(__alloc);
}

template <class _Tp, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> make_shared_for_overwrite() {
  return std::allocate_shared_for_overwrite<_Tp>(allocator<_Tp>());
}





template <size_t _Alignment>
struct __sp_aligned_storage {
  alignas(_Alignment) char __storage[_Alignment];
};

template <class _Tp, class _Alloc>
struct __unbounded_array_control_block;

template <class _Tp, class _Alloc>
struct __unbounded_array_control_block<_Tp[], _Alloc> : __shared_weak_count {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* __get_data() noexcept { return __data_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __unbounded_array_control_block(
      _Alloc const& __alloc, size_t __count, _Tp const& __arg)
      : __alloc_(__alloc), __count_(__count) {
    std::__uninitialized_allocator_fill_n_multidimensional(__alloc_, std::begin(__data_), __count_, __arg);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __unbounded_array_control_block(_Alloc const& __alloc, size_t __count)
      : __alloc_(__alloc), __count_(__count) {

    if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {


      std::uninitialized_default_construct_n(std::begin(__data_), __count_);
    } else {
      std::__uninitialized_allocator_value_construct_n_multidimensional(__alloc_, std::begin(__data_), __count_);
    }



  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr size_t __bytes_for(size_t __elements) {






    size_t __bytes = __elements == 0 ? sizeof(__unbounded_array_control_block)
                                               : (__elements - 1) * sizeof(_Tp) + sizeof(__unbounded_array_control_block);
    constexpr size_t __align = alignof(_Tp);
    return (__bytes + __align - 1) & ~(__align - 1);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__))
  ~__unbounded_array_control_block() override {
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared() noexcept override {

    if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {
      std::__reverse_destroy(__data_, __data_ + __count_);
    } else {
      __allocator_traits_rebind_t<_Alloc, _Tp> __value_alloc(__alloc_);
      std::__allocator_destroy_multidimensional(__value_alloc, __data_, __data_ + __count_);
    }




  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared_weak() noexcept override {
    using _AlignedStorage = __sp_aligned_storage<alignof(__unbounded_array_control_block)>;
    using _StorageAlloc = __allocator_traits_rebind_t<_Alloc, _AlignedStorage>;
    using _PointerTraits = pointer_traits<typename allocator_traits<_StorageAlloc>::pointer>;

    _StorageAlloc __tmp(__alloc_);
    __alloc_.~_Alloc();
    size_t __size = __unbounded_array_control_block::__bytes_for(__count_);
    _AlignedStorage* __storage = reinterpret_cast<_AlignedStorage*>(this);
    allocator_traits<_StorageAlloc>::deallocate(
        __tmp, _PointerTraits::pointer_to(*__storage), __size / sizeof(_AlignedStorage));
  }

  [[__no_unique_address__]] _Alloc __alloc_;
  size_t __count_;
  union {
    _Tp __data_[1];
  };
};

template <class _Array, class _Alloc, class... _Arg>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Array>
__allocate_shared_unbounded_array(const _Alloc& __a, size_t __n, _Arg&&... __arg) {
  static_assert(__libcpp_is_unbounded_array<_Array>::value);




  using _ControlBlock = __unbounded_array_control_block<_Array, _Alloc>;
  using _AlignedStorage = __sp_aligned_storage<alignof(_ControlBlock)>;
  using _StorageAlloc = __allocator_traits_rebind_t<_Alloc, _AlignedStorage>;
  __allocation_guard<_StorageAlloc> __guard(__a, _ControlBlock::__bytes_for(__n) / sizeof(_AlignedStorage));
  _ControlBlock* __control_block = reinterpret_cast<_ControlBlock*>(std::addressof(*__guard.__get()));
  std::__construct_at(__control_block, __a, __n, std::forward<_Arg>(__arg)...);
  __guard.__release_ptr();
  return shared_ptr<_Array>::__create_with_control_block(__control_block->__get_data(), __control_block);
}

template <class _Tp, class _Alloc>
struct __bounded_array_control_block;

template <class _Tp, size_t _Count, class _Alloc>
struct __bounded_array_control_block<_Tp[_Count], _Alloc> : __shared_weak_count {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* __get_data() noexcept { return __data_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __bounded_array_control_block(_Alloc const& __alloc, _Tp const& __arg)
      : __alloc_(__alloc) {
    std::__uninitialized_allocator_fill_n_multidimensional(__alloc_, std::addressof(__data_[0]), _Count, __arg);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __bounded_array_control_block(_Alloc const& __alloc) : __alloc_(__alloc) {

    if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {


      std::uninitialized_default_construct_n(std::addressof(__data_[0]), _Count);
    } else {
      std::__uninitialized_allocator_value_construct_n_multidimensional(__alloc_, std::addressof(__data_[0]), _Count);
    }



  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__))
  ~__bounded_array_control_block() override {
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared() noexcept override {

    if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {
      std::__reverse_destroy(__data_, __data_ + _Count);
    } else {
      __allocator_traits_rebind_t<_Alloc, _Tp> __value_alloc(__alloc_);
      std::__allocator_destroy_multidimensional(__value_alloc, __data_, __data_ + _Count);
    }




  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared_weak() noexcept override {
    using _ControlBlockAlloc = __allocator_traits_rebind_t<_Alloc, __bounded_array_control_block>;
    using _PointerTraits = pointer_traits<typename allocator_traits<_ControlBlockAlloc>::pointer>;

    _ControlBlockAlloc __tmp(__alloc_);
    __alloc_.~_Alloc();
    allocator_traits<_ControlBlockAlloc>::deallocate(__tmp, _PointerTraits::pointer_to(*this), 1);
  }

  [[__no_unique_address__]] _Alloc __alloc_;
  union {
    _Tp __data_[_Count];
  };
};

template <class _Array, class _Alloc, class... _Arg>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Array> __allocate_shared_bounded_array(const _Alloc& __a, _Arg&&... __arg) {
  static_assert(__libcpp_is_bounded_array<_Array>::value);
  using _ControlBlock = __bounded_array_control_block<_Array, _Alloc>;
  using _ControlBlockAlloc = __allocator_traits_rebind_t<_Alloc, _ControlBlock>;

  __allocation_guard<_ControlBlockAlloc> __guard(__a, 1);
  _ControlBlock* __control_block = reinterpret_cast<_ControlBlock*>(std::addressof(*__guard.__get()));
  std::__construct_at(__control_block, __a, std::forward<_Arg>(__arg)...);
  __guard.__release_ptr();
  return shared_ptr<_Array>::__create_with_control_block(__control_block->__get_data(), __control_block);
}






template <class _Tp, class _Alloc, __enable_if_t<is_bounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> allocate_shared(const _Alloc& __a) {
  return std::__allocate_shared_bounded_array<_Tp>(__a);
}

template <class _Tp, class _Alloc, __enable_if_t<is_bounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> allocate_shared(const _Alloc& __a, const remove_extent_t<_Tp>& __u) {
  return std::__allocate_shared_bounded_array<_Tp>(__a, __u);
}

template <class _Tp, class _Alloc, __enable_if_t<is_bounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> allocate_shared_for_overwrite(const _Alloc& __a) {
  using _ForOverwriteAllocator = __allocator_traits_rebind_t<_Alloc, __for_overwrite_tag>;
  _ForOverwriteAllocator __alloc(__a);
  return std::__allocate_shared_bounded_array<_Tp>(__alloc);
}

template <class _Tp, __enable_if_t<is_bounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> make_shared() {
  return std::__allocate_shared_bounded_array<_Tp>(allocator<_Tp>());
}

template <class _Tp, __enable_if_t<is_bounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> make_shared(const remove_extent_t<_Tp>& __u) {
  return std::__allocate_shared_bounded_array<_Tp>(allocator<_Tp>(), __u);
}

template <class _Tp, __enable_if_t<is_bounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> make_shared_for_overwrite() {
  return std::__allocate_shared_bounded_array<_Tp>(allocator<__for_overwrite_tag>());
}


template <class _Tp, class _Alloc, __enable_if_t<is_unbounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> allocate_shared(const _Alloc& __a, size_t __n) {
  return std::__allocate_shared_unbounded_array<_Tp>(__a, __n);
}

template <class _Tp, class _Alloc, __enable_if_t<is_unbounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> allocate_shared(const _Alloc& __a, size_t __n, const remove_extent_t<_Tp>& __u) {
  return std::__allocate_shared_unbounded_array<_Tp>(__a, __n, __u);
}

template <class _Tp, class _Alloc, __enable_if_t<is_unbounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> allocate_shared_for_overwrite(const _Alloc& __a, size_t __n) {
  using _ForOverwriteAllocator = __allocator_traits_rebind_t<_Alloc, __for_overwrite_tag>;
  _ForOverwriteAllocator __alloc(__a);
  return std::__allocate_shared_unbounded_array<_Tp>(__alloc, __n);
}

template <class _Tp, __enable_if_t<is_unbounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> make_shared(size_t __n) {
  return std::__allocate_shared_unbounded_array<_Tp>(allocator<_Tp>(), __n);
}

template <class _Tp, __enable_if_t<is_unbounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> make_shared(size_t __n, const remove_extent_t<_Tp>& __u) {
  return std::__allocate_shared_unbounded_array<_Tp>(allocator<_Tp>(), __n, __u);
}

template <class _Tp, __enable_if_t<is_unbounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> make_shared_for_overwrite(size_t __n) {
  return std::__allocate_shared_unbounded_array<_Tp>(allocator<__for_overwrite_tag>(), __n);
}



template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept {
  return __x.get() == __y.get();
}
# 1145 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) strong_ordering operator<=>(shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) noexcept {
  return compare_three_way()(__x.get(), __y.get());
}


template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator==(const shared_ptr<_Tp>& __x, nullptr_t) noexcept {
  return !__x;
}
# 1216 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) strong_ordering operator<=>(shared_ptr<_Tp> const& __x, nullptr_t) noexcept {
  return compare_three_way()(__x.get(), static_cast<typename shared_ptr<_Tp>::element_type*>(nullptr));
}


template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) noexcept {
  __x.swap(__y);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> static_pointer_cast(const shared_ptr<_Up>& __r) noexcept {
  return shared_ptr<_Tp>(__r, static_cast< typename shared_ptr<_Tp>::element_type*>(__r.get()));
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> static_pointer_cast(shared_ptr<_Up>&& __r) noexcept {
  return shared_ptr<_Tp>(std::move(__r), static_cast<typename shared_ptr<_Tp>::element_type*>(__r.get()));
}


template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept {
  typedef typename shared_ptr<_Tp>::element_type _ET;
  _ET* __p = dynamic_cast<_ET*>(__r.get());
  return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> dynamic_pointer_cast(shared_ptr<_Up>&& __r) noexcept {
  auto* __p = dynamic_cast<typename shared_ptr<_Tp>::element_type*>(__r.get());
  return __p ? shared_ptr<_Tp>(std::move(__r), __p) : shared_ptr<_Tp>();
}


template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> const_pointer_cast(const shared_ptr<_Up>& __r) noexcept {
  typedef typename shared_ptr<_Tp>::element_type _RTp;
  return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> const_pointer_cast(shared_ptr<_Up>&& __r) noexcept {
  return shared_ptr<_Tp>(std::move(__r), const_cast<typename shared_ptr<_Tp>::element_type*>(__r.get()));
}


template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> reinterpret_pointer_cast(const shared_ptr<_Up>& __r) noexcept {
  return shared_ptr<_Tp>(__r, reinterpret_cast< typename shared_ptr<_Tp>::element_type*>(__r.get()));
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> reinterpret_pointer_cast(shared_ptr<_Up>&& __r) noexcept {
  return shared_ptr<_Tp>(std::move(__r), reinterpret_cast<typename shared_ptr<_Tp>::element_type*>(__r.get()));
}




template <class _Dp, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Dp* get_deleter(const shared_ptr<_Tp>& __p) noexcept {
  return __p.template __get_deleter<_Dp>();
}



template <class _Tp>
class weak_ptr {
public:

  typedef remove_extent_t<_Tp> element_type;




private:
  element_type* __ptr_;
  __shared_weak_count* __cntrl_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr weak_ptr() noexcept;

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr(shared_ptr<_Yp> const& __r) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr(weak_ptr const& __r) noexcept;

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr(weak_ptr<_Yp> const& __r) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr(weak_ptr&& __r) noexcept;

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr(weak_ptr<_Yp>&& __r) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) ~weak_ptr();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr& operator=(weak_ptr const& __r) noexcept;
  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr& operator=(weak_ptr<_Yp> const& __r) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr& operator=(weak_ptr&& __r) noexcept;
  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr& operator=(weak_ptr<_Yp>&& __r) noexcept;

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr& operator=(shared_ptr<_Yp> const& __r) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void swap(weak_ptr& __r) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void reset() noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) long use_count() const noexcept { return __cntrl_ ? __cntrl_->use_count() : 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool expired() const noexcept { return __cntrl_ == nullptr || __cntrl_->use_count() == 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> lock() const noexcept;
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool owner_before(const shared_ptr<_Up>& __r) const noexcept {
    return __cntrl_ < __r.__cntrl_;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool owner_before(const weak_ptr<_Up>& __r) const noexcept {
    return __cntrl_ < __r.__cntrl_;
  }

  template <class _Up>
  friend class weak_ptr;
  template <class _Up>
  friend class shared_ptr;
};


template <class _Tp>
weak_ptr(shared_ptr<_Tp>) -> weak_ptr<_Tp>;


template <class _Tp>
inline constexpr weak_ptr<_Tp>::weak_ptr() noexcept : __ptr_(nullptr), __cntrl_(nullptr) {}

template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r) noexcept : __ptr_(nullptr), __cntrl_(nullptr) {
  shared_ptr<_Yp> __s = __r.lock();
  *this = weak_ptr<_Tp>(__s);
}

template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) noexcept : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = nullptr;
  __r.__cntrl_ = nullptr;
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r) noexcept : __ptr_(nullptr), __cntrl_(nullptr) {
  shared_ptr<_Yp> __s = __r.lock();
  *this = weak_ptr<_Tp>(__s);
  __r.reset();
}

template <class _Tp>
weak_ptr<_Tp>::~weak_ptr() {
  if (__cntrl_)
    __cntrl_->__release_weak();
}

template <class _Tp>
inline weak_ptr<_Tp>& weak_ptr<_Tp>::operator=(weak_ptr const& __r) noexcept {
  weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>& weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) noexcept {
  weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
inline weak_ptr<_Tp>& weak_ptr<_Tp>::operator=(weak_ptr&& __r) noexcept {
  weak_ptr(std::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>& weak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) noexcept {
  weak_ptr(std::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>& weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) noexcept {
  weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
inline void weak_ptr<_Tp>::swap(weak_ptr& __r) noexcept {
  std::swap(__ptr_, __r.__ptr_);
  std::swap(__cntrl_, __r.__cntrl_);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) noexcept {
  __x.swap(__y);
}

template <class _Tp>
inline void weak_ptr<_Tp>::reset() noexcept {
  weak_ptr().swap(*this);
}

template <class _Tp>
shared_ptr<_Tp> weak_ptr<_Tp>::lock() const noexcept {
  shared_ptr<_Tp> __r;
  __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
  if (__r.__cntrl_)
    __r.__ptr_ = __ptr_;
  return __r;
}


template <class _Tp = void>
struct owner_less;





template <class _Tp>
struct owner_less<shared_ptr<_Tp> > : __binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept {
    return __x.owner_before(__y);
  }
};

template <class _Tp>
struct owner_less<weak_ptr<_Tp> > : __binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept {
    return __x.owner_before(__y);
  }
};


template <>
struct owner_less<void> {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept {
    return __x.owner_before(__y);
  }
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept {
    return __x.owner_before(__y);
  }
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept {
    return __x.owner_before(__y);
  }
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(weak_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept {
    return __x.owner_before(__y);
  }
  typedef void is_transparent;
};


template <class _Tp>
class enable_shared_from_this {
  mutable weak_ptr<_Tp> __weak_this_;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr enable_shared_from_this() noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) enable_shared_from_this(enable_shared_from_this const&) noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) ~enable_shared_from_this() {}

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> shared_from_this() { return shared_ptr<_Tp>(__weak_this_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp const> shared_from_this() const { return shared_ptr<const _Tp>(__weak_this_); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr<_Tp> weak_from_this() noexcept { return __weak_this_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) weak_ptr<const _Tp> weak_from_this() const noexcept { return __weak_this_; }


  template <class _Up>
  friend class shared_ptr;
};

template <class _Tp>
struct hash;

template <class _Tp>
struct hash<shared_ptr<_Tp> > {





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(const shared_ptr<_Tp>& __ptr) const noexcept {
    return hash<typename shared_ptr<_Tp>::element_type*>()(__ptr.get());
  }
};

template <class _CharT, class _Traits, class _Yp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);



class __attribute__((__visibility__("default"))) __sp_mut {
  void* __lx_;

public:
  void lock() noexcept;
  void unlock() noexcept;

private:
  constexpr __sp_mut(void*) noexcept;
  __sp_mut(const __sp_mut&);
  __sp_mut& operator=(const __sp_mut&);

  friend __attribute__((__visibility__("default"))) __sp_mut& __get_sp_mut(const void*);
};

__attribute__((__visibility__("default"))) __sp_mut& __get_sp_mut(const void*);

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool atomic_is_lock_free(const shared_ptr<_Tp>*) {
  return false;
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> atomic_load(const shared_ptr<_Tp>* __p) {
  __sp_mut& __m = std::__get_sp_mut(__p);
  __m.lock();
  shared_ptr<_Tp> __q = *__p;
  __m.unlock();
  return __q;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order) {
  return std::atomic_load(__p);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r) {
  __sp_mut& __m = std::__get_sp_mut(__p);
  __m.lock();
  __p->swap(__r);
  __m.unlock();
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order) {
  std::atomic_store(__p, __r);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp> atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r) {
  __sp_mut& __m = std::__get_sp_mut(__p);
  __m.lock();
  __p->swap(__r);
  __m.unlock();
  return __r;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) shared_ptr<_Tp>
atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order) {
  return std::atomic_exchange(__p, __r);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool
atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w) {
  shared_ptr<_Tp> __temp;
  __sp_mut& __m = std::__get_sp_mut(__p);
  __m.lock();
  if (__p->__owner_equivalent(*__v)) {
    std::swap(__temp, *__p);
    *__p = __w;
    __m.unlock();
    return true;
  }
  std::swap(__temp, *__v);
  *__v = *__p;
  __m.unlock();
  return false;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool
atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w) {
  return std::atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool atomic_compare_exchange_strong_explicit(
    shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w, memory_order, memory_order) {
  return std::atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool atomic_compare_exchange_weak_explicit(
    shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w, memory_order, memory_order) {
  return std::atomic_compare_exchange_weak(__p, __v, __w);
}



}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__mutex/once_flag.h" 1 3
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__mutex/once_flag.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/tuple" 1 3
# 214 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/tuple" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_arg_t.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_arg_t.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uses_allocator.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/uses_allocator.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
struct __has_allocator_type {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type __test(typename _Up::allocator_type* = 0);

public:
  static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator : public integral_constant<bool, is_convertible<_Alloc, typename _Tp::allocator_type>::value> {
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false> : public false_type {};

template <class _Tp, class _Alloc>
struct uses_allocator : public __uses_allocator<_Tp, _Alloc> {};


template <class _Tp, class _Alloc>
inline constexpr bool uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;


}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_arg_t.h" 2 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_arg_t.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

struct allocator_arg_t {
  explicit allocator_arg_t() = default;
};


inline constexpr allocator_arg_t allocator_arg = allocator_arg_t();
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/allocator_arg_t.h" 3
template <class _Tp, class _Alloc, class... _Args>
struct __uses_alloc_ctor_imp {
  typedef __attribute__((__nodebug__)) __remove_cvref_t<_Alloc> _RawAlloc;
  static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
  static const bool __ic = is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
  static const int value = __ua ? 2 - __ic : 0;
};

template <class _Tp, class _Alloc, class... _Args>
struct __uses_alloc_ctor : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value> {};

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void
__user_alloc_construct_impl(integral_constant<int, 0>, _Tp* __storage, const _Allocator&, _Args&&... __args) {
  new (__storage) _Tp(std::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void
__user_alloc_construct_impl(integral_constant<int, 1>, _Tp* __storage, const _Allocator& __a, _Args&&... __args) {
  new (__storage) _Tp(allocator_arg, __a, std::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void
__user_alloc_construct_impl(integral_constant<int, 2>, _Tp* __storage, const _Allocator& __a, _Args&&... __args) {
  new (__storage) _Tp(std::forward<_Args>(__args)..., __a);
}



}}
# 215 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/tuple" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/find_index.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__tuple/find_index.h" 3




 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

namespace __find_detail {

static constexpr size_t __not_found = static_cast<size_t>(-1);
static constexpr size_t __ambiguous = __not_found - 1;

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
  return !__matches ? __res : (__res == __not_found ? __curr_i : __ambiguous);
}

template <size_t _Nx>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
  return __i == _Nx
           ? __not_found
           : __find_detail::__find_idx_return(__i, __find_detail::__find_idx(__i + 1, __matches), __matches[__i]);
}

template <class _T1, class... _Args>
struct __find_exactly_one_checked {
  static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};
  static constexpr size_t value = __find_detail::__find_idx(0, __matches);
  static_assert(value != __not_found, "type not found in type list");
  static_assert(value != __ambiguous, "type occurs more than once in type list");
};

template <class _T1>
struct __find_exactly_one_checked<_T1> {
  static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
};

}

template <typename _T1, typename... _Args>
struct __find_exactly_one_t : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {};

}}
# 217 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/tuple" 2 3
# 275 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/tuple" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 279 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/tuple" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {





template <size_t _Ip, class _Hp, bool = is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value >
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    noexcept(__is_nothrow_swappable<_Hp>::value) {
  swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
swap(const __tuple_leaf<_Ip, _Hp, _Ep>& __x, const __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    noexcept(__is_nothrow_swappable<const _Hp>::value) {
  swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool>
class __tuple_leaf {
  _Hp __value_;

  template <class _Tp>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __can_bind_reference() {

    return !__reference_binds_to_temporary(_Hp, _Tp);



  }

  constexpr __tuple_leaf& operator=(const __tuple_leaf&);

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __tuple_leaf() noexcept(is_nothrow_default_constructible<_Hp>::value) : __value_() {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __tuple_leaf(integral_constant<int, 0>, const _Alloc&) : __value_() {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
      : __value_(allocator_arg_t(), __a) {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a) : __value_(__a) {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <class _Tp,
            __enable_if_t<_And<_IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>, is_constructible<_Hp, _Tp> >::value,
                           int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
  constexpr explicit __tuple_leaf(_Tp&& __t) noexcept(is_nothrow_constructible<_Hp, _Tp>::value)
      : __value_(std::forward<_Tp>(__t)) {
    static_assert(__can_bind_reference<_Tp&&>(),
                  "Attempted construction of reference element binds to a temporary whose lifetime has ended");
  }

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __tuple_leaf(
      integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
      : __value_(std::forward<_Tp>(__t)) {
    static_assert(__can_bind_reference<_Tp&&>(),
                  "Attempted construction of reference element binds to a temporary whose lifetime has ended");
  }

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __tuple_leaf(
      integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
      : __value_(allocator_arg_t(), __a, std::forward<_Tp>(__t)) {
    static_assert(!is_reference<_Hp>::value, "Attempted to uses-allocator construct a reference element in a tuple");
  }

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __tuple_leaf(
      integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
      : __value_(std::forward<_Tp>(__t), __a) {
    static_assert(!is_reference<_Hp>::value, "Attempted to uses-allocator construct a reference element in a tuple");
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __tuple_leaf(const __tuple_leaf& __t) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __tuple_leaf(__tuple_leaf&& __t) = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int swap(__tuple_leaf& __t)
      noexcept(__is_nothrow_swappable<__tuple_leaf>::value) {
    std::swap(*this, __t);
    return 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int swap(const __tuple_leaf& __t) const
      noexcept(__is_nothrow_swappable<const __tuple_leaf>::value) {
    std::swap(*this, __t);
    return 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Hp& get() noexcept { return __value_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Hp& get() const noexcept { return __value_; }
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true> : private _Hp {
  constexpr __tuple_leaf& operator=(const __tuple_leaf&);

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __tuple_leaf() noexcept(is_nothrow_default_constructible<_Hp>::value) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
      : _Hp(allocator_arg_t(), __a) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a) : _Hp(__a) {}

  template <class _Tp,
            __enable_if_t< _And< _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>, is_constructible<_Hp, _Tp> >::value,
                           int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
  constexpr explicit __tuple_leaf(_Tp&& __t) noexcept(is_nothrow_constructible<_Hp, _Tp>::value)
      : _Hp(std::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
      : _Hp(std::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
      : _Hp(allocator_arg_t(), __a, std::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
      : _Hp(std::forward<_Tp>(__t), __a) {}

  __tuple_leaf(__tuple_leaf const&) = default;
  __tuple_leaf(__tuple_leaf&&) = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int swap(__tuple_leaf& __t)
      noexcept(__is_nothrow_swappable<__tuple_leaf>::value) {
    std::swap(*this, __t);
    return 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int swap(const __tuple_leaf& __rhs) const
      noexcept(__is_nothrow_swappable<const __tuple_leaf>::value) {
    std::swap(*this, __rhs);
    return 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Hp& get() noexcept { return static_cast<_Hp&>(*this); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Hp& get() const noexcept {
    return static_cast<const _Hp&>(*this);
  }
};

template <class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __swallow(_Tp&&...) noexcept {}

template <class _Tp>
struct __all_default_constructible;

template <class... _Tp>
struct __all_default_constructible<__tuple_types<_Tp...>> : __all<is_default_constructible<_Tp>::value...> {};



template <class _Indx, class... _Tp>
struct __tuple_impl;

template <size_t... _Indx, class... _Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>... {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __tuple_impl()
      noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

  template <size_t... _Uf, class... _Tf, size_t... _Ul, class... _Tl, class... _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __tuple_impl(
      __tuple_indices<_Uf...>, __tuple_types<_Tf...>, __tuple_indices<_Ul...>, __tuple_types<_Tl...>, _Up&&... __u)
      noexcept(__all<is_nothrow_constructible<_Tf, _Up>::value...>::value&& __all<is_nothrow_default_constructible<_Tl>::value...>::value)

      : __tuple_leaf<_Uf, _Tf>(std::forward<_Up>(__u))..., __tuple_leaf<_Ul, _Tl>()... {}

  template <class _Alloc, size_t... _Uf, class... _Tf, size_t... _Ul, class... _Tl, class... _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __tuple_impl(
      allocator_arg_t,
      const _Alloc& __a,
      __tuple_indices<_Uf...>,
      __tuple_types<_Tf...>,
      __tuple_indices<_Ul...>,
      __tuple_types<_Tl...>,
      _Up&&... __u)
      : __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a, std::forward<_Up>(__u))...,
        __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)... {}

  template <class _Tuple, __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __tuple_impl(_Tuple&& __t) noexcept((__all<is_nothrow_constructible< _Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))



      : __tuple_leaf<_Indx, _Tp>(
            std::forward<typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(
                std::get<_Indx>(__t)))... {}

  template <class _Alloc, class _Tuple, __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
      : __tuple_leaf<_Indx, _Tp>(
            __uses_alloc_ctor<_Tp,
                              _Alloc,
                              typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(),
            __a,
            std::forward<typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(
                std::get<_Indx>(__t)))... {}

  __tuple_impl(const __tuple_impl&) = default;
  __tuple_impl(__tuple_impl&&) = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(__tuple_impl& __t)
      noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
    std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(const __tuple_impl& __t) const
      noexcept(__all<__is_nothrow_swappable<const _Tp>::value...>::value) {
    std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t))...);
  }
};

template <class _Dest, class _Source, size_t... _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__memberwise_copy_assign(_Dest& __dest, _Source const& __source, __tuple_indices<_Np...>) {
  std::__swallow(((std::get<_Np>(__dest) = std::get<_Np>(__source)), void(), 0)...);
}

template <class _Dest, class _Source, class... _Up, size_t... _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__memberwise_forward_assign(_Dest& __dest, _Source&& __source, __tuple_types<_Up...>, __tuple_indices<_Np...>) {
  std::__swallow(((std::get<_Np>(__dest) = std::forward<_Up>(std::get<_Np>(__source))), void(), 0)...);
}

template <class... _Tp>
class tuple {
  typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;

  _BaseT __base_;

  template <size_t _Jp, class... _Up>
  friend constexpr typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) noexcept;
  template <size_t _Jp, class... _Up>
  friend constexpr const typename tuple_element<_Jp, tuple<_Up...> >::type&
  get(const tuple<_Up...>&) noexcept;
  template <size_t _Jp, class... _Up>
  friend constexpr typename tuple_element<_Jp, tuple<_Up...> >::type&&
  get(tuple<_Up...>&&) noexcept;
  template <size_t _Jp, class... _Up>
  friend constexpr const typename tuple_element<_Jp, tuple<_Up...> >::type&&
  get(const tuple<_Up...>&&) noexcept;

public:



  template <template <class...> class _IsImpDefault = __is_implicitly_default_constructible,
            template <class...> class _IsDefault = is_default_constructible,
            __enable_if_t< _And< _IsDefault<_Tp>... >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(_Not<_Lazy<_And, _IsImpDefault<_Tp>...> >::value) tuple()
      noexcept(_And<is_nothrow_default_constructible<_Tp>...>::value) {}

  template <class _Alloc,
            template <class...> class _IsImpDefault = __is_implicitly_default_constructible,
            template <class...> class _IsDefault = is_default_constructible,
            __enable_if_t< _And< _IsDefault<_Tp>... >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(_Not<_Lazy<_And, _IsImpDefault<_Tp>...> >::value)
      tuple(allocator_arg_t, _Alloc const& __a)
      : __base_(allocator_arg_t(),
                __a,
                __tuple_indices<>(),
                __tuple_types<>(),
                typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                __tuple_types<_Tp...>()) {}


  template <template <class...> class _And = _And,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) >= 1>, is_copy_constructible<_Tp>... >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >::value) tuple(const _Tp&... __t)
      noexcept(_And<is_nothrow_copy_constructible<_Tp>...>::value)
      : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...) {}

  template <class _Alloc,
            template <class...> class _And = _And,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) >= 1>, is_copy_constructible<_Tp>... >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp&... __t)
      : __base_(allocator_arg_t(),
                __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...) {}


  template <class... _Up>
  struct _IsThisTuple : false_type {};
  template <class _Up>
  struct _IsThisTuple<_Up> : is_same<__remove_cvref_t<_Up>, tuple> {};

  template <class... _Up>
  struct _EnableUTypesCtor
      : _And< _BoolConstant<sizeof...(_Tp) >= 1>,
              _Not<_IsThisTuple<_Up...> >,
              is_constructible<_Tp, _Up>... > {};

  template <class... _Up,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>, _EnableUTypesCtor<_Up...> >::value,
                           int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(_Up&&... __u) noexcept(_And<is_nothrow_constructible<_Tp, _Up>...>::value)
      : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                std::forward<_Up>(__u)...) {}

  template <class _Alloc,
            class... _Up,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>, _EnableUTypesCtor<_Up...> >::value,
                           int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
      : __base_(allocator_arg_t(),
                __a,
                typename __make_tuple_indices<sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                std::forward<_Up>(__u)...) {}


  tuple(const tuple&) = default;
  tuple(tuple&&) = default;

  template <class _Alloc,
            template <class...> class _And = _And,
            __enable_if_t< _And<is_copy_constructible<_Tp>...>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple(allocator_arg_t, const _Alloc& __alloc, const tuple& __t)
      : __base_(allocator_arg_t(), __alloc, __t) {}

  template <class _Alloc,
            template <class...> class _And = _And,
            __enable_if_t< _And<is_move_constructible<_Tp>...>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple(allocator_arg_t, const _Alloc& __alloc, tuple&& __t)
      : __base_(allocator_arg_t(), __alloc, std::move(__t)) {}



  template <class _OtherTuple, class _DecayedOtherTuple = __remove_cvref_t<_OtherTuple>, class = void>
  struct _EnableCtorFromUTypesTuple : false_type {};

  template <class _OtherTuple, class... _Up>
  struct _EnableCtorFromUTypesTuple<
      _OtherTuple,
      tuple<_Up...>,

      __enable_if_t<sizeof...(_Up) == sizeof...(_Tp)>>
      : _And<



            _Not<is_same<_OtherTuple, const tuple&> >,
            _Not<is_same<_OtherTuple, tuple&&> >,
            is_constructible<_Tp, __copy_cvref_t<_OtherTuple, _Up> >...,
            _Lazy<_Or,
                  _BoolConstant<sizeof...(_Tp) != 1>,


                  _Lazy<_And,
                        _Not<is_same<_Tp, _Up> >...,
                        _Not<is_convertible<_OtherTuple, _Tp> >...,
                        _Not<is_constructible<_Tp, _OtherTuple> >... > > > {};

  template <class... _Up, __enable_if_t< _And< _EnableCtorFromUTypesTuple<const tuple<_Up...>&> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >::value) tuple(const tuple<_Up...>& __t)
      noexcept(_And<is_nothrow_constructible<_Tp, const _Up&>...>::value)
      : __base_(__t) {}

  template <class... _Up,
            class _Alloc,
            __enable_if_t< _And< _EnableCtorFromUTypesTuple<const tuple<_Up...>&> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
      : __base_(allocator_arg_t(), __a, __t) {}




  template <class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_Lazy<_And, is_convertible<_Up&, _Tp>...>::value) tuple(tuple<_Up...>& __t)
      : __base_(__t) {}

  template <class _Alloc, class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_Lazy<_And, is_convertible<_Up&, _Tp>...>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, tuple<_Up...>& __t)
      : __base_(allocator_arg_t(), __alloc, __t) {}



  template <class... _Up, __enable_if_t< _And< _EnableCtorFromUTypesTuple<tuple<_Up...>&&> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(tuple<_Up...>&& __t) noexcept(_And<is_nothrow_constructible<_Tp, _Up>...>::value)
      : __base_(std::move(__t)) {}

  template <class _Alloc,
            class... _Up,
            __enable_if_t< _And< _EnableCtorFromUTypesTuple<tuple<_Up...>&&> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
      : __base_(allocator_arg_t(), __a, std::move(__t)) {}




  template <class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_Lazy<_And, is_convertible<const _Up&&, _Tp>...>::value)
      tuple(const tuple<_Up...>&& __t)
      : __base_(std::move(__t)) {}

  template <class _Alloc,
            class... _Up,
            enable_if_t< _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_Lazy<_And, is_convertible<const _Up&&, _Tp>...>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, const tuple<_Up...>&& __t)
      : __base_(allocator_arg_t(), __alloc, std::move(__t)) {}




  template <template <class...> class _Pred,
            class _Pair,
            class _DecayedPair = __remove_cvref_t<_Pair>,
            class _Tuple = tuple>
  struct _CtorPredicateFromPair : false_type {};

  template <template <class...> class _Pred, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
  struct _CtorPredicateFromPair<_Pred, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
      : _And< _Pred<_Tp1, __copy_cvref_t<_Pair, _Up1> >, _Pred<_Tp2, __copy_cvref_t<_Pair, _Up2> > > {};

  template <class _Pair>
  struct _EnableCtorFromPair : _CtorPredicateFromPair<is_constructible, _Pair> {};

  template <class _Pair>
  struct _NothrowConstructibleFromPair : _CtorPredicateFromPair<is_nothrow_constructible, _Pair> {};

  template <class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
  struct _BothImplicitlyConvertible : false_type {};

  template <class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
  struct _BothImplicitlyConvertible<_Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
      : _And< is_convertible<__copy_cvref_t<_Pair, _Up1>, _Tp1>, is_convertible<__copy_cvref_t<_Pair, _Up2>, _Tp2> > {};

  template <class _Up1,
            class _Up2,
            template <class...> class _And = _And,
            __enable_if_t< _And< _EnableCtorFromPair<const pair<_Up1, _Up2>&> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >::value) tuple(const pair<_Up1, _Up2>& __p)
      noexcept(_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value)
      : __base_(__p) {}

  template <class _Alloc,
            class _Up1,
            class _Up2,
            template <class...> class _And = _And,
            __enable_if_t< _And< _EnableCtorFromPair<const pair<_Up1, _Up2>&> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
      : __base_(allocator_arg_t(), __a, __p) {}




  template <class _U1, class _U2, enable_if_t< _EnableCtorFromPair<pair<_U1, _U2>&>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
      tuple(pair<_U1, _U2>& __p)
      : __base_(__p) {}

  template <class _Alloc,
            class _U1,
            class _U2,
            enable_if_t< _EnableCtorFromPair<std::pair<_U1, _U2>&>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, pair<_U1, _U2>& __p)
      : __base_(allocator_arg_t(), __alloc, __p) {}




  template <class _Up1,
            class _Up2,
            template <class...> class _And = _And,
            __enable_if_t< _And< _EnableCtorFromPair<pair<_Up1, _Up2>&&> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >::value) tuple(pair<_Up1, _Up2>&& __p)
      noexcept(_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value)
      : __base_(std::move(__p)) {}

  template <class _Alloc,
            class _Up1,
            class _Up2,
            template <class...> class _And = _And,
            __enable_if_t< _And< _EnableCtorFromPair<pair<_Up1, _Up2>&&> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(
      _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
      : __base_(allocator_arg_t(), __a, std::move(__p)) {}




  template <class _U1, class _U2, enable_if_t< _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
      tuple(const pair<_U1, _U2>&& __p)
      : __base_(std::move(__p)) {}

  template <class _Alloc,
            class _U1,
            class _U2,
            enable_if_t< _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, const pair<_U1, _U2>&& __p)
      : __base_(allocator_arg_t(), __alloc, std::move(__p)) {}



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple&
  operator=(_If<_And<is_copy_assignable<_Tp>...>::value, tuple, __nat> const& __tuple)
      noexcept(_And<is_nothrow_copy_assignable<_Tp>...>::value) {
    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const tuple& operator=(tuple const& __tuple) const
    requires(_And<is_copy_assignable<const _Tp>...>::value)
  {
    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const tuple& operator=(tuple&& __tuple) const
    requires(_And<is_assignable<const _Tp&, _Tp>...>::value)
  {
    std::__memberwise_forward_assign(
        *this, std::move(__tuple), __tuple_types<_Tp...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple&
  operator=(_If<_And<is_move_assignable<_Tp>...>::value, tuple, __nat>&& __tuple)
      noexcept(_And<is_nothrow_move_assignable<_Tp>...>::value) {
    std::__memberwise_forward_assign(
        *this, std::move(__tuple), __tuple_types<_Tp...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  template <
      class... _Up,
      __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>, is_assignable<_Tp&, _Up const&>... >::value,
                     int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple& operator=(tuple<_Up...> const& __tuple)
      noexcept(_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value) {
    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  template <class... _Up,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>, is_assignable<_Tp&, _Up>... >::value,
                           int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple& operator=(tuple<_Up...>&& __tuple)
      noexcept(_And<is_nothrow_assignable<_Tp&, _Up>...>::value) {
    std::__memberwise_forward_assign(
        *this, std::move(__tuple), __tuple_types<_Up...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }


  template <class... _UTypes,
            enable_if_t< _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
                              is_assignable<const _Tp&, const _UTypes&>...>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const tuple& operator=(const tuple<_UTypes...>& __u) const {
    std::__memberwise_copy_assign(*this, __u, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  template <class... _UTypes,
            enable_if_t< _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
                              is_assignable<const _Tp&, _UTypes>...>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const tuple& operator=(tuple<_UTypes...>&& __u) const {
    std::__memberwise_forward_assign(
        *this, __u, __tuple_types<_UTypes...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }


  template <template <class...> class _Pred,
            bool _Const,
            class _Pair,
            class _DecayedPair = __remove_cvref_t<_Pair>,
            class _Tuple = tuple>
  struct _AssignPredicateFromPair : false_type {};

  template <template <class...> class _Pred, bool _Const, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
  struct _AssignPredicateFromPair<_Pred, _Const, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
      : _And<_Pred<__maybe_const<_Const, _Tp1>&, __copy_cvref_t<_Pair, _Up1> >,
             _Pred<__maybe_const<_Const, _Tp2>&, __copy_cvref_t<_Pair, _Up2> > > {};

  template <bool _Const, class _Pair>
  struct _EnableAssignFromPair : _AssignPredicateFromPair<is_assignable, _Const, _Pair> {};

  template <bool _Const, class _Pair>
  struct _NothrowAssignFromPair : _AssignPredicateFromPair<is_nothrow_assignable, _Const, _Pair> {};


  template <class _U1, class _U2, enable_if_t< _EnableAssignFromPair<true, const pair<_U1, _U2>&>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const tuple& operator=(const pair<_U1, _U2>& __pair) const
      noexcept(_NothrowAssignFromPair<true, const pair<_U1, _U2>&>::value) {
    std::get<0>(*this) = __pair.first;
    std::get<1>(*this) = __pair.second;
    return *this;
  }

  template <class _U1, class _U2, enable_if_t< _EnableAssignFromPair<true, pair<_U1, _U2>&&>::value>* = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const tuple& operator=(pair<_U1, _U2>&& __pair) const
      noexcept(_NothrowAssignFromPair<true, pair<_U1, _U2>&&>::value) {
    std::get<0>(*this) = std::move(__pair.first);
    std::get<1>(*this) = std::move(__pair.second);
    return *this;
  }


  template <class _Up1,
            class _Up2,
            __enable_if_t< _EnableAssignFromPair<false, pair<_Up1, _Up2> const&>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple& operator=(pair<_Up1, _Up2> const& __pair)
      noexcept(_NothrowAssignFromPair<false, pair<_Up1, _Up2> const&>::value) {
    std::get<0>(*this) = __pair.first;
    std::get<1>(*this) = __pair.second;
    return *this;
  }

  template <class _Up1, class _Up2, __enable_if_t< _EnableAssignFromPair<false, pair<_Up1, _Up2>&&>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple& operator=(pair<_Up1, _Up2>&& __pair)
      noexcept(_NothrowAssignFromPair<false, pair<_Up1, _Up2>&&>::value) {
    std::get<0>(*this) = std::forward<_Up1>(__pair.first);
    std::get<1>(*this) = std::forward<_Up2>(__pair.second);
    return *this;
  }


  template <
      class _Up,
      size_t _Np,
      __enable_if_t< _And< _BoolConstant<_Np == sizeof...(_Tp)>, is_assignable<_Tp&, _Up const&>... >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple& operator=(array<_Up, _Np> const& __array)
      noexcept(_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value) {
    std::__memberwise_copy_assign(*this, __array, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }


  template <class _Up,
            size_t _Np,
            class = void,
            __enable_if_t< _And< _BoolConstant<_Np == sizeof...(_Tp)>, is_assignable<_Tp&, _Up>... >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple& operator=(array<_Up, _Np>&& __array)
      noexcept(_And<is_nothrow_assignable<_Tp&, _Up>...>::value) {
    std::__memberwise_forward_assign(
        *this,
        std::move(__array),
        __tuple_types<_If<true, _Up, _Tp>...>(),
        typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(tuple& __t)
      noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
    __base_.swap(__t.__base_);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(const tuple& __t) const
      noexcept(__all<is_nothrow_swappable_v<const _Tp&>...>::value) {
    __base_.swap(__t.__base_);
  }

};

template <>
class tuple<> {
public:
  constexpr tuple() noexcept = default;
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple(allocator_arg_t, const _Alloc&) noexcept {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept {}
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple(array<_Up, 0>) noexcept {}
  template <class _Alloc, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(tuple&) noexcept {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(const tuple&) const noexcept {}

};


template <class... _TTypes, class... _UTypes, template <class> class _TQual, template <class> class _UQual>
  requires requires { typename tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>; }
struct basic_common_reference<tuple<_TTypes...>, tuple<_UTypes...>, _TQual, _UQual> {
  using type = tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>;
};

template <class... _TTypes, class... _UTypes>
  requires requires { typename tuple<common_type_t<_TTypes, _UTypes>...>; }
struct common_type<tuple<_TTypes...>, tuple<_UTypes...>> {
  using type = tuple<common_type_t<_TTypes, _UTypes>...>;
};



template <class... _Tp>
tuple(_Tp...) -> tuple<_Tp...>;
template <class _Tp1, class _Tp2>
tuple(pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class... _Tp>
tuple(allocator_arg_t, _Alloc, _Tp...) -> tuple<_Tp...>;
template <class _Alloc, class _Tp1, class _Tp2>
tuple(allocator_arg_t, _Alloc, pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class... _Tp>
tuple(allocator_arg_t, _Alloc, tuple<_Tp...>) -> tuple<_Tp...>;


template <class... _Tp, __enable_if_t<__all<__is_swappable<_Tp>::value...>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
    noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
  __t.swap(__u);
}


template <class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr enable_if_t<__all<is_swappable_v<const _Tp>...>::value, void>
swap(const tuple<_Tp...>& __lhs,
     const tuple<_Tp...>& __rhs) noexcept(__all<is_nothrow_swappable_v<const _Tp>...>::value) {
  __lhs.swap(__rhs);
}




template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) noexcept {
  typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) noexcept {
  typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) noexcept {
  typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<type&&>(static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) noexcept {
  typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<const type&&>(static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}



template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1& get(tuple<_Args...>& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
}

template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
}





template <class... _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple<_Tp&...> tie(_Tp&... __t) noexcept {
  return tuple<_Tp&...>(__t...);
}

template <class _Up>
struct __ignore_t {
  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const __ignore_t& operator=(_Tp&&) const {
    return *this;
  }
};


inline constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();






template <class... _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple<typename __unwrap_ref_decay<_Tp>::type...>
make_tuple(_Tp&&... __t) {
  return tuple<typename __unwrap_ref_decay<_Tp>::type...>(std::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple<_Tp&&...> forward_as_tuple(_Tp&&... __t) noexcept {
  return tuple<_Tp&&...>(std::forward<_Tp>(__t)...);
}

template <size_t _Ip>
struct __tuple_equal {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(const _Tp& __x, const _Up& __y) {
    return __tuple_equal<_Ip - 1>()(__x, __y) && std::get<_Ip - 1>(__x) == std::get<_Ip - 1>(__y);
  }
};

template <>
struct __tuple_equal<0> {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator()(const _Tp&, const _Up&) {
    return true;
  }
};

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  static_assert(sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
  return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}





template <class... _Tp, class... _Up, size_t... _Is>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto
__tuple_compare_three_way(const tuple<_Tp...>& __x, const tuple<_Up...>& __y, index_sequence<_Is...>) {
  common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...> __result = strong_ordering::equal;
  static_cast<void>(
      ((__result = std::__synth_three_way(std::get<_Is>(__x), std::get<_Is>(__y)), __result != 0) || ...));
  return __result;
}

template <class... _Tp, class... _Up>
  requires(sizeof...(_Tp) == sizeof...(_Up))
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...>
operator<=>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  return std::__tuple_compare_three_way(__x, __y, index_sequence_for<_Tp...>{});
}
# 1248 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/tuple" 3
template <class _Tp, class _Up>
struct __tuple_cat_type;

template <class... _Ttypes, class... _Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> > {
  typedef __attribute__((__nodebug__)) tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class... _Tuples>
struct __tuple_cat_return_1 {};

template <class... _Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0> {
  using type __attribute__((__nodebug__)) =
      typename __tuple_cat_type< tuple<_Types...>,
                                 typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type >::type;
};

template <class... _Types, class _Tuple0, class _Tuple1, class... _Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
          typename __tuple_cat_type< tuple<_Types...>,
                                     typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type >::type,
          __tuple_like_ext<__libcpp_remove_reference_t<_Tuple1> >::value,
          _Tuple1,
          _Tuples...> {};

template <class... _Tuples>
struct __tuple_cat_return;

template <class _Tuple0, class... _Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
                                  __tuple_like_ext<__libcpp_remove_reference_t<_Tuple0> >::value,
                                  _Tuple0,
                                  _Tuples...> {};

template <>
struct __tuple_cat_return<> {
  typedef __attribute__((__nodebug__)) tuple<> type;
};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr tuple<> tuple_cat() { return tuple<>(); }

template <class _Rp, class _Indices, class _Tuple0, class... _Tuples>
struct __tuple_cat_return_ref_imp;

template <class... _Types, size_t... _I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0> {
  typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple0> _T0;
  typedef tuple<_Types..., __apply_cv_t<_Tuple0, typename tuple_element<_I0, _T0>::type>&&...> type;
};

template <class... _Types, size_t... _I0, class _Tuple0, class _Tuple1, class... _Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
          tuple<_Types...,
                __apply_cv_t<_Tuple0, typename tuple_element<_I0, __libcpp_remove_reference_t<_Tuple0>>::type>&&...>,
          typename __make_tuple_indices<tuple_size<__libcpp_remove_reference_t<_Tuple1> >::value>::type,
          _Tuple1,
          _Tuples...> {};

template <class _Tuple0, class... _Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<
          tuple<>,
          typename __make_tuple_indices< tuple_size<__libcpp_remove_reference_t<_Tuple0> >::value >::type,
          _Tuple0,
          _Tuples...> {};

template <class _Types, class _I0, class _J0>
struct __tuple_cat;

template <class... _Types, size_t... _I0, size_t... _J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> > {
  template <class _Tuple0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
      typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
      operator()(tuple<_Types...> __t, _Tuple0&& __t0) {
    (void)__t;
    return std::forward_as_tuple(
        std::forward<_Types>(std::get<_I0>(__t))..., std::get<_J0>(std::forward<_Tuple0>(__t0))...);
  }

  template <class _Tuple0, class _Tuple1, class... _Tuples>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
      typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
      operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&&... __tpls) {
    (void)__t;
    typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple0> _T0;
    typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple1> _T1;
    return __tuple_cat<tuple<_Types..., __apply_cv_t<_Tuple0, typename tuple_element<_J0, _T0>::type>&&...>,
                       typename __make_tuple_indices<sizeof...(_Types) + tuple_size<_T0>::value>::type,
                       typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
        std::forward_as_tuple(
            std::forward<_Types>(std::get<_I0>(__t))..., std::get<_J0>(std::forward<_Tuple0>(__t0))...),
        std::forward<_Tuple1>(__t1),
        std::forward<_Tuples>(__tpls)...);
  }
};

template <class _Tuple0, class... _Tuples>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls) {
  typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple0> _T0;
  return __tuple_cat<tuple<>, __tuple_indices<>, typename __make_tuple_indices<tuple_size<_T0>::value>::type>()(
      tuple<>(), std::forward<_Tuple0>(__t0), std::forward<_Tuples>(__tpls)...);
}

template <class... _Tp, class _Alloc>
struct uses_allocator<tuple<_Tp...>, _Alloc> : true_type {};

template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_T1, _T2>::pair(
    piecewise_construct_t,
    tuple<_Args1...>& __first_args,
    tuple<_Args2...>& __second_args,
    __tuple_indices<_I1...>,
    __tuple_indices<_I2...>)
    : first(std::forward<_Args1>(std::get<_I1>(__first_args))...),
      second(std::forward<_Args2>(std::get<_I2>(__second_args))...) {}


template <class _Tp>
inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;






template <class _Fn, class _Tuple, size_t... _Id>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto)
__apply_tuple_impl(_Fn&& __f, _Tuple&& __t, __tuple_indices<_Id...>)
    noexcept(noexcept(std::__invoke(std::forward<_Fn>(__f), std::get<_Id>(std::forward<_Tuple>(__t))...))) { return std::__invoke(std::forward<_Fn>(__f), std::get<_Id>(std::forward<_Tuple>(__t))...); }

template <class _Fn, class _Tuple>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr decltype(auto) apply(_Fn&& __f, _Tuple&& __t)
    noexcept(noexcept(std::__apply_tuple_impl( std::forward<_Fn>(__f), std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))) { return std::__apply_tuple_impl( std::forward<_Fn>(__f), std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}); }




template <class _Tp, class _Tuple, size_t... _Idx>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
    noexcept(noexcept(_Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...))) { return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...); }

template <class _Tp, class _Tuple>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp make_from_tuple(_Tuple&& __t)
    noexcept(noexcept(std::__make_from_tuple_impl<_Tp>( std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))) { return std::__make_from_tuple_impl<_Tp>( std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}); }
# 1407 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/tuple" 3
}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__mutex/once_flag.h" 2 3
# 26 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__mutex/once_flag.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 30 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__mutex/once_flag.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

struct once_flag;



template <class _Callable, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void call_once(once_flag&, _Callable&&, _Args&&...);
# 50 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__mutex/once_flag.h" 3
struct once_flag {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr once_flag() noexcept : __state_(_Unset) {}
  once_flag(const once_flag&) = delete;
  once_flag& operator=(const once_flag&) = delete;




  typedef unsigned long _State_type;


  static const _State_type _Unset = 0;
  static const _State_type _Pending = 1;
  static const _State_type _Complete = ~_State_type(0);

private:
  _State_type __state_;


  template <class _Callable, class... _Args>
  friend void call_once(once_flag&, _Callable&&, _Args&&...);







};



template <class _Fp>
class __call_once_param {
  _Fp& __f_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __call_once_param(_Fp& __f) : __f_(__f) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void operator()() {
    typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
    __execute(_Index());
  }

private:
  template <size_t... _Indices>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __execute(__tuple_indices<_Indices...>) {
    std::__invoke(std::get<0>(std::move(__f_)), std::get<_Indices>(std::move(__f_))...);
  }
};
# 115 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__mutex/once_flag.h" 3
template <class _Fp>
void __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __call_once_proxy(void* __vp) {
  __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
  (*__p)();
}

__attribute__((__visibility__("default"))) void __call_once(volatile once_flag::_State_type&, void*, void (*)(void*));



template <class _Callable, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void call_once(once_flag& __flag, _Callable&& __func, _Args&&... __args) {
  if (__libcpp_acquire_load(&__flag.__state_) != once_flag::_Complete) {
    typedef tuple<_Callable&&, _Args&&...> _Gp;
    _Gp __f(std::forward<_Callable>(__func), std::forward<_Args>(__args)...);
    __call_once_param<_Gp> __p(__f);
    std::__call_once(__flag.__state_, &__p, &__call_once_proxy<_Gp>);
  }
}
# 155 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__mutex/once_flag.h" 3
}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/no_destroy.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__utility/no_destroy.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

struct __uninitialized_tag {};







template <class _Tp>
struct __no_destroy {
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __no_destroy(__uninitialized_tag) : __dummy_() {
    if (__libcpp_is_constant_evaluated()) {
      __dummy_ = char();
    }
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) ~__no_destroy() {

  }

  template <class... _Args>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __no_destroy(_Args&&... __args)
      : __obj_(std::forward<_Args>(__args)...) {}

  template <class... _Args>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp& __emplace(_Args&&... __args) {
    new (&__obj_) _Tp(std::forward<_Args>(__args)...);
    return __obj_;
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp& __get() { return __obj_; }
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Tp const& __get() const { return __obj_; }

private:
  union {
    _Tp __obj_;
    char __dummy_;
  };
};

}}
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cctype" 1 3
# 39 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cctype" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/ctype.h" 1 3
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/ctype.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/ctype.h" 1 3 4
# 71 "/data/data/com.termux/files/usr/bin/../../usr/include/ctype.h" 3 4
extern "C" {


extern const char* _ctype_;






static __inline__ int _tolower(int __ch) {
  return __ch | 0x20;
}






static __inline__ int _toupper(int __ch) {


  return __ch ^ 0x20;
}


__attribute__((__no_sanitize__("unsigned-integer-overflow")))
static __inline__ int __bionic_ctype_in_range(unsigned __lo, int __ch, unsigned __hi) {
  return ((static_cast<unsigned>(__ch)) - __lo) < (__hi - __lo + 1);
}


static __inline__ int isalpha(int __ch) {
  return __bionic_ctype_in_range('a', _tolower(__ch), 'z');
}


static __inline__ int isblank(int __ch) {
  return __ch == ' ' || __ch == '\t';
}


static __inline__ int iscntrl(int __ch) {
  return ((static_cast<unsigned>(__ch)) < ' ') || __ch == 0x7f;
}


static __inline__ int isdigit(int __ch) {
  return __bionic_ctype_in_range('0', __ch, '9');
}


static __inline__ int isgraph(int __ch) {
  return __bionic_ctype_in_range('!', __ch, '~');
}


static __inline__ int islower(int __ch) {
  return __bionic_ctype_in_range('a', __ch, 'z');
}


static __inline__ int isprint(int __ch) {
  return __bionic_ctype_in_range(' ', __ch, '~');
}


static __inline__ int isspace(int __ch) {
  return __ch == ' ' || __bionic_ctype_in_range('\t', __ch, '\r');
}


static __inline__ int isupper(int __ch) {
  return __bionic_ctype_in_range('A', __ch, 'Z');
}


static __inline__ int isxdigit(int __ch) {
  return isdigit(__ch) || __bionic_ctype_in_range('a', _tolower(__ch), 'f') ;
}


static __inline__ int isalnum(int __ch) {
  return isalpha(__ch) || isdigit(__ch);
}


static __inline__ int ispunct(int __ch) {
  return isgraph(__ch) && !isalnum(__ch);
}


static __inline__ int tolower(int __ch) {
  return (__bionic_ctype_in_range('A', __ch, 'Z')) ? _tolower(__ch) : __ch;
}


static __inline__ int toupper(int __ch) {
  return (__bionic_ctype_in_range('a', __ch, 'z')) ? _toupper(__ch) : __ch;
}


static __inline__ int isascii(int __ch) {
  return (static_cast<unsigned>(__ch)) < 0x80;
}


static __inline__ int toascii(int __ch) {
  return __ch & 0x7f;
}


static __inline__ int isalnum_l(int __ch, locale_t __l) {
  return isalnum(__ch);
}


static __inline__ int isalpha_l(int __ch, locale_t __l) {
  return isalpha(__ch);
}


static __inline__ int isblank_l(int __ch, locale_t __l) {
  return isblank(__ch);
}


static __inline__ int iscntrl_l(int __ch, locale_t __l) {
  return iscntrl(__ch);
}


static __inline__ int isdigit_l(int __ch, locale_t __l) {
  return isdigit(__ch);
}


static __inline__ int isgraph_l(int __ch, locale_t __l) {
  return isgraph(__ch);
}


static __inline__ int islower_l(int __ch, locale_t __l) {
  return islower(__ch);
}


static __inline__ int isprint_l(int __ch, locale_t __l) {
  return isprint(__ch);
}


static __inline__ int ispunct_l(int __ch, locale_t __l) {
  return ispunct(__ch);
}


static __inline__ int isspace_l(int __ch, locale_t __l) {
  return isspace(__ch);
}


static __inline__ int isupper_l(int __ch, locale_t __l) {
  return isupper(__ch);
}


static __inline__ int isxdigit_l(int __ch, locale_t __l) {
  return isxdigit(__ch);
}


static __inline__ int tolower_l(int __ch, locale_t __l) {
  return tolower(__ch);
}


static __inline__ int toupper_l(int __ch, locale_t __l) {
  return toupper(__ch);
}

}
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/ctype.h" 2 3
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cctype" 2 3
# 50 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cctype" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 110 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cctype" 3
using ::isalnum __attribute__((__using_if_exists__));
using ::isalpha __attribute__((__using_if_exists__));
using ::isblank __attribute__((__using_if_exists__));
using ::iscntrl __attribute__((__using_if_exists__));
using ::isdigit __attribute__((__using_if_exists__));
using ::isgraph __attribute__((__using_if_exists__));
using ::islower __attribute__((__using_if_exists__));
using ::isprint __attribute__((__using_if_exists__));
using ::ispunct __attribute__((__using_if_exists__));
using ::isspace __attribute__((__using_if_exists__));
using ::isupper __attribute__((__using_if_exists__));
using ::isxdigit __attribute__((__using_if_exists__));
using ::tolower __attribute__((__using_if_exists__));
using ::toupper __attribute__((__using_if_exists__));

}}
# 21 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/clocale" 1 3
# 39 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/clocale" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/locale.h" 1 3
# 44 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/locale.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/locale.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/locale.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3 4
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 3


# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 1 3
# 108 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 3
# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/__stddef_null.h" 1 3
# 109 "/data/data/com.termux/files/usr/lib/clang/21/include/stddef.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 2 3
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/locale.h" 2 3 4

extern "C" {
# 72 "/data/data/com.termux/files/usr/bin/../../usr/include/locale.h" 3 4
struct lconv {
  char* _Nonnull decimal_point;
  char* _Nonnull thousands_sep;
  char* _Nonnull grouping;
  char* _Nonnull int_curr_symbol;
  char* _Nonnull currency_symbol;
  char* _Nonnull mon_decimal_point;
  char* _Nonnull mon_thousands_sep;
  char* _Nonnull mon_grouping;
  char* _Nonnull positive_sign;
  char* _Nonnull negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_p_cs_precedes;
  char int_p_sep_by_space;
  char int_n_cs_precedes;
  char int_n_sep_by_space;
  char int_p_sign_posn;
  char int_n_sign_posn;
};

struct lconv* _Nonnull localeconv(void);

locale_t _Nullable duplocale(locale_t _Nonnull __l);
void freelocale(locale_t _Nonnull __l);
locale_t _Nullable newlocale(int __category_mask, const char* _Nonnull __locale_name, locale_t _Nullable __base);
char* _Nullable setlocale(int __category, const char* _Nullable __locale_name);
locale_t _Nullable uselocale(locale_t _Nullable __l);



}
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/locale.h" 2 3
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/clocale" 2 3
# 51 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/clocale" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

using ::lconv __attribute__((__using_if_exists__));
using ::setlocale __attribute__((__using_if_exists__));
using ::localeconv __attribute__((__using_if_exists__));

}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdlib" 1 3
# 86 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdlib" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdlib.h" 1 3
# 87 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdlib" 2 3
# 98 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdlib" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

using ::size_t __attribute__((__using_if_exists__));
using ::div_t __attribute__((__using_if_exists__));
using ::ldiv_t __attribute__((__using_if_exists__));
using ::lldiv_t __attribute__((__using_if_exists__));
using ::atof __attribute__((__using_if_exists__));
using ::atoi __attribute__((__using_if_exists__));
using ::atol __attribute__((__using_if_exists__));
using ::atoll __attribute__((__using_if_exists__));
using ::strtod __attribute__((__using_if_exists__));
using ::strtof __attribute__((__using_if_exists__));
using ::strtold __attribute__((__using_if_exists__));
using ::strtol __attribute__((__using_if_exists__));
using ::strtoll __attribute__((__using_if_exists__));
using ::strtoul __attribute__((__using_if_exists__));
using ::strtoull __attribute__((__using_if_exists__));
using ::rand __attribute__((__using_if_exists__));
using ::srand __attribute__((__using_if_exists__));
using ::calloc __attribute__((__using_if_exists__));
using ::free __attribute__((__using_if_exists__));
using ::malloc __attribute__((__using_if_exists__));
using ::realloc __attribute__((__using_if_exists__));
using ::abort __attribute__((__using_if_exists__));
using ::atexit __attribute__((__using_if_exists__));
using ::exit __attribute__((__using_if_exists__));
using ::_Exit __attribute__((__using_if_exists__));
using ::getenv __attribute__((__using_if_exists__));
using ::system __attribute__((__using_if_exists__));
using ::bsearch __attribute__((__using_if_exists__));
using ::qsort __attribute__((__using_if_exists__));
using ::abs __attribute__((__using_if_exists__));
using ::labs __attribute__((__using_if_exists__));
using ::llabs __attribute__((__using_if_exists__));
using ::div __attribute__((__using_if_exists__));
using ::ldiv __attribute__((__using_if_exists__));
using ::lldiv __attribute__((__using_if_exists__));
using ::mblen __attribute__((__using_if_exists__));

using ::mbtowc __attribute__((__using_if_exists__));
using ::wctomb __attribute__((__using_if_exists__));
using ::mbstowcs __attribute__((__using_if_exists__));
using ::wcstombs __attribute__((__using_if_exists__));


using ::at_quick_exit __attribute__((__using_if_exists__));
using ::quick_exit __attribute__((__using_if_exists__));


using ::aligned_alloc __attribute__((__using_if_exists__));


}}
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__locale" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 1 3
# 571 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/max.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/max.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/max_element.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/max_element.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Compare, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  static_assert(
      __has_forward_iterator_category<_ForwardIterator>::value, "std::max_element requires a ForwardIterator");
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last)
      if (__comp(*__first, *__i))
        __first = __i;
  }
  return __first;
}

template <class _ForwardIterator, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  return std::__max_element<__comp_ref_type<_Compare> >(__first, __last, __comp);
}

template <class _ForwardIterator>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::max_element(__first, __last, __less<>());
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/max.h" 2 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/max.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/max.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp&
max([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const _Tp&
max([[_Clang::__lifetimebound__]] const _Tp& __a, [[_Clang::__lifetimebound__]] const _Tp& __b) {
  return std::max(__a, __b, __less<>());
}



template <class _Tp, class _Compare>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp
max(initializer_list<_Tp> __t, _Compare __comp) {
  return *std::__max_element<__comp_ref_type<_Compare> >(__t.begin(), __t.end(), __comp);
}

template <class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp max(initializer_list<_Tp> __t) {
  return *std::max_element(__t.begin(), __t.end(), __less<>());
}



}}
# 572 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/remove.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/remove.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find.h" 1 3
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find_segment_if.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find_segment_if.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {







template <class _SegmentedIterator, class _Pred, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _SegmentedIterator
__find_segment_if(_SegmentedIterator __first, _SegmentedIterator __last, _Pred __pred, _Proj& __proj) {
  using _Traits = __segmented_iterator_traits<_SegmentedIterator>;

  auto __sfirst = _Traits::__segment(__first);
  auto __slast = _Traits::__segment(__last);


  if (__sfirst == __slast)
    return _Traits::__compose(__sfirst, __pred(_Traits::__local(__first), _Traits::__local(__last), __proj));

  {
    auto __llast = _Traits::__end(__sfirst);
    auto __liter = __pred(_Traits::__local(__first), __llast, __proj);
    if (__liter != __llast)
      return _Traits::__compose(__sfirst, __liter);
  }
  ++__sfirst;


  while (__sfirst != __slast) {
    auto __llast = _Traits::__end(__sfirst);
    auto __liter = __pred(_Traits::__begin(__sfirst), _Traits::__end(__sfirst), __proj);
    if (__liter != __llast)
      return _Traits::__compose(__sfirst, __liter);
    ++__sfirst;
  }


  return _Traits::__compose(__sfirst, __pred(_Traits::__begin(__sfirst), _Traits::__local(__last), __proj));
}

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find.h" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__bit/countr.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__bit/countr.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__bit/rotate.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__bit/rotate.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp __rotr(_Tp __t, int __cnt) noexcept {
  static_assert(__libcpp_is_unsigned_integer<_Tp>::value, "__rotr requires an unsigned integer type");
  const unsigned int __dig = numeric_limits<_Tp>::digits;
  if ((__cnt % __dig) == 0)
    return __t;

  if (__cnt < 0) {
    __cnt *= -1;
    return (__t << (__cnt % __dig)) | (__t >> (__dig - (__cnt % __dig)));
  }

  return (__t >> (__cnt % __dig)) | (__t << (__dig - (__cnt % __dig)));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp __rotl(_Tp __t, int __cnt) noexcept {
  return std::__rotr(__t, -__cnt);
}



template <__libcpp_unsigned_integer _Tp>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp rotl(_Tp __t, int __cnt) noexcept {
  return std::__rotl(__t, __cnt);
}

template <__libcpp_unsigned_integer _Tp>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp rotr(_Tp __t, int __cnt) noexcept {
  return std::__rotr(__t, __cnt);
}



}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__bit/countr.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__bit/countr.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__bit/countr.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int __libcpp_ctz(unsigned __x) noexcept {
  return __builtin_ctz(__x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int __libcpp_ctz(unsigned long __x) noexcept {
  return __builtin_ctzl(__x);
}

[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int __libcpp_ctz(unsigned long long __x) noexcept {
  return __builtin_ctzll(__x);
}



template <__libcpp_unsigned_integer _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int countr_zero(_Tp __t) noexcept {
  if (__t == 0)
    return numeric_limits<_Tp>::digits;

  if (sizeof(_Tp) <= sizeof(unsigned int))
    return std::__libcpp_ctz(static_cast<unsigned int>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long))
    return std::__libcpp_ctz(static_cast<unsigned long>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long long))
    return std::__libcpp_ctz(static_cast<unsigned long long>(__t));
  else {
    int __ret = 0;
    const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
    while (static_cast<unsigned long long>(__t) == 0uLL) {
      __ret += __ulldigits;
      __t >>= __ulldigits;
    }
    return __ret + std::__libcpp_ctz(static_cast<unsigned long long>(__t));
  }
}

template <__libcpp_unsigned_integer _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int countr_one(_Tp __t) noexcept {
  return __t != numeric_limits<_Tp>::max() ? std::countr_zero(static_cast<_Tp>(~__t)) : numeric_limits<_Tp>::digits;
}



}}
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__bit/invert_if.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__bit/invert_if.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <bool _Invert, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp __invert_if(_Tp __v) {
  if (_Invert)
    return ~__v;
  return __v;
}

}}
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find.h" 2 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/bit_reference.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/bit_reference.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0>
class __bit_iterator;

}}
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find.h" 2 3
# 31 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cwchar" 1 3
# 111 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cwchar" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cwctype" 1 3
# 55 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cwctype" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/wctype.h" 1 3
# 56 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/wctype.h" 3
# 68 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/wctype.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/wctype.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/wctype.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/wctype.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/wctype.h" 3 4
extern "C" {

typedef unsigned int wint_t;



int iswalnum(wint_t __wc);
int iswalpha(wint_t __wc);
int iswblank(wint_t __wc);
int iswcntrl(wint_t __wc);
int iswdigit(wint_t __wc);
int iswgraph(wint_t __wc);
int iswlower(wint_t __wc);
int iswprint(wint_t __wc);
int iswpunct(wint_t __wc);
int iswspace(wint_t __wc);
int iswupper(wint_t __wc);
int iswxdigit(wint_t __wc);

wint_t towlower(wint_t __wc);
wint_t towupper(wint_t __wc);

typedef long wctype_t;
wctype_t wctype(const char* _Nonnull __name);
int iswctype(wint_t __wc, wctype_t __type);

typedef const void* wctrans_t;







}
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/wctype.h" 2 3 4


extern "C" {

int iswalnum_l(wint_t __wc, locale_t _Nonnull __l);
int iswalpha_l(wint_t __wc, locale_t _Nonnull __l);
int iswblank_l(wint_t __wc, locale_t _Nonnull __l);
int iswcntrl_l(wint_t __wc, locale_t _Nonnull __l);
int iswdigit_l(wint_t __wc, locale_t _Nonnull __l);
int iswgraph_l(wint_t __wc, locale_t _Nonnull __l);
int iswlower_l(wint_t __wc, locale_t _Nonnull __l);
int iswprint_l(wint_t __wc, locale_t _Nonnull __l);
int iswpunct_l(wint_t __wc, locale_t _Nonnull __l);
int iswspace_l(wint_t __wc, locale_t _Nonnull __l);
int iswupper_l(wint_t __wc, locale_t _Nonnull __l);
int iswxdigit_l(wint_t __wc, locale_t _Nonnull __l);

wint_t towlower_l(wint_t __wc, locale_t _Nonnull __l);
wint_t towupper_l(wint_t __wc, locale_t _Nonnull __l);
# 62 "/data/data/com.termux/files/usr/bin/../../usr/include/wctype.h" 3 4
wctype_t wctype_l(const char* _Nonnull __name, locale_t _Nonnull __l);
int iswctype_l(wint_t __wc, wctype_t __transform, locale_t _Nonnull __l);

}
# 69 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/wctype.h" 2 3
# 56 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cwctype" 2 3
# 67 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cwctype" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


using ::wint_t __attribute__((__using_if_exists__));
using ::wctrans_t __attribute__((__using_if_exists__));
using ::wctype_t __attribute__((__using_if_exists__));
using ::iswalnum __attribute__((__using_if_exists__));
using ::iswalpha __attribute__((__using_if_exists__));
using ::iswblank __attribute__((__using_if_exists__));
using ::iswcntrl __attribute__((__using_if_exists__));
using ::iswdigit __attribute__((__using_if_exists__));
using ::iswgraph __attribute__((__using_if_exists__));
using ::iswlower __attribute__((__using_if_exists__));
using ::iswprint __attribute__((__using_if_exists__));
using ::iswpunct __attribute__((__using_if_exists__));
using ::iswspace __attribute__((__using_if_exists__));
using ::iswupper __attribute__((__using_if_exists__));
using ::iswxdigit __attribute__((__using_if_exists__));
using ::iswctype __attribute__((__using_if_exists__));
using ::wctype __attribute__((__using_if_exists__));
using ::towlower __attribute__((__using_if_exists__));
using ::towupper __attribute__((__using_if_exists__));
using ::towctrans __attribute__((__using_if_exists__));
using ::wctrans __attribute__((__using_if_exists__));


}}
# 112 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cwchar" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/wchar.h" 1 3
# 109 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/wchar.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3
# 110 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/wchar.h" 2 3
# 118 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/wchar.h" 3
# 127 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/wchar.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/wchar.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/wchar.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdio.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/wchar.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/stdarg.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/wchar.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3 4
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/wchar.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 1 3 4
# 37 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/time.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/time.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/time.h" 1 3 4








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/timespec.h" 1 3 4
# 46 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/timespec.h" 3 4
struct timespec {

  time_t tv_sec;

  long tv_nsec;
};
# 10 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/time.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/time_types.h" 1 3 4








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/time.h" 1 3 4
# 10 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/time_types.h" 2 3 4

struct __kernel_timespec {
  __kernel_time64_t tv_sec;
  long long tv_nsec;
};
struct __kernel_itimerspec {
  struct __kernel_timespec it_interval;
  struct __kernel_timespec it_value;
};
struct __kernel_old_timespec {
  __kernel_old_time_t tv_sec;
  long tv_nsec;
};
struct __kernel_sock_timeval {
  __s64 tv_sec;
  __s64 tv_usec;
};
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/time.h" 2 3 4



struct timeval {
  __kernel_old_time_t tv_sec;
  __kernel_suseconds_t tv_usec;
};
struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};
struct itimerval {
  struct timeval it_interval;
  struct timeval it_value;
};
struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/time.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/select.h" 1 3 4
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/select.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/sigcontext.h" 1 3 4
# 11 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/sigcontext.h" 3 4
struct sigcontext {
  __u64 fault_address;
  __u64 regs[31];
  __u64 sp;
  __u64 pc;
  __u64 pstate;
  __u8 __reserved[4096] __attribute__((__aligned__(16)));
};
struct _aarch64_ctx {
  __u32 magic;
  __u32 size;
};

struct fpsimd_context {
  struct _aarch64_ctx head;
  __u32 fpsr;
  __u32 fpcr;
  __uint128_t vregs[32];
};

struct esr_context {
  struct _aarch64_ctx head;
  __u64 esr;
};

struct poe_context {
  struct _aarch64_ctx head;
  __u64 por_el0;
};

struct extra_context {
  struct _aarch64_ctx head;
  __u64 datap;
  __u32 size;
  __u32 __reserved[3];
};

struct sve_context {
  struct _aarch64_ctx head;
  __u16 vl;
  __u16 flags;
  __u16 __reserved[2];
};


struct tpidr2_context {
  struct _aarch64_ctx head;
  __u64 tpidr2;
};

struct fpmr_context {
  struct _aarch64_ctx head;
  __u64 fpmr;
};

struct za_context {
  struct _aarch64_ctx head;
  __u16 vl;
  __u16 __reserved[3];
};

struct zt_context {
  struct _aarch64_ctx head;
  __u16 nregs;
  __u16 __reserved[3];
};

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/sve_context.h" 1 3 4
# 79 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/sigcontext.h" 2 3 4
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/signal_types.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/signal_types.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/limits.h" 1 3 4
# 25 "/data/data/com.termux/files/usr/lib/clang/21/include/limits.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/limits.h" 1 3 4
# 58 "/data/data/com.termux/files/usr/bin/../../usr/include/limits.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/float.h" 1 3 4
# 77 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/float.h" 3



# 1 "/data/data/com.termux/files/usr/lib/clang/21/include/float.h" 1 3
# 81 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/float.h" 2 3
# 59 "/data/data/com.termux/files/usr/bin/../../usr/include/limits.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/limits.h" 1 3 4
# 62 "/data/data/com.termux/files/usr/bin/../../usr/include/limits.h" 2 3 4
# 121 "/data/data/com.termux/files/usr/bin/../../usr/include/limits.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/posix_limits.h" 1 3 4
# 122 "/data/data/com.termux/files/usr/bin/../../usr/include/limits.h" 2 3 4
# 26 "/data/data/com.termux/files/usr/lib/clang/21/include/limits.h" 2 3 4
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/signal_types.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/signal.h" 1 3 4








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/signal.h" 1 3 4
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/signal.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/signal.h" 1 3 4
# 56 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/signal.h" 3 4
typedef struct {
  unsigned long sig[(64 / 64)];
} sigset_t;
typedef unsigned long old_sigset_t;
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/signal-defs.h" 1 3 4
# 45 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/signal-defs.h" 3 4
typedef void __signalfn_t(int);
typedef __signalfn_t * __sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t * __sigrestore_t;
# 61 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/signal.h" 2 3 4



struct __kernel_sigaction {
  __sighandler_t sa_handler;
  unsigned long sa_flags;

  __sigrestore_t sa_restorer;

  sigset_t sa_mask;
};
typedef struct sigaltstack {
  void * ss_sp;
  int ss_flags;
  __kernel_size_t ss_size;
} stack_t;
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/signal.h" 2 3 4
# 10 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/signal.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/siginfo.h" 1 3 4






# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/siginfo.h" 1 3 4
# 11 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/siginfo.h" 3 4
typedef union sigval {
  int sival_int;
  void * sival_ptr;
} sigval_t;
# 25 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/siginfo.h" 3 4
union __sifields {
  struct {
    __kernel_pid_t _pid;
    __kernel_uid32_t _uid;
  } _kill;
  struct {
    __kernel_timer_t _tid;
    int _overrun;
    sigval_t _sigval;
    int _sys_private;
  } _timer;
  struct {
    __kernel_pid_t _pid;
    __kernel_uid32_t _uid;
    sigval_t _sigval;
  } _rt;
  struct {
    __kernel_pid_t _pid;
    __kernel_uid32_t _uid;
    int _status;
    __kernel_clock_t _utime;
    __kernel_clock_t _stime;
  } _sigchld;
  struct {
    void * _addr;

    union {
      int _trapno;
      short _addr_lsb;
      struct {
        char _dummy_bnd[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
        void * _lower;
        void * _upper;
      } _addr_bnd;
      struct {
        char _dummy_pkey[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
        __u32 _pkey;
      } _addr_pkey;
      struct {
        unsigned long _data;
        __u32 _type;
        __u32 _flags;
      } _perf;
    };
  } _sigfault;
  struct {
    long _band;
    int _fd;
  } _sigpoll;
  struct {
    void * _call_addr;
    int _syscall;
    unsigned int _arch;
  } _sigsys;
};







typedef struct siginfo {
  union {
    struct { int si_signo; int si_errno; int si_code; union __sifields _sifields; };
    int _si_pad[128 / sizeof(int)];
  };
} siginfo_t;
# 215 "/data/data/com.termux/files/usr/bin/../../usr/include/asm-generic/siginfo.h" 3 4
typedef struct sigevent {
  sigval_t sigev_value;
  int sigev_signo;
  int sigev_notify;
  union {
    int _pad[((64 - (sizeof(int) * 2 + sizeof(sigval_t))) / sizeof(int))];
    int _tid;
    struct {
      void(* _function) (sigval_t);
      void * _attribute;
    } _sigev_thread;
  } _sigev_un;
} sigevent_t;
# 8 "/data/data/com.termux/files/usr/bin/../../usr/include/aarch64-linux-android/asm/siginfo.h" 2 3 4
# 11 "/data/data/com.termux/files/usr/bin/../../usr/include/linux/signal.h" 2 3 4
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/signal_types.h" 2 3 4
# 70 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/signal_types.h" 3 4
typedef int sig_atomic_t;

typedef __sighandler_t sig_t;
typedef __sighandler_t sighandler_t;
# 85 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/signal_types.h" 3 4
typedef sigset_t sigset64_t;
# 122 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/signal_types.h" 3 4
struct sigaction { int sa_flags; union { sighandler_t sa_handler; void (*sa_sigaction)(int, struct siginfo*, void*); }; sigset_t sa_mask; void (*sa_restorer)(void); };
# 134 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/signal_types.h" 3 4
struct sigaction64 { int sa_flags; union { sighandler_t sa_handler; void (*sa_sigaction)(int, struct siginfo*, void*); }; sigset_t sa_mask; void (*sa_restorer)(void); };
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 2 3 4



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/ucontext.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/ucontext.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/ucontext.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/user.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/user.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/user.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/page_size.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/page_size.h" 3 4
extern "C" {
# 49 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/page_size.h" 3 4
}
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/user.h" 2 3 4

extern "C" {
# 222 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/user.h" 3 4
struct user_regs_struct {
  uint64_t regs[31];
  uint64_t sp;
  uint64_t pc;
  uint64_t pstate;
};
struct user_fpsimd_struct {
  __uint128_t vregs[32];
  uint32_t fpsr;
  uint32_t fpcr;
};
# 245 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/user.h" 3 4
}
# 35 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/ucontext.h" 2 3 4

extern "C" {
# 105 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/ucontext.h" 3 4
typedef unsigned long greg_t;
typedef greg_t gregset_t[34];
typedef struct user_fpsimd_struct fpregset_t;


typedef struct sigcontext mcontext_t;

typedef struct ucontext {
  unsigned long uc_flags;
  struct ucontext *uc_link;
  stack_t uc_stack;
  union {
    sigset_t uc_sigmask;
    sigset64_t uc_sigmask64;
  };

  char __padding[128 - sizeof(sigset_t)];
  mcontext_t uc_mcontext;
} ucontext_t;
# 392 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/ucontext.h" 3 4
}
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 2 3 4


extern "C" {
# 54 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 3 4
int __libc_current_sigrtmin(void);
int __libc_current_sigrtmax(void);

extern const char* _Nonnull const sys_siglist[65];
extern const char* _Nonnull const sys_signame[65];



int sigaction(int __signal, const struct sigaction* _Nullable __new_action, struct sigaction* _Nullable __old_action);






int siginterrupt(int __signal, int __flag);

sighandler_t _Nonnull signal(int __signal, sighandler_t _Nullable __handler);
int sigaddset(sigset_t* _Nonnull __set, int __signal);





int sigdelset(sigset_t* _Nonnull __set, int __signal);





int sigemptyset(sigset_t* _Nonnull __set);





int sigfillset(sigset_t* _Nonnull __set);





int sigismember(const sigset_t* _Nonnull __set, int __signal);






int sigpending(sigset_t* _Nonnull __set);





int sigprocmask(int __how, const sigset_t* _Nullable __new_set, sigset_t* _Nullable __old_set);





int sigsuspend(const sigset_t* _Nonnull __mask);





int sigwait(const sigset_t* _Nonnull __set, int* _Nonnull __signal);
# 145 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 3 4
int raise(int __signal);
int kill(pid_t __pid, int __signal);
int killpg(int __pgrp, int __signal);
int tgkill(int __tgid, int __tid, int __signal);

int sigaltstack(const stack_t* _Nullable __new_signal_stack, stack_t* _Nullable __old_signal_stack);

void psiginfo(const siginfo_t* _Nonnull __info, const char* _Nullable __msg);
void psignal(int __signal, const char* _Nullable __msg);

int pthread_kill(pthread_t __pthread, int __signal);
# 164 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 3 4
int pthread_sigmask(int __how, const sigset_t* _Nullable __new_set, sigset_t* _Nullable __old_set);
# 173 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 3 4
int sigqueue(pid_t __pid, int __signal, const union sigval __value) __attribute__((__availability__(android,strict,introduced=23 )));
int sigtimedwait(const sigset_t* _Nonnull __set, siginfo_t* _Nullable __info, const struct timespec* _Nullable __timeout) __attribute__((__availability__(android,strict,introduced=23 )));
# 184 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 3 4
int sigwaitinfo(const sigset_t* _Nonnull __set, siginfo_t* _Nullable __info) __attribute__((__availability__(android,strict,introduced=23 )));
# 225 "/data/data/com.termux/files/usr/bin/../../usr/include/signal.h" 3 4
}
# 43 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/select.h" 2 3 4

extern "C" {

typedef unsigned long fd_mask;
# 65 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/select.h" 3 4
typedef struct {
  fd_mask fds_bits[1024/(8 * sizeof(fd_mask))];
} fd_set;





void __FD_CLR_chk(int, fd_set* _Nonnull , size_t);
void __FD_SET_chk(int, fd_set* _Nonnull, size_t);
int __FD_ISSET_chk(int, const fd_set* _Nonnull, size_t);
# 137 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/select.h" 3 4
int select(int __max_fd_plus_one, fd_set* _Nullable __read_fds, fd_set* _Nullable __write_fds, fd_set* _Nullable __exception_fds, struct timeval* _Nullable __timeout);
# 149 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/select.h" 3 4
int pselect(int __max_fd_plus_one, fd_set* _Nullable __read_fds, fd_set* _Nullable __write_fds, fd_set* _Nullable __exception_fds, const struct timespec* _Nullable __timeout, const sigset_t* _Nullable __mask);
# 167 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/select.h" 3 4
}
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/time.h" 2 3 4

extern "C" {

int gettimeofday(struct timeval* _Nullable __tv, struct timezone* _Nullable __tz);
int settimeofday(const struct timeval* _Nullable __tv, const struct timezone* _Nullable __tz);

int getitimer(int __which, struct itimerval* _Nonnull __current_value);
int setitimer(int __which, const struct itimerval* _Nonnull __new_value, struct itimerval* _Nullable __old_value);

int utimes(const char* _Nonnull __path, const struct timeval __times[_Nullable 2]);



int futimes(int __fd, const struct timeval __times[_Nullable 2]);
int lutimes(const char* _Nonnull __path, const struct timeval __times[_Nullable 2]);
# 71 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/time.h" 3 4
int futimesat(int __dir_fd, const char* _Null_unspecified __path, const struct timeval __times[_Nullable 2]);
# 115 "/data/data/com.termux/files/usr/bin/../../usr/include/sys/time.h" 3 4
}
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 2 3 4


extern "C" {
# 63 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
extern char* _Nonnull tzname[];


extern int daylight;


extern long int timezone;

struct sigevent;




struct tm {

  int tm_sec;

  int tm_min;

  int tm_hour;

  int tm_mday;

  int tm_mon;

  int tm_year;

  int tm_wday;

  int tm_yday;

  int tm_isdst;

  long int tm_gmtoff;

  const char* _Nullable tm_zone;
};
# 110 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
time_t time(time_t* _Nullable __t);
# 120 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
int nanosleep(const struct timespec* _Nonnull __duration, struct timespec* _Nullable __remainder);
# 132 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
char* _Nullable asctime(const struct tm* _Nonnull __tm);
# 142 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
char* _Nullable asctime_r(const struct tm* _Nonnull __tm, char* _Nonnull __buf);







double difftime(time_t __lhs, time_t __rhs);
# 161 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
time_t mktime(struct tm* _Nonnull __tm);
# 186 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
struct tm* _Nullable localtime(const time_t* _Nonnull __t);
# 198 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
struct tm* _Nullable localtime_r(const time_t* _Nonnull __t, struct tm* _Nonnull __tm);
# 218 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
time_t timelocal(struct tm* _Nonnull __tm);
# 229 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
struct tm* _Nullable gmtime(const time_t* _Nonnull __t);
# 240 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
struct tm* _Nullable gmtime_r(const time_t* _Nonnull __t, struct tm* _Nonnull __tm);




time_t timegm(struct tm* _Nonnull __tm);







char* _Nullable strptime(const char* _Nonnull __s, const char* _Nonnull __fmt, struct tm* _Nonnull __tm) __attribute__((__format__(strftime, 2, 0)));




char* _Nullable strptime_l(const char* _Nonnull __s, const char* _Nonnull __fmt, struct tm* _Nonnull __tm, locale_t _Nonnull __l) __attribute__((__format__(strftime, 2, 0))) __asm__("strptime");







size_t strftime(char* _Nonnull __buf, size_t __n, const char* _Nonnull __fmt, const struct tm* _Nullable __tm) __attribute__((__format__(strftime, 3, 0)));




size_t strftime_l(char* _Nonnull __buf, size_t __n, const char* _Nonnull __fmt, const struct tm* _Nullable __tm, locale_t _Nonnull __l) __attribute__((__format__(strftime, 3, 0)));
# 283 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
char* _Nullable ctime(const time_t* _Nonnull __t);
# 293 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
char* _Nullable ctime_r(const time_t* _Nonnull __t, char* _Nonnull __buf);
# 307 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
void tzset(void);
# 354 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
clock_t clock(void);
# 364 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
int clock_getcpuclockid(pid_t __pid, clockid_t* _Nonnull __clock) __attribute__((__availability__(android,strict,introduced=23 )));
# 374 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
int clock_getres(clockid_t __clock, struct timespec* _Nullable __resolution);







int clock_gettime(clockid_t __clock, struct timespec* _Nonnull __ts);
# 393 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
int clock_nanosleep(clockid_t __clock, int __flags, const struct timespec* _Nonnull __time, struct timespec* _Nullable __remainder);







int clock_settime(clockid_t __clock, const struct timespec* _Nonnull __ts);







int timer_create(clockid_t __clock, struct sigevent* _Nullable __event, timer_t _Nonnull * _Nonnull __timer_ptr);







int timer_delete(timer_t _Nonnull __timer);







int timer_settime(timer_t _Nonnull __timer, int __flags, const struct itimerspec* _Nonnull __new_value, struct itimerspec* _Nullable __old_value);







int timer_gettime(timer_t _Nonnull _timer, struct itimerspec* _Nonnull __ts);
# 442 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
int timer_getoverrun(timer_t _Nonnull __timer);
# 500 "/data/data/com.termux/files/usr/bin/../../usr/include/time.h" 3 4
}
# 38 "/data/data/com.termux/files/usr/bin/../../usr/include/wchar.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/bionic_multibyte_result.h" 1 3 4
# 39 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/bionic_multibyte_result.h" 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stddef.h" 1 3 4
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/bionic_multibyte_result.h" 2 3 4

extern "C" {







enum : size_t {


  BIONIC_MULTIBYTE_RESULT_ILLEGAL_SEQUENCE = -1UL,




  BIONIC_MULTIBYTE_RESULT_INCOMPLETE_SEQUENCE = -2UL,







  BIONIC_MULTIBYTE_RESULT_NO_BYTES_CONSUMED = -3UL,

};

}
# 41 "/data/data/com.termux/files/usr/bin/../../usr/include/wchar.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/mbstate_t.h" 1 3 4
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/bits/mbstate_t.h" 3 4
typedef struct {
  unsigned char __seq[4];

  unsigned char __reserved[4];

} mbstate_t;
# 42 "/data/data/com.termux/files/usr/bin/../../usr/include/wchar.h" 2 3 4



extern "C" {

wint_t btowc(int __ch);
int fwprintf(FILE* _Nonnull __fp, const wchar_t* _Nonnull __fmt, ...);
int fwscanf(FILE* _Nonnull __fp, const wchar_t* _Nonnull __fmt, ...);
wint_t fgetwc(FILE* _Nonnull __fp);
wchar_t* _Nullable fgetws(wchar_t* _Nonnull __buf, int __size, FILE* _Nonnull __fp);
wint_t fputwc(wchar_t __wc, FILE* _Nonnull __fp);
int fputws(const wchar_t* _Nonnull __s, FILE* _Nonnull __fp);
int fwide(FILE* _Nonnull __fp, int __mode);
wint_t getwc(FILE* _Nonnull __fp);
wint_t getwchar(void);
int mbsinit(const mbstate_t* _Nullable __ps);
size_t mbrlen(const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps);
size_t mbrtowc(wchar_t* _Nullable __buf, const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps);
size_t mbsrtowcs(wchar_t* _Nullable __dst, const char* _Nullable * _Nonnull __src, size_t __dst_n, mbstate_t* _Nullable __ps);
size_t mbsrtowcs_l(wchar_t* _Nullable __dst, const char* _Nullable * _Nonnull __src, size_t __dst_n, mbstate_t* _Nullable __ps, locale_t _Nonnull __l) __asm__("mbsrtowcs");
size_t mbsnrtowcs(wchar_t* _Nullable __dst, const char* _Nullable * _Nullable __src, size_t __src_n, size_t __dst_n, mbstate_t* _Nullable __ps);
wint_t putwc(wchar_t __wc, FILE* _Nonnull __fp);
wint_t putwchar(wchar_t __wc);
int swprintf(wchar_t* _Nonnull __buf, size_t __n, const wchar_t* _Nonnull __fmt, ...);
int swscanf(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __fmt, ...);
wint_t ungetwc(wint_t __wc, FILE* _Nonnull __fp);
int vfwprintf(FILE* _Nonnull __fp, const wchar_t* _Nonnull __fmt, va_list __args);
int vfwscanf(FILE* _Nonnull __fp, const wchar_t* _Nonnull __fmt, va_list __args);
int vswprintf(wchar_t* _Nonnull __buf, size_t __n, const wchar_t* _Nonnull __fmt, va_list __args);
int vswscanf(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __fmt, va_list __args);
int vwprintf(const wchar_t* _Nonnull __fmt, va_list __args);
int vwscanf(const wchar_t* _Nonnull __fmt, va_list __args);
wchar_t* _Nonnull wcpcpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src);
wchar_t* _Nonnull wcpncpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
size_t wcrtomb(char* _Nullable __buf, wchar_t __wc, mbstate_t* _Nullable __ps);
int wcscasecmp(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs);


int wcscasecmp_l(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs, locale_t _Nonnull __l) __attribute__((__availability__(android,strict,introduced=23 )));


wchar_t* _Nonnull wcscat(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src);
wchar_t* _Nullable wcschr(const wchar_t * _Nonnull __s, wchar_t __wc);
int wcscmp(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs);
int wcscoll(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs);
wchar_t* _Nonnull wcscpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src);
size_t wcscspn(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __accept);
size_t wcsftime(wchar_t* _Nonnull __buf, size_t __n, const wchar_t* _Nullable __fmt, const struct tm* _Nonnull __tm);





size_t wcslen(const wchar_t* _Nonnull __s);
int wcsncasecmp(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs, size_t __n);


int wcsncasecmp_l(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs, size_t __n, locale_t _Nonnull __l) __attribute__((__availability__(android,strict,introduced=23 )));


wchar_t* _Nonnull wcsncat(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
int wcsncmp(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs, size_t __n);
wchar_t* _Nonnull wcsncpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
size_t wcsnrtombs(char* _Nullable __dst, const wchar_t* _Null_unspecified * _Nullable __src, size_t __src_n, size_t __dst_n, mbstate_t* _Nullable __ps);
wchar_t* _Nullable wcspbrk(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __accept);
wchar_t* _Nullable wcsrchr(const wchar_t* _Nonnull __s, wchar_t __wc);
size_t wcsrtombs(char* _Nullable __dst, const wchar_t* _Null_unspecified * _Nullable __src, size_t __dst_n, mbstate_t* _Nullable __ps);
size_t wcsrtombs_l(char* _Nullable __dst, const wchar_t* _Null_unspecified * _Nullable __src, size_t __dst_n, mbstate_t* _Nullable __ps, locale_t _Nonnull __l) __asm__("wcsrtombs");
size_t wcsspn(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __accept);
wchar_t* _Nullable wcsstr(const wchar_t* _Nonnull __haystack, const wchar_t* _Nonnull __needle);
double wcstod(const wchar_t* _Nonnull __s, wchar_t* _Null_unspecified * _Nullable __end_ptr);
double wcstod_l(const wchar_t* _Nonnull __s, wchar_t* _Null_unspecified * _Nullable __end_ptr, locale_t _Nonnull __l) __asm__("wcstod");
float wcstof(const wchar_t* _Nonnull __s, wchar_t* _Null_unspecified * _Nullable __end_ptr);
float wcstof_l(const wchar_t* _Nonnull __s, wchar_t* _Null_unspecified * _Nullable __end_ptr, locale_t _Nonnull __l) __asm__("wcstof");
wchar_t* _Nullable wcstok(wchar_t* _Nullable __s, const wchar_t* _Nonnull __delimiter, wchar_t* _Nonnull * _Nonnull __ptr);
long wcstol(const wchar_t* _Nonnull __s, wchar_t* _Null_unspecified * _Nullable __end_ptr, int __base);
long wcstol_l(const wchar_t* _Nonnull __s, wchar_t* _Null_unspecified * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __asm__("wcstol");
long long wcstoll(const wchar_t* _Nonnull __s, wchar_t* _Null_unspecified * _Nullable __end_ptr, int __base);
long double wcstold(const wchar_t* _Nonnull __s, wchar_t* _Null_unspecified * _Nullable __end_ptr);
unsigned long wcstoul(const wchar_t* _Nonnull __s, wchar_t* _Null_unspecified * _Nullable __end_ptr, int __base);
unsigned long wcstoul_l(const wchar_t* _Nonnull __s, wchar_t* _Null_unspecified * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __asm__("wcstoul");
unsigned long long wcstoull(const wchar_t* _Nonnull __s, wchar_t* _Null_unspecified * _Nullable __end_ptr, int __base);
int wcswidth(const wchar_t* _Nonnull __s, size_t __n);
size_t wcsxfrm(wchar_t* _Null_unspecified __dst, const wchar_t* _Nonnull __src, size_t __n);
int wctob(wint_t __wc);
int wcwidth(wchar_t __wc);
wchar_t* _Nullable wmemchr(const wchar_t* _Nonnull __src, wchar_t __wc, size_t __n);
int wmemcmp(const wchar_t* _Nullable __lhs, const wchar_t* _Nullable __rhs, size_t __n);
wchar_t* _Nonnull wmemcpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);



wchar_t* _Nonnull wmempcpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n) __attribute__((__availability__(android,strict,introduced=23 )));



wchar_t* _Nonnull wmemmove(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
wchar_t* _Nonnull wmemset(wchar_t* _Nonnull __dst, wchar_t __wc, size_t __n);
int wprintf(const wchar_t* _Nonnull __fmt, ...);
int wscanf(const wchar_t* _Nonnull __fmt, ...);

long long wcstoll_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
unsigned long long wcstoull_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
long double wcstold_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l);

int wcscoll_l(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs, locale_t _Nonnull __l) __attribute__((__pure__));
size_t wcsxfrm_l(wchar_t* _Null_unspecified __dst, const wchar_t* _Nonnull __src, size_t __n, locale_t _Nonnull __l);
size_t wcslcat(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
size_t wcslcpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);



FILE* _Nullable open_wmemstream(wchar_t* _Nonnull * _Nonnull __ptr, size_t* _Nonnull __size_ptr) __attribute__((__availability__(android,strict,introduced=23 )));


wchar_t* _Nullable wcsdup(const wchar_t* _Nonnull __s);
size_t wcsnlen(const wchar_t* _Nonnull __s, size_t __n);

}
# 128 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/wchar.h" 2 3
# 146 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/wchar.h" 3
extern "C++" {
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) wchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {
  return (wchar_t*)wcschr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {
  return __libcpp_wcschr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) wchar_t* wcschr(wchar_t* __s, wchar_t __c) {
  return __libcpp_wcschr(__s, __c);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) wchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {
  return (wchar_t*)wcspbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) const wchar_t*
wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {
  return __libcpp_wcspbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) wchar_t* wcspbrk(wchar_t* __s1, const wchar_t* __s2) {
  return __libcpp_wcspbrk(__s1, __s2);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) wchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {
  return (wchar_t*)wcsrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {
  return __libcpp_wcsrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) wchar_t* wcsrchr(wchar_t* __s, wchar_t __c) {
  return __libcpp_wcsrchr(__s, __c);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) wchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {
  return (wchar_t*)wcsstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) const wchar_t*
wcsstr(const wchar_t* __s1, const wchar_t* __s2) {
  return __libcpp_wcsstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) wchar_t* wcsstr(wchar_t* __s1, const wchar_t* __s2) {
  return __libcpp_wcsstr(__s1, __s2);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) wchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {
  return (wchar_t*)wmemchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) const wchar_t*
wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {
  return __libcpp_wmemchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __attribute__((__enable_if__(true, ""))) wchar_t* wmemchr(wchar_t* __s, wchar_t __c, size_t __n) {
  return __libcpp_wmemchr(__s, __c, __n);
}
}
# 114 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cwchar" 2 3
# 125 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cwchar" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

using ::mbstate_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));
using ::tm __attribute__((__using_if_exists__));
using ::wint_t __attribute__((__using_if_exists__));
using ::FILE __attribute__((__using_if_exists__));
using ::fwprintf __attribute__((__using_if_exists__));
using ::fwscanf __attribute__((__using_if_exists__));
using ::swprintf __attribute__((__using_if_exists__));
using ::vfwprintf __attribute__((__using_if_exists__));
using ::vswprintf __attribute__((__using_if_exists__));
using ::swscanf __attribute__((__using_if_exists__));
using ::vfwscanf __attribute__((__using_if_exists__));
using ::vswscanf __attribute__((__using_if_exists__));
using ::fgetwc __attribute__((__using_if_exists__));
using ::fgetws __attribute__((__using_if_exists__));
using ::fputwc __attribute__((__using_if_exists__));
using ::fputws __attribute__((__using_if_exists__));
using ::fwide __attribute__((__using_if_exists__));
using ::getwc __attribute__((__using_if_exists__));
using ::putwc __attribute__((__using_if_exists__));
using ::ungetwc __attribute__((__using_if_exists__));
using ::wcstod __attribute__((__using_if_exists__));
using ::wcstof __attribute__((__using_if_exists__));
using ::wcstold __attribute__((__using_if_exists__));
using ::wcstol __attribute__((__using_if_exists__));
using ::wcstoll __attribute__((__using_if_exists__));
using ::wcstoul __attribute__((__using_if_exists__));
using ::wcstoull __attribute__((__using_if_exists__));
using ::wcscpy __attribute__((__using_if_exists__));
using ::wcsncpy __attribute__((__using_if_exists__));
using ::wcscat __attribute__((__using_if_exists__));
using ::wcsncat __attribute__((__using_if_exists__));
using ::wcscmp __attribute__((__using_if_exists__));
using ::wcscoll __attribute__((__using_if_exists__));
using ::wcsncmp __attribute__((__using_if_exists__));
using ::wcsxfrm __attribute__((__using_if_exists__));
using ::wcschr __attribute__((__using_if_exists__));
using ::wcspbrk __attribute__((__using_if_exists__));
using ::wcsrchr __attribute__((__using_if_exists__));
using ::wcsstr __attribute__((__using_if_exists__));
using ::wmemchr __attribute__((__using_if_exists__));
using ::wcscspn __attribute__((__using_if_exists__));
using ::wcslen __attribute__((__using_if_exists__));
using ::wcsspn __attribute__((__using_if_exists__));
using ::wcstok __attribute__((__using_if_exists__));
using ::wmemcmp __attribute__((__using_if_exists__));
using ::wmemcpy __attribute__((__using_if_exists__));
using ::wmemmove __attribute__((__using_if_exists__));
using ::wmemset __attribute__((__using_if_exists__));
using ::wcsftime __attribute__((__using_if_exists__));
using ::btowc __attribute__((__using_if_exists__));
using ::wctob __attribute__((__using_if_exists__));
using ::mbsinit __attribute__((__using_if_exists__));
using ::mbrlen __attribute__((__using_if_exists__));
using ::mbrtowc __attribute__((__using_if_exists__));
using ::wcrtomb __attribute__((__using_if_exists__));
using ::mbsrtowcs __attribute__((__using_if_exists__));
using ::wcsrtombs __attribute__((__using_if_exists__));

using ::getwchar __attribute__((__using_if_exists__));
using ::vwscanf __attribute__((__using_if_exists__));
using ::wscanf __attribute__((__using_if_exists__));

using ::putwchar __attribute__((__using_if_exists__));
using ::vwprintf __attribute__((__using_if_exists__));
using ::wprintf __attribute__((__using_if_exists__));

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t __constexpr_wcslen(const wchar_t* __str) {

  return __builtin_wcslen(__str);
# 208 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cwchar" 3
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int
__constexpr_wmemcmp(const wchar_t* __lhs, const wchar_t* __rhs, size_t __count) {

  return __builtin_wmemcmp(__lhs, __rhs, __count);
# 226 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cwchar" 3
}

template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp* __constexpr_wmemchr(_Tp* __str, _Up __value, size_t __count) {
  static_assert(sizeof(_Tp) == sizeof(wchar_t)&& alignof(_Tp) >= alignof(wchar_t) &&
                    __libcpp_is_trivially_equality_comparable<_Tp, _Tp>::value,
                "Calling wmemchr on non-trivially equality comparable types is unsafe.");


  if (!__libcpp_is_constant_evaluated()) {
    wchar_t __value_buffer = 0;
    __builtin_memcpy(&__value_buffer, &__value, sizeof(wchar_t));
    return reinterpret_cast<_Tp*>(
        __builtin_wmemchr(reinterpret_cast<__apply_cv_t<_Tp, wchar_t>*>(__str), __value_buffer, __count));
  }

  else if constexpr (is_same_v<remove_cv_t<_Tp>, wchar_t>)
    return __builtin_wmemchr(__str, __value, __count);



  for (; __count; --__count) {
    if (*__str == __value)
      return __str;
    ++__str;
  }
  return nullptr;
}

}}
# 32 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find.h" 2 3
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {


template <class _Iter, class _Sent, class _Tp, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter
__find_impl(_Iter __first, _Sent __last, const _Tp& __value, _Proj& __proj) {
  for (; __first != __last; ++__first)
    if (std::__invoke(__proj, *__first) == __value)
      break;
  return __first;
}


template <class _Tp,
          class _Up,
          class _Proj,
          __enable_if_t<__is_identity<_Proj>::value && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value &&
                            sizeof(_Tp) == 1,
                        int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp*
__find_impl(_Tp* __first, _Tp* __last, const _Up& __value, _Proj&) {
  if (auto __ret = std::__constexpr_memchr(__first, __value, __last - __first))
    return __ret;
  return __last;
}


template <class _Tp,
          class _Up,
          class _Proj,
          __enable_if_t<__is_identity<_Proj>::value && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value &&
                            sizeof(_Tp) == sizeof(wchar_t) && alignof(_Tp) >= alignof(wchar_t),
                        int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp*
__find_impl(_Tp* __first, _Tp* __last, const _Up& __value, _Proj&) {
  if (auto __ret = std::__constexpr_wmemchr(__first, __value, __last - __first))
    return __ret;
  return __last;
}




template <class _Tp,
          class _Up,
          class _Proj,
          __enable_if_t<__is_identity<_Proj>::value && !__libcpp_is_trivially_equality_comparable<_Tp, _Up>::value &&
                            is_integral<_Tp>::value && is_integral<_Up>::value &&
                            is_signed<_Tp>::value == is_signed<_Up>::value,
                        int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Tp*
__find_impl(_Tp* __first, _Tp* __last, const _Up& __value, _Proj& __proj) {
  if (__value < numeric_limits<_Tp>::min() || __value > numeric_limits<_Tp>::max())
    return __last;
  return std::__find_impl(__first, __last, _Tp(__value), __proj);
}


template <bool _ToFind, class _Cp, bool _IsConst>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __bit_iterator<_Cp, _IsConst>
__find_bool(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n) {
  using _It = __bit_iterator<_Cp, _IsConst>;
  using __storage_type = typename _It::__storage_type;

  const int __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
    __storage_type __b = std::__invert_if<!_ToFind>(*__first.__seg_) & __m;
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
    if (__n == __dn)
      return __first + __n;
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word) {
    __storage_type __b = std::__invert_if<!_ToFind>(*__first.__seg_);
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
  }

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = std::__invert_if<!_ToFind>(*__first.__seg_) & __m;
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
  }
  return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp, class _Proj, __enable_if_t<__is_identity<_Proj>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __bit_iterator<_Cp, _IsConst>
__find_impl(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value, _Proj&) {
  if (static_cast<bool>(__value))
    return std::__find_bool<true>(__first, static_cast<typename _Cp::size_type>(__last - __first));
  return std::__find_bool<false>(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class>
struct __find_segment;

template <class _SegmentedIterator,
          class _Tp,
          class _Proj,
          __enable_if_t<__is_segmented_iterator<_SegmentedIterator>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _SegmentedIterator
__find_impl(_SegmentedIterator __first, _SegmentedIterator __last, const _Tp& __value, _Proj& __proj) {
  return std::__find_segment_if(std::move(__first), std::move(__last), __find_segment<_Tp>(__value), __proj);
}

template <class _Tp>
struct __find_segment {
  const _Tp& __value_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __find_segment(const _Tp& __value) : __value_(__value) {}

  template <class _InputIterator, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _InputIterator
  operator()(_InputIterator __first, _InputIterator __last, _Proj& __proj) const {
    return std::__find_impl(__first, __last, __value_, __proj);
  }
};


template <class _InputIterator, class _Tp>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value) {
  __identity __proj;
  return std::__rewrap_iter(
      __first, std::__find_impl(std::__unwrap_iter(__first), std::__unwrap_iter(__last), __value, __proj));
}

}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/remove.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find_if.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find_if.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIterator, class _Predicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      break;
  return __first;
}

}}
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/remove.h" 2 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/remove.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 23 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/remove.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _ForwardIterator, class _Tp>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  __first = std::find(__first, __last, __value);
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (!(*__i == __value)) {
        *__first = std::move(*__i);
        ++__first;
      }
    }
  }
  return __first;
}

}}
# 574 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/remove_if.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/remove_if.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 22 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/remove_if.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _ForwardIterator, class _Predicate>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  __first = std::find_if<_ForwardIterator, _Predicate&>(__first, __last, __pred);
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (!__pred(*__i)) {
        *__first = std::move(*__i);
        ++__first;
      }
    }
  }
  return __first;
}

}}
# 575 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__format/enable_insertable.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__format/enable_insertable.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



namespace __format {


template <class _Container>
inline constexpr bool __enable_insertable = false;

}



}}
# 578 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3
# 593 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/swap_allocator.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory/swap_allocator.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <typename _Alloc>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __swap_allocator(_Alloc& __a1, _Alloc& __a2, true_type)

    noexcept



{
  using std::swap;
  swap(__a1, __a2);
}

template <typename _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
__swap_allocator(_Alloc&, _Alloc&, false_type) noexcept {}

template <typename _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __swap_allocator(_Alloc& __a1, _Alloc& __a2)

    noexcept



{
  std::__swap_allocator(
      __a1, __a2, integral_constant<bool, allocator_traits<_Alloc>::propagate_on_container_swap::value>());
}

}}
# 594 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory_resource/polymorphic_allocator.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory_resource/polymorphic_allocator.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory_resource/memory_resource.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory_resource/memory_resource.h" 3




 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

namespace pmr {



class __attribute__((__visibility__("default"))) memory_resource {
  static const size_t __max_align = alignof(max_align_t);

public:
  virtual ~memory_resource();

  [[__nodiscard__]]
  [[using __gnu__: __returns_nonnull__, __alloc_size__(2), __alloc_align__(3)]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void*
  allocate(size_t __bytes, size_t __align = __max_align) {
    return do_allocate(__bytes, __align);
  }

  [[__gnu__::__nonnull__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void
  deallocate(void* __p, size_t __bytes, size_t __align = __max_align) {
    do_deallocate(__p, __bytes, __align);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool is_equal(const memory_resource& __other) const noexcept { return do_is_equal(__other); }

private:
  virtual void* do_allocate(size_t, size_t) = 0;
  virtual void do_deallocate(void*, size_t, size_t) = 0;
  virtual bool do_is_equal(memory_resource const&) const noexcept = 0;
};



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool
operator==(const memory_resource& __lhs, const memory_resource& __rhs) noexcept {
  return &__lhs == &__rhs || __lhs.is_equal(__rhs);
}
# 72 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory_resource/memory_resource.h" 3
[[__gnu__::__returns_nonnull__]] __attribute__((__visibility__("default"))) memory_resource*
get_default_resource() noexcept;

[[__gnu__::__returns_nonnull__]] __attribute__((__visibility__("default"))) memory_resource*
set_default_resource(memory_resource*) noexcept;

[[using __gnu__: __returns_nonnull__, __const__]] __attribute__((__visibility__("default"))) memory_resource*
new_delete_resource() noexcept;

[[using __gnu__: __returns_nonnull__, __const__]] __attribute__((__visibility__("default"))) memory_resource*
null_memory_resource() noexcept;

}

}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory_resource/polymorphic_allocator.h" 2 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory_resource/polymorphic_allocator.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory_resource/polymorphic_allocator.h" 2 3



 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

namespace pmr {



template <class _ValueType

          = byte

          >
class polymorphic_allocator {

public:
  using value_type = _ValueType;



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) polymorphic_allocator() noexcept : __res_(std::pmr::get_default_resource()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) polymorphic_allocator(memory_resource* __r) noexcept : __res_(__r) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) polymorphic_allocator(const polymorphic_allocator&) = default;

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) polymorphic_allocator(const polymorphic_allocator<_Tp>& __other) noexcept
      : __res_(__other.resource()) {}

  polymorphic_allocator& operator=(const polymorphic_allocator&) = delete;



  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _ValueType* allocate(size_t __n) {
    if (__n > __max_size()) {
      __throw_bad_array_new_length();
    }
    return static_cast<_ValueType*>(__res_->allocate(__n * sizeof(_ValueType), alignof(_ValueType)));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void deallocate(_ValueType* __p, size_t __n) {
    ((void)0);



    __res_->deallocate(__p, __n * sizeof(_ValueType), alignof(_ValueType));
  }



  [[nodiscard]] [[using __gnu__: __alloc_size__(2), __alloc_align__(3)]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void*
  allocate_bytes(size_t __nbytes, size_t __alignment = alignof(max_align_t)) {
    return __res_->allocate(__nbytes, __alignment);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void deallocate_bytes(void* __ptr, size_t __nbytes, size_t __alignment = alignof(max_align_t)) {
    __res_->deallocate(__ptr, __nbytes, __alignment);
  }

  template <class _Type>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Type* allocate_object(size_t __n = 1) {
    if (numeric_limits<size_t>::max() / sizeof(_Type) < __n)
      std::__throw_bad_array_new_length();
    return static_cast<_Type*>(allocate_bytes(__n * sizeof(_Type), alignof(_Type)));
  }

  template <class _Type>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void deallocate_object(_Type* __ptr, size_t __n = 1) {
    deallocate_bytes(__ptr, __n * sizeof(_Type), alignof(_Type));
  }

  template <class _Type, class... _CtorArgs>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) _Type* new_object(_CtorArgs&&... __ctor_args) {
    _Type* __ptr = allocate_object<_Type>();
    auto __guard = std::__make_exception_guard([&] { deallocate_object(__ptr); });
    construct(__ptr, std::forward<_CtorArgs>(__ctor_args)...);
    __guard.__complete();
    return __ptr;
  }

  template <class _Type>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void delete_object(_Type* __ptr) {
    destroy(__ptr);
    deallocate_object(__ptr);
  }



  template <class _Tp, class... _Ts>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void construct(_Tp* __p, _Ts&&... __args) {
    std::__user_alloc_construct_impl(
        typename __uses_alloc_ctor<_Tp, polymorphic_allocator&, _Ts...>::type(),
        __p,
        *this,
        std::forward<_Ts>(__args)...);
  }

  template <class _T1, class _T2, class... _Args1, class... _Args2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void
  construct(pair<_T1, _T2>* __p, piecewise_construct_t, tuple<_Args1...> __x, tuple<_Args2...> __y) {
    ::new ((void*)__p) pair<_T1, _T2>(
        piecewise_construct,
        __transform_tuple(typename __uses_alloc_ctor< _T1, polymorphic_allocator&, _Args1... >::type(),
                          std::move(__x),
                          typename __make_tuple_indices<sizeof...(_Args1)>::type{}),
        __transform_tuple(typename __uses_alloc_ctor< _T2, polymorphic_allocator&, _Args2... >::type(),
                          std::move(__y),
                          typename __make_tuple_indices<sizeof...(_Args2)>::type{}));
  }

  template <class _T1, class _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void construct(pair<_T1, _T2>* __p) {
    construct(__p, piecewise_construct, tuple<>(), tuple<>());
  }

  template <class _T1, class _T2, class _Up, class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void construct(pair<_T1, _T2>* __p, _Up&& __u, _Vp&& __v) {
    construct(__p,
              piecewise_construct,
              std::forward_as_tuple(std::forward<_Up>(__u)),
              std::forward_as_tuple(std::forward<_Vp>(__v)));
  }

  template <class _T1, class _T2, class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void construct(pair<_T1, _T2>* __p, const pair<_U1, _U2>& __pr) {
    construct(__p, piecewise_construct, std::forward_as_tuple(__pr.first), std::forward_as_tuple(__pr.second));
  }

  template <class _T1, class _T2, class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void construct(pair<_T1, _T2>* __p, pair<_U1, _U2>&& __pr) {
    construct(__p,
              piecewise_construct,
              std::forward_as_tuple(std::forward<_U1>(__pr.first)),
              std::forward_as_tuple(std::forward<_U2>(__pr.second)));
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void destroy(_Tp* __p) {
    __p->~_Tp();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) polymorphic_allocator select_on_container_copy_construction() const noexcept {
    return polymorphic_allocator();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) memory_resource* resource() const noexcept { return __res_; }

private:
  template <class... _Args, size_t... _Is>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) tuple<_Args&&...>
  __transform_tuple(integral_constant<int, 0>, tuple<_Args...>&& __t, __tuple_indices<_Is...>) {
    return std::forward_as_tuple(std::get<_Is>(std::move(__t))...);
  }

  template <class... _Args, size_t... _Is>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) tuple<allocator_arg_t const&, polymorphic_allocator&, _Args&&...>
  __transform_tuple(integral_constant<int, 1>, tuple<_Args...>&& __t, __tuple_indices<_Is...>) {
    using _Tup = tuple<allocator_arg_t const&, polymorphic_allocator&, _Args&&...>;
    return _Tup(allocator_arg, *this, std::get<_Is>(std::move(__t))...);
  }

  template <class... _Args, size_t... _Is>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) tuple<_Args&&..., polymorphic_allocator&>
  __transform_tuple(integral_constant<int, 2>, tuple<_Args...>&& __t, __tuple_indices<_Is...>) {
    using _Tup = tuple<_Args&&..., polymorphic_allocator&>;
    return _Tup(std::get<_Is>(std::move(__t))..., *this);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t __max_size() const noexcept {
    return numeric_limits<size_t>::max() / sizeof(value_type);
  }

  memory_resource* __res_;
};



template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool
operator==(const polymorphic_allocator<_Tp>& __lhs, const polymorphic_allocator<_Up>& __rhs) noexcept {
  return *__lhs.resource() == *__rhs.resource();
}
# 223 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__memory_resource/polymorphic_allocator.h" 3
}

}}
# 595 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3


# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/container_compatible_range.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/container_compatible_range.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Range, class _Tp>
concept _ContainerCompatibleRange =
    ranges::input_range<_Range> && convertible_to<ranges::range_reference_t<_Range>, _Tp>;



}}
# 598 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/from_range.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__ranges/from_range.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



struct from_range_t {
  explicit from_range_t() = default;
};

inline constexpr from_range_t from_range{};



}}
# 599 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 1 3
# 12 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy_n.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/copy_n.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _InputIterator,
          class _Size,
          class _OutputIterator,
          __enable_if_t<__has_input_iterator_category<_InputIterator>::value &&
                            !__has_random_access_iterator_category<_InputIterator>::value,
                        int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _OutputIterator
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) {
  typedef decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  if (__n > 0) {
    *__result = *__first;
    ++__result;
    for (--__n; __n > 0; --__n) {
      ++__first;
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

template <class _InputIterator,
          class _Size,
          class _OutputIterator,
          __enable_if_t<__has_random_access_iterator_category<_InputIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _OutputIterator
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) {
  typedef typename iterator_traits<_InputIterator>::difference_type difference_type;
  typedef decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  return std::copy(__first, __first + difference_type(__n), __result);
}

}}
# 13 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find_end.h" 1 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find_end.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/search.h" 1 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/search.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _AlgPolicy,
          class _Iter1,
          class _Sent1,
          class _Iter2,
          class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_Iter1, _Iter1> __search_forward_impl(
    _Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2, _Pred& __pred, _Proj1& __proj1, _Proj2& __proj2) {
  if (__first2 == __last2)
    return std::make_pair(__first1, __first1);
  while (true) {

    while (true) {
      if (__first1 == __last1) {
        _IterOps<_AlgPolicy>::__advance_to(__first1, __last1);
        return std::make_pair(__first1, __first1);
      }
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }

    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return std::make_pair(__first1, ++__m1);
      if (++__m1 == __last1) {
        return std::make_pair(__m1, __m1);
      }


      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2))) {
        ++__first1;
        break;
      }
    }
  }
}

template <class _AlgPolicy,
          class _Iter1,
          class _Sent1,
          class _Iter2,
          class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2,
          class _DiffT1,
          class _DiffT2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_Iter1, _Iter1> __search_random_access_impl(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    _DiffT1 __size1,
    _DiffT2 __size2) {
  const _Iter1 __s = __first1 + __size1 - _DiffT1(__size2 - 1);

  while (true) {
    while (true) {
      if (__first1 == __s) {
        _IterOps<_AlgPolicy>::__advance_to(__first1, __last1);
        return std::make_pair(__first1, __first1);
      }
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }

    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return std::make_pair(__first1, __first1 + _DiffT1(__size2));
      ++__m1;
      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2))) {
        ++__first1;
        break;
      }
    }
  }
}

template <class _Iter1,
          class _Sent1,
          class _Iter2,
          class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2,
          __enable_if_t<__has_random_access_iterator_category<_Iter1>::value &&
                            __has_random_access_iterator_category<_Iter2>::value,
                        int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_Iter1, _Iter1> __search_impl(
    _Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2, _Pred& __pred, _Proj1& __proj1, _Proj2& __proj2) {
  auto __size2 = __last2 - __first2;
  if (__size2 == 0)
    return std::make_pair(__first1, __first1);

  auto __size1 = __last1 - __first1;
  if (__size1 < __size2) {
    return std::make_pair(__last1, __last1);
  }

  return std::__search_random_access_impl<_ClassicAlgPolicy>(
      __first1, __last1, __first2, __last2, __pred, __proj1, __proj2, __size1, __size2);
}

template <
    class _Iter1,
    class _Sent1,
    class _Iter2,
    class _Sent2,
    class _Pred,
    class _Proj1,
    class _Proj2,
    __enable_if_t<__has_forward_iterator_category<_Iter1>::value && __has_forward_iterator_category<_Iter2>::value &&
                      !(__has_random_access_iterator_category<_Iter1>::value &&
                        __has_random_access_iterator_category<_Iter2>::value),
                  int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pair<_Iter1, _Iter1> __search_impl(
    _Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2, _Pred& __pred, _Proj1& __proj1, _Proj2& __proj2) {
  return std::__search_forward_impl<_ClassicAlgPolicy>(__first1, __last1, __first2, __last2, __pred, __proj1, __proj2);
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator1
search(_ForwardIterator1 __first1,
       _ForwardIterator1 __last1,
       _ForwardIterator2 __first2,
       _ForwardIterator2 __last2,
       _BinaryPredicate __pred) {
  static_assert(__is_callable<_BinaryPredicate, decltype(*__first1), decltype(*__first2)>::value,
                "BinaryPredicate has to be callable");
  auto __proj = __identity();
  return std::__search_impl(__first1, __last1, __first2, __last2, __pred, __proj, __proj).first;
}

template <class _ForwardIterator1, class _ForwardIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::search(__first1, __last1, __first2, __last2, __equal_to());
}


template <class _ForwardIterator, class _Searcher>
[[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator
search(_ForwardIterator __f, _ForwardIterator __l, const _Searcher& __s) {
  return __s(__f, __l).first;
}



}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find_end.h" 2 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find_end.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template < class _AlgPolicy,
           class _Iter1,
           class _Sent1,
           class _Iter2,
           class _Sent2,
           class _Pred,
           class _Proj1,
           class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr pair<_Iter1, _Iter1> __find_end_impl(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    forward_iterator_tag,
    forward_iterator_tag) {

  _Iter1 __match_first = _IterOps<_AlgPolicy>::next(__first1, __last1);
  _Iter1 __match_last = __match_first;
  if (__first2 == __last2)
    return pair<_Iter1, _Iter1>(__match_last, __match_last);
  while (true) {
    while (true) {
      if (__first1 == __last1)
        return pair<_Iter1, _Iter1>(__match_first, __match_last);
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }

    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2) {
        __match_first = __first1;
        __match_last = ++__m1;
        ++__first1;
        break;
      }
      if (++__m1 == __last1)
        return pair<_Iter1, _Iter1>(__match_first, __match_last);

      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2))) {
        ++__first1;
        break;
      }
    }
  }
}

template < class _IterOps,
           class _Pred,
           class _Iter1,
           class _Sent1,
           class _Iter2,
           class _Sent2,
           class _Proj1,
           class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter1 __find_end(
    _Iter1 __first1,
    _Sent1 __sent1,
    _Iter2 __first2,
    _Sent2 __sent2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    bidirectional_iterator_tag,
    bidirectional_iterator_tag) {
  auto __last1 = _IterOps::next(__first1, __sent1);
  auto __last2 = _IterOps::next(__first2, __sent2);

  if (__first2 == __last2)
    return __last1;
  _Iter1 __l1 = __last1;
  _Iter2 __l2 = __last2;
  --__l2;
  while (true) {

    while (true) {
      if (__first1 == __l1)
        return __last1;
      if (std::__invoke(__pred, std::__invoke(__proj1, *--__l1), std::__invoke(__proj2, *__l2)))
        break;
    }

    _Iter1 __m1 = __l1;
    _Iter2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;
      if (__m1 == __first1)
        return __last1;


      if (!std::__invoke(__pred, std::__invoke(__proj1, *--__m1), std::__invoke(__proj2, *--__m2))) {
        break;
      }
    }
  }
}

template < class _AlgPolicy,
           class _Pred,
           class _Iter1,
           class _Sent1,
           class _Iter2,
           class _Sent2,
           class _Proj1,
           class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _Iter1 __find_end(
    _Iter1 __first1,
    _Sent1 __sent1,
    _Iter2 __first2,
    _Sent2 __sent2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    random_access_iterator_tag,
    random_access_iterator_tag) {
  typedef typename iterator_traits<_Iter1>::difference_type _D1;
  auto __last1 = _IterOps<_AlgPolicy>::next(__first1, __sent1);
  auto __last2 = _IterOps<_AlgPolicy>::next(__first2, __sent2);

  auto __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __last1;
  auto __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;
  const _Iter1 __s = __first1 + _D1(__len2 - 1);
  _Iter1 __l1 = __last1;
  _Iter2 __l2 = __last2;
  --__l2;
  while (true) {
    while (true) {
      if (__s == __l1)
        return __last1;
      if (std::__invoke(__pred, std::__invoke(__proj1, *--__l1), std::__invoke(__proj2, *__l2)))
        break;
    }
    _Iter1 __m1 = __l1;
    _Iter2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;

      if (!std::__invoke(__pred, std::__invoke(__proj1, *--__m1), std::__invoke(*--__m2))) {
        break;
      }
    }
  }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator1 __find_end_classic(
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardIterator2 __last2,
    _BinaryPredicate& __pred) {
  auto __proj = __identity();
  return std::__find_end_impl<_ClassicAlgPolicy>(
             __first1,
             __last1,
             __first2,
             __last2,
             __pred,
             __proj,
             __proj,
             typename iterator_traits<_ForwardIterator1>::iterator_category(),
             typename iterator_traits<_ForwardIterator2>::iterator_category())
      .first;
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator1 find_end(
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardIterator2 __last2,
    _BinaryPredicate __pred) {
  return std::__find_end_classic(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::find_end(__first1, __last1, __first2, __last2, __equal_to());
}

}}
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find_first_of.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__algorithm/find_first_of.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator1 __find_first_of_ce(
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardIterator2 __last2,
    _BinaryPredicate&& __pred) {
  for (; __first1 != __last1; ++__first1)
    for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
      if (__pred(*__first1, *__j))
        return __first1;
  return __last1;
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator1 find_first_of(
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardIterator2 __last2,
    _BinaryPredicate __pred) {
  return std::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
[[__nodiscard__]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr _ForwardIterator1 find_first_of(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to());
}

}}
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 2 3
# 27 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdio" 1 3
# 100 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdio" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/stdio.h" 1 3
# 101 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdio" 2 3
# 112 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/cstdio" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

using ::FILE __attribute__((__using_if_exists__));
using ::fpos_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));

using ::fclose __attribute__((__using_if_exists__));
using ::fflush __attribute__((__using_if_exists__));
using ::setbuf __attribute__((__using_if_exists__));
using ::setvbuf __attribute__((__using_if_exists__));
using ::fprintf __attribute__((__using_if_exists__));
using ::fscanf __attribute__((__using_if_exists__));
using ::snprintf __attribute__((__using_if_exists__));
using ::sprintf __attribute__((__using_if_exists__));
using ::sscanf __attribute__((__using_if_exists__));
using ::vfprintf __attribute__((__using_if_exists__));
using ::vfscanf __attribute__((__using_if_exists__));
using ::vsscanf __attribute__((__using_if_exists__));
using ::vsnprintf __attribute__((__using_if_exists__));
using ::vsprintf __attribute__((__using_if_exists__));
using ::fgetc __attribute__((__using_if_exists__));
using ::fgets __attribute__((__using_if_exists__));
using ::fputc __attribute__((__using_if_exists__));
using ::fputs __attribute__((__using_if_exists__));
using ::getc __attribute__((__using_if_exists__));
using ::putc __attribute__((__using_if_exists__));
using ::ungetc __attribute__((__using_if_exists__));
using ::fread __attribute__((__using_if_exists__));
using ::fwrite __attribute__((__using_if_exists__));
using ::fgetpos __attribute__((__using_if_exists__));
using ::fseek __attribute__((__using_if_exists__));
using ::fsetpos __attribute__((__using_if_exists__));
using ::ftell __attribute__((__using_if_exists__));
using ::rewind __attribute__((__using_if_exists__));
using ::clearerr __attribute__((__using_if_exists__));
using ::feof __attribute__((__using_if_exists__));
using ::ferror __attribute__((__using_if_exists__));
using ::perror __attribute__((__using_if_exists__));

using ::fopen __attribute__((__using_if_exists__));
using ::freopen __attribute__((__using_if_exists__));
using ::remove __attribute__((__using_if_exists__));
using ::rename __attribute__((__using_if_exists__));
using ::tmpfile __attribute__((__using_if_exists__));
using ::tmpnam __attribute__((__using_if_exists__));

using ::getchar __attribute__((__using_if_exists__));



using ::scanf __attribute__((__using_if_exists__));
using ::vscanf __attribute__((__using_if_exists__));

using ::printf __attribute__((__using_if_exists__));
using ::putchar __attribute__((__using_if_exists__));
using ::puts __attribute__((__using_if_exists__));
using ::vprintf __attribute__((__using_if_exists__));

}}
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/iosfwd" 1 3
# 110 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/iosfwd" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/fstream.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/fstream.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_fstream;

using filebuf = basic_filebuf<char>;
using ifstream = basic_ifstream<char>;
using ofstream = basic_ofstream<char>;
using fstream = basic_fstream<char>;


using wfilebuf = basic_filebuf<wchar_t>;
using wifstream = basic_ifstream<wchar_t>;
using wofstream = basic_ofstream<wchar_t>;
using wfstream = basic_fstream<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(filebuf))) __attribute__((__preferred_name__(wfilebuf))) basic_filebuf;
template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ifstream))) __attribute__((__preferred_name__(wifstream))) basic_ifstream;
template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ofstream))) __attribute__((__preferred_name__(wofstream))) basic_ofstream;
template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(fstream))) __attribute__((__preferred_name__(wfstream))) basic_fstream;

}}
# 111 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/iosfwd" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/istream.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/istream.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_istream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_iostream;

using istream = basic_istream<char>;
using iostream = basic_iostream<char>;


using wistream = basic_istream<wchar_t>;
using wiostream = basic_iostream<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(istream))) __attribute__((__preferred_name__(wistream))) basic_istream;

template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(iostream))) __attribute__((__preferred_name__(wiostream))) basic_iostream;

}}
# 113 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/iosfwd" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/sstream.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/sstream.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_stringbuf;

template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_stringstream;

using stringbuf = basic_stringbuf<char>;
using istringstream = basic_istringstream<char>;
using ostringstream = basic_ostringstream<char>;
using stringstream = basic_stringstream<char>;


using wstringbuf = basic_stringbuf<wchar_t>;
using wistringstream = basic_istringstream<wchar_t>;
using wostringstream = basic_ostringstream<wchar_t>;
using wstringstream = basic_stringstream<wchar_t>;


template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(stringbuf))) __attribute__((__preferred_name__(wstringbuf))) basic_stringbuf;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(istringstream)))
    __attribute__((__preferred_name__(wistringstream))) basic_istringstream;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(ostringstream)))
    __attribute__((__preferred_name__(wostringstream))) basic_ostringstream;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(stringstream)))
    __attribute__((__preferred_name__(wstringstream))) basic_stringstream;

}}
# 115 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/iosfwd" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/streambuf.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/streambuf.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_streambuf;

using streambuf = basic_streambuf<char>;


using wstreambuf = basic_streambuf<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(streambuf))) __attribute__((__preferred_name__(wstreambuf))) basic_streambuf;

}}
# 116 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/iosfwd" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__std_mbstate_t.h" 1 3
# 14 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__std_mbstate_t.h" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__mbstate_t.h" 1 3
# 17 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__mbstate_t.h" 3
# 15 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__std_mbstate_t.h" 2 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__std_mbstate_t.h" 3





 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

using ::mbstate_t __attribute__((__using_if_exists__));

}}
# 118 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/iosfwd" 2 3
# 122 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/iosfwd" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

class __attribute__((__visibility__("default"))) ios_base;

template <class _CharT, class _Traits = char_traits<_CharT> >
class istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
class ostreambuf_iterator;

template <class _State>
class fpos;
typedef fpos<mbstate_t> streampos;

typedef fpos<mbstate_t> wstreampos;


typedef fpos<mbstate_t> u8streampos;

typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;
# 166 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/iosfwd" 3
template <class _Tp, class _Alloc = allocator<_Tp> >
class vector;

template <class _CharT, class _Traits>
class __save_flags {
  typedef basic_ios<_CharT, _Traits> __stream_type;
  typedef typename __stream_type::fmtflags fmtflags;

  __stream_type& __stream_;
  fmtflags __fmtflags_;
  _CharT __fill_;

  __save_flags(const __save_flags&);
  __save_flags& operator=(const __save_flags&);

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) explicit __save_flags(__stream_type& __stream)
      : __stream_(__stream), __fmtflags_(__stream.flags()), __fill_(__stream.fill()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) ~__save_flags() {
    __stream_.flags(__fmtflags_);
    __stream_.fill(__fill_);
  }
};

}}
# 29 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 2 3
# 36 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 40 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _CharT>
struct char_traits;
# 78 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 3
template <>
struct char_traits<char> {
  using char_type = char;
  using int_type = int;
  using off_type = streamoff;
  using pos_type = streampos;
  using state_type = mbstate_t;

  using comparison_category = strong_ordering;


  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
  assign(char_type& __c1, const char_type& __c2) noexcept {
    __c1 = __c2;
  }


  static inline __attribute__((__visibility__("hidden"))) constexpr bool eq(char_type __c1, char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool lt(char_type __c1, char_type __c2) noexcept {
    return (unsigned char)__c1 < (unsigned char)__c2;
  }



  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int
  compare(const char_type* __lhs, const char_type* __rhs, size_t __count) noexcept {
    if (__libcpp_is_constant_evaluated()) {

      return __builtin_memcmp(__lhs, __rhs, __count);
# 122 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/char_traits.h" 3
    } else {
      return __builtin_memcmp(__lhs, __rhs, __count);
    }
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t constexpr length(const char_type* __s) noexcept {
    return std::__constexpr_strlen(__s);
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const char_type*
  find(const char_type* __s, size_t __n, const char_type& __a) noexcept {
    if (__n == 0)
      return nullptr;
    return std::__constexpr_memchr(__s, __a, __n);
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type*
  move(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type*
  copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    ((void)0);

    std::copy_n(__s2, __n, __s1);
    return __s1;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type*
  assign(char_type* __s, size_t __n, char_type __a) noexcept {
    std::fill_n(__s, __n, __a);
    return __s;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type to_int_type(char_type __c) noexcept {
    return int_type((unsigned char)__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type eof() noexcept { return int_type((-1)); }
};




template <>
struct char_traits<wchar_t> {
  using char_type = wchar_t;
  using int_type = wint_t;
  using off_type = streamoff;
  using pos_type = streampos;
  using state_type = mbstate_t;

  using comparison_category = strong_ordering;


  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
  assign(char_type& __c1, const char_type& __c2) noexcept {
    __c1 = __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool eq(char_type __c1, char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool lt(char_type __c1, char_type __c2) noexcept {
    return __c1 < __c2;
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int
  compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    if (__n == 0)
      return 0;
    return std::__constexpr_wmemcmp(__s1, __s2, __n);
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t length(const char_type* __s) noexcept {
    return std::__constexpr_wcslen(__s);
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const char_type*
  find(const char_type* __s, size_t __n, const char_type& __a) noexcept {
    if (__n == 0)
      return nullptr;
    return std::__constexpr_wmemchr(__s, __a, __n);
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type*
  move(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type*
  copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    ((void)0);

    std::copy_n(__s2, __n, __s1);
    return __s1;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type*
  assign(char_type* __s, size_t __n, char_type __a) noexcept {
    std::fill_n(__s, __n, __a);
    return __s;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type to_int_type(char_type __c) noexcept {
    return int_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type eof() noexcept { return int_type((static_cast<wint_t>(-1))); }
};




template <>
struct char_traits<char8_t> {
  using char_type = char8_t;
  using int_type = unsigned int;
  using off_type = streamoff;
  using pos_type = u8streampos;
  using state_type = mbstate_t;

  using comparison_category = strong_ordering;


  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void assign(char_type& __c1, const char_type& __c2) noexcept {
    __c1 = __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool eq(char_type __c1, char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool lt(char_type __c1, char_type __c2) noexcept { return __c1 < __c2; }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int
  compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    return std::__constexpr_memcmp(__s1, __s2, __element_count(__n));
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_t length(const char_type* __s) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr const char_type*
  find(const char_type* __s, size_t __n, const char_type& __a) noexcept;

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type*
  move(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type*
  copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    ((void)0);

    std::copy_n(__s2, __n, __s1);
    return __s1;
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type*
  assign(char_type* __s, size_t __n, char_type __a) noexcept {
    std::fill_n(__s, __n, __a);
    return __s;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type to_char_type(int_type __c) noexcept { return char_type(__c); }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type to_int_type(char_type __c) noexcept { return int_type(__c); }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type eof() noexcept { return int_type((-1)); }
};


inline constexpr size_t char_traits<char8_t>::length(const char_type* __s) noexcept {
  size_t __len = 0;
  for (; !eq(*__s, char_type(0)); ++__s)
    ++__len;
  return __len;
}


inline constexpr const char8_t*
char_traits<char8_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept {
  for (; __n; --__n) {
    if (eq(*__s, __a))
      return __s;
    ++__s;
  }
  return nullptr;
}



template <>
struct char_traits<char16_t> {
  using char_type = char16_t;
  using int_type = uint_least16_t;
  using off_type = streamoff;
  using pos_type = u16streampos;
  using state_type = mbstate_t;

  using comparison_category = strong_ordering;


  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
  assign(char_type& __c1, const char_type& __c2) noexcept {
    __c1 = __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool eq(char_type __c1, char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool lt(char_type __c1, char_type __c2) noexcept {
    return __c1 < __c2;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr int
  compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr size_t length(const char_type* __s) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr const char_type*
  find(const char_type* __s, size_t __n, const char_type& __a) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static char_type*
  move(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static char_type*
  copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    ((void)0);

    std::copy_n(__s2, __n, __s1);
    return __s1;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static char_type*
  assign(char_type* __s, size_t __n, char_type __a) noexcept {
    std::fill_n(__s, __n, __a);
    return __s;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type to_int_type(char_type __c) noexcept {
    return int_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type eof() noexcept { return int_type(0xFFFF); }
};

inline constexpr int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept {
  for (; __n; --__n, ++__s1, ++__s2) {
    if (lt(*__s1, *__s2))
      return -1;
    if (lt(*__s2, *__s1))
      return 1;
  }
  return 0;
}

inline constexpr size_t char_traits<char16_t>::length(const char_type* __s) noexcept {
  size_t __len = 0;
  for (; !eq(*__s, char_type(0)); ++__s)
    ++__len;
  return __len;
}

inline constexpr const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept {
  for (; __n; --__n) {
    if (eq(*__s, __a))
      return __s;
    ++__s;
  }
  return nullptr;
}

template <>
struct char_traits<char32_t> {
  using char_type = char32_t;
  using int_type = uint_least32_t;
  using off_type = streamoff;
  using pos_type = u32streampos;
  using state_type = mbstate_t;

  using comparison_category = strong_ordering;


  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
  assign(char_type& __c1, const char_type& __c2) noexcept {
    __c1 = __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool eq(char_type __c1, char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool lt(char_type __c1, char_type __c2) noexcept {
    return __c1 < __c2;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr int
  compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr size_t length(const char_type* __s) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static constexpr const char_type*
  find(const char_type* __s, size_t __n, const char_type& __a) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static char_type*
  move(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static char_type*
  copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept {
    std::copy_n(__s2, __n, __s1);
    return __s1;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static char_type*
  assign(char_type* __s, size_t __n, char_type __a) noexcept {
    std::fill_n(__s, __n, __a);
    return __s;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr char_type to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type to_int_type(char_type __c) noexcept {
    return int_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int_type eof() noexcept { return int_type(0xFFFFFFFF); }
};

inline constexpr int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept {
  for (; __n; --__n, ++__s1, ++__s2) {
    if (lt(*__s1, *__s2))
      return -1;
    if (lt(*__s2, *__s1))
      return 1;
  }
  return 0;
}

inline constexpr size_t char_traits<char32_t>::length(const char_type* __s) noexcept {
  size_t __len = 0;
  for (; !eq(*__s, char_type(0)); ++__s)
    ++__len;
  return __len;
}

inline constexpr const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept {
  for (; __n; --__n) {
    if (eq(*__s, __a))
      return __s;
    ++__s;
  }
  return nullptr;
}




template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
__str_find(const _CharT* __p, _SizeT __sz, _CharT __c, _SizeT __pos) noexcept {
  if (__pos >= __sz)
    return __npos;
  const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);
  if (__r == nullptr)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) inline constexpr const _CharT* __search_substring(
    const _CharT* __first1, const _CharT* __last1, const _CharT* __first2, const _CharT* __last2) noexcept {


  const ptrdiff_t __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __first1;

  ptrdiff_t __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;


  _CharT __f2 = *__first2;
  while (true) {
    __len1 = __last1 - __first1;

    if (__len1 < __len2)
      return __last1;


    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
    if (__first1 == nullptr)
      return __last1;






    if (_Traits::compare(__first1, __first2, __len2) == 0)
      return __first1;

    ++__first1;
  }
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
__str_find(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept {
  if (__pos > __sz)
    return __npos;

  if (__n == 0)
    return __pos;

  const _CharT* __r = std::__search_substring<_CharT, _Traits>(__p + __pos, __p + __sz, __s, __s + __n);

  if (__r == __p + __sz)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}



template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
__str_rfind(const _CharT* __p, _SizeT __sz, _CharT __c, _SizeT __pos) noexcept {
  if (__sz < 1)
    return __npos;
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT* __ps = __p + __pos; __ps != __p;) {
    if (_Traits::eq(*--__ps, __c))
      return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
__str_rfind(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept {
  __pos = std::min(__pos, __sz);
  if (__n < __sz - __pos)
    __pos += __n;
  else
    __pos = __sz;
  const _CharT* __r = std::__find_end_classic(__p, __p + __pos, __s, __s + __n, _Traits::eq);
  if (__n > 0 && __r == __p + __pos)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
__str_find_first_of(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept {
  if (__pos >= __sz || __n == 0)
    return __npos;
  const _CharT* __r = std::__find_first_of_ce(__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq);
  if (__r == __p + __sz)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
__str_find_last_of(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept {
  if (__n != 0) {
    if (__pos < __sz)
      ++__pos;
    else
      __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;) {
      const _CharT* __r = _Traits::find(__s, __n, *--__ps);
      if (__r)
        return static_cast<_SizeT>(__ps - __p);
    }
  }
  return __npos;
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
__str_find_first_not_of(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept {
  if (__pos < __sz) {
    const _CharT* __pe = __p + __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
      if (_Traits::find(__s, __n, *__ps) == nullptr)
        return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
__str_find_first_not_of(const _CharT* __p, _SizeT __sz, _CharT __c, _SizeT __pos) noexcept {
  if (__pos < __sz) {
    const _CharT* __pe = __p + __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
      if (!_Traits::eq(*__ps, __c))
        return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
__str_find_last_not_of(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept {
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT* __ps = __p + __pos; __ps != __p;)
    if (_Traits::find(__s, __n, *--__ps) == nullptr)
      return static_cast<_SizeT>(__ps - __p);
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
__str_find_last_not_of(const _CharT* __p, _SizeT __sz, _CharT __c, _SizeT __pos) noexcept {
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT* __ps = __p + __pos; __ps != __p;)
    if (!_Traits::eq(*--__ps, __c))
      return static_cast<_SizeT>(__ps - __p);
  return __npos;
}

template <class _Ptr>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t __do_string_hash(_Ptr __p, _Ptr __e) {
  typedef typename iterator_traits<_Ptr>::value_type value_type;
  return __murmur2_or_cityhash<size_t>()(__p, (__e - __p) * sizeof(value_type));
}

}}
# 601 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/extern_template_lists.h" 1 3
# 16 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__string/extern_template_lists.h" 3
# 602 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3

# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_allocator.h" 1 3
# 20 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/is_allocator.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <typename _Alloc, typename = void, typename = void>
struct __is_allocator : false_type {};

template <typename _Alloc>
struct __is_allocator<_Alloc,
                      __void_t<typename _Alloc::value_type>,
                      __void_t<decltype(std::declval<_Alloc&>().allocate(size_t(0)))> > : true_type {};

}}
# 604 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3








# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/noexcept_move_assign_container.h" 1 3
# 19 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__type_traits/noexcept_move_assign_container.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <typename _Alloc, typename _Traits = allocator_traits<_Alloc> >
struct __noexcept_move_assign_container
    : public integral_constant<bool,
                               _Traits::propagate_on_container_move_assignment::value

                                   || _Traits::is_always_equal::value



                               > {
};

}}
# 613 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3
# 622 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/climits" 1 3
# 46 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/climits" 3
# 623 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3




# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string_view" 1 3
# 213 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string_view" 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/string_view.h" 1 3
# 18 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__fwd/string_view.h" 3


 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_string_view;

typedef basic_string_view<char> string_view;

typedef basic_string_view<char8_t> u8string_view;

typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;

typedef basic_string_view<wchar_t> wstring_view;



template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(string_view)))

      __attribute__((__preferred_name__(wstring_view)))


      __attribute__((__preferred_name__(u8string_view)))

      __attribute__((__preferred_name__(u16string_view)))
      __attribute__((__preferred_name__(u32string_view)))
      basic_string_view;

}}
# 214 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string_view" 2 3
# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/bounded_iter.h" 1 3
# 24 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/bounded_iter.h" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 28 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/bounded_iter.h" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {
# 48 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/bounded_iter.h" 3
template <class _Iterator, class = __enable_if_t< __libcpp_is_contiguous_iterator<_Iterator>::value > >
struct __bounded_iter {
  using value_type = typename iterator_traits<_Iterator>::value_type;
  using difference_type = typename iterator_traits<_Iterator>::difference_type;
  using pointer = typename iterator_traits<_Iterator>::pointer;
  using reference = typename iterator_traits<_Iterator>::reference;
  using iterator_category = typename iterator_traits<_Iterator>::iterator_category;

  using iterator_concept = contiguous_iterator_tag;






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __bounded_iter() = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __bounded_iter(__bounded_iter const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __bounded_iter(__bounded_iter&&) = default;

  template <class _OtherIterator, __enable_if_t< is_convertible<_OtherIterator, _Iterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __bounded_iter(__bounded_iter<_OtherIterator> const& __other) noexcept
      : __current_(__other.__current_),
        __begin_(__other.__begin_),
        __end_(__other.__end_) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __bounded_iter& operator=(__bounded_iter const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) __bounded_iter& operator=(__bounded_iter&&) = default;

private:
# 87 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__iterator/bounded_iter.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit __bounded_iter(
      _Iterator __current, _Iterator __begin, _Iterator __end)
      : __current_(__current), __begin_(__begin), __end_(__end) {
    ((void)0);

    ((void)0);

  }

  template <class _It>
  friend constexpr __bounded_iter<_It> __make_bounded_iter(_It, _It, _It);

public:







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator*() const noexcept {
    ((void)0);

    return *__current_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer operator->() const noexcept {
    ((void)0);

    return std::__to_address(__current_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator[](difference_type __n) const noexcept {
    ((void)0);

    ((void)0);

    return __current_[__n];
  }




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __bounded_iter& operator++() noexcept {
    ((void)0);

    ++__current_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __bounded_iter operator++(int) noexcept {
    __bounded_iter __tmp(*this);
    ++*this;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __bounded_iter& operator--() noexcept {
    ((void)0);

    --__current_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __bounded_iter operator--(int) noexcept {
    __bounded_iter __tmp(*this);
    --*this;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __bounded_iter& operator+=(difference_type __n) noexcept {
    ((void)0);

    ((void)0);

    __current_ += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr friend __bounded_iter
  operator+(__bounded_iter const& __self, difference_type __n) noexcept {
    __bounded_iter __tmp(__self);
    __tmp += __n;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr friend __bounded_iter
  operator+(difference_type __n, __bounded_iter const& __self) noexcept {
    __bounded_iter __tmp(__self);
    __tmp += __n;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __bounded_iter& operator-=(difference_type __n) noexcept {
    ((void)0);

    ((void)0);

    __current_ -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr friend __bounded_iter
  operator-(__bounded_iter const& __self, difference_type __n) noexcept {
    __bounded_iter __tmp(__self);
    __tmp -= __n;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr friend difference_type
  operator-(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ - __y.__current_;
  }







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr friend bool
  operator==(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ == __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr friend bool
  operator!=(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ != __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr friend bool
  operator<(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ < __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr friend bool
  operator>(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ > __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr friend bool
  operator<=(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ <= __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr friend bool
  operator>=(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ >= __y.__current_;
  }

private:
  template <class>
  friend struct pointer_traits;
  _Iterator __current_;
  _Iterator __begin_, __end_;
};

template <class _It>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr __bounded_iter<_It> __make_bounded_iter(_It __it, _It __begin, _It __end) {
  return __bounded_iter<_It>(std::move(__it), std::move(__begin), std::move(__end));
}






template <class _Iterator>
struct pointer_traits<__bounded_iter<_Iterator> > {
  using pointer = __bounded_iter<_Iterator>;
  using element_type = typename pointer_traits<_Iterator>::element_type;
  using difference_type = typename pointer_traits<_Iterator>::difference_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr static element_type* to_address(pointer __it) noexcept {
    return std::__to_address(__it.__current_);
  }
};

}}
# 215 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string_view" 2 3
# 254 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string_view" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 258 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string_view" 2 3

 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr inline size_t
__char_traits_length_checked(const typename _Traits::char_type* __s) noexcept {

  return ((void)0),

         _Traits::length(__s);
}

template <class _CharT, class _Traits>
class basic_string_view {
public:

  using traits_type = _Traits;
  using value_type = _CharT;
  using pointer = _CharT*;
  using const_pointer = const _CharT*;
  using reference = _CharT&;
  using const_reference = const _CharT&;





  using const_iterator = const_pointer;

  using iterator = const_iterator;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
  using reverse_iterator = const_reverse_iterator;
  using size_type = size_t;
  using difference_type = ptrdiff_t;
  static constexpr const size_type npos = -1;

  static_assert((!is_array<value_type>::value), "Character type of basic_string_view must not be an array");
  static_assert((is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout");
  static_assert((is_trivial<value_type>::value), "Character type of basic_string_view must be trivial");
  static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                "traits_type::char_type must be the same type as CharT");


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) basic_string_view() noexcept : __data_(nullptr), __size_(0) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) basic_string_view(const basic_string_view&) noexcept = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) basic_string_view& operator=(const basic_string_view&) noexcept = default;

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) basic_string_view(const _CharT* __s, size_type __len) noexcept
      : __data_(__s),
        __size_(__len) {




    ((void)0);


    ((void)0);


  }


  template <contiguous_iterator _It, sized_sentinel_for<_It> _End>
    requires(is_same_v<iter_value_t<_It>, _CharT> && !is_convertible_v<_End, size_type>)
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) basic_string_view(_It __begin, _End __end)
      : __data_(std::to_address(__begin)), __size_(__end - __begin) {
    ((void)0);

  }



  template <class _Range>
    requires(!is_same_v<remove_cvref_t<_Range>, basic_string_view> && ranges::contiguous_range<_Range> &&
             ranges::sized_range<_Range> && is_same_v<ranges::range_value_t<_Range>, _CharT> &&
             !is_convertible_v<_Range, const _CharT*> &&
             (!requires(remove_cvref_t<_Range>& __d) { __d.operator std::basic_string_view<_CharT, _Traits>(); }))
  constexpr explicit __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) basic_string_view(_Range&& __r)
      : __data_(ranges::data(__r)), __size_(ranges::size(__r)) {}


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) basic_string_view(const _CharT* __s)
      : __data_(__s), __size_(std::__char_traits_length_checked<_Traits>(__s)) {}


  basic_string_view(nullptr_t) = delete;



  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_iterator begin() const noexcept { return cbegin(); }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_iterator end() const noexcept { return cend(); }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_iterator cbegin() const noexcept {



    return const_iterator(__data_);

  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_iterator cend() const noexcept {



    return const_iterator(__data_ + __size_);

  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(cend());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(cbegin());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(cend());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(cbegin());
  }


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type size() const noexcept { return __size_; }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type length() const noexcept { return __size_; }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type max_size() const noexcept {
    return numeric_limits<size_type>::max() / sizeof(value_type);
  }

  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty() const noexcept {
    return __size_ == 0;
  }


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_reference operator[](size_type __pos) const noexcept {
    return ((void)0), __data_[__pos];
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_reference at(size_type __pos) const {
    return __pos >= size() ? (__throw_out_of_range("string_view::at"), __data_[0]) : __data_[__pos];
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_reference front() const noexcept {
    return ((void)0), __data_[0];
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_reference back() const noexcept {
    return ((void)0), __data_[__size_ - 1];
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) const_pointer data() const noexcept { return __data_; }


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void remove_prefix(size_type __n) noexcept {
    ((void)0);
    __data_ += __n;
    __size_ -= __n;
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void remove_suffix(size_type __n) noexcept {
    ((void)0);
    __size_ -= __n;
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void swap(basic_string_view& __other) noexcept {
    const value_type* __p = __data_;
    __data_ = __other.__data_;
    __other.__data_ = __p;

    size_type __sz = __size_;
    __size_ = __other.__size_;
    __other.__size_ = __sz;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  copy(_CharT* __s, size_type __n, size_type __pos = 0) const {
    if (__pos > size())
      __throw_out_of_range("string_view::copy");
    size_type __rlen = std::min(__n, size() - __pos);
    _Traits::copy(__s, data() + __pos, __rlen);
    return __rlen;
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) basic_string_view substr(size_type __pos = 0, size_type __n = npos) const {
    return __pos > size() ? (__throw_out_of_range("string_view::substr"), basic_string_view())
                          : basic_string_view(data() + __pos, std::min(__n, size() - __pos));
  }

  constexpr int compare(basic_string_view __sv) const noexcept {
    size_type __rlen = std::min(size(), __sv.size());
    int __retval = _Traits::compare(data(), __sv.data(), __rlen);
    if (__retval == 0)
      __retval = size() == __sv.size() ? 0 : (size() < __sv.size() ? -1 : 1);
    return __retval;
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) int
  compare(size_type __pos1, size_type __n1, basic_string_view __sv) const {
    return substr(__pos1, __n1).compare(__sv);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) int
  compare(size_type __pos1, size_type __n1, basic_string_view __sv, size_type __pos2, size_type __n2) const {
    return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) int compare(const _CharT* __s) const noexcept {
    return compare(basic_string_view(__s));
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) int
  compare(size_type __pos1, size_type __n1, const _CharT* __s) const {
    return substr(__pos1, __n1).compare(basic_string_view(__s));
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) int
  compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const {
    return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
  }


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find(basic_string_view __s, size_type __pos = 0) const noexcept {
    ((void)0);
    return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type find(_CharT __c, size_type __pos = 0) const noexcept {
    return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find(const _CharT* __s, size_type __pos, size_type __n) const noexcept {
    ((void)0);
    return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find(const _CharT* __s, size_type __pos = 0) const noexcept {
    ((void)0);
    return std::__str_find<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  rfind(basic_string_view __s, size_type __pos = npos) const noexcept {
    ((void)0);
    return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  rfind(_CharT __c, size_type __pos = npos) const noexcept {
    return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  rfind(const _CharT* __s, size_type __pos, size_type __n) const noexcept {
    ((void)0);
    return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  rfind(const _CharT* __s, size_type __pos = npos) const noexcept {
    ((void)0);
    return std::__str_rfind<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_first_of(basic_string_view __s, size_type __pos = 0) const noexcept {
    ((void)0);
    return std::__str_find_first_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_first_of(_CharT __c, size_type __pos = 0) const noexcept {
    return find(__c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_first_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept {
    ((void)0);
    return std::__str_find_first_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_first_of(const _CharT* __s, size_type __pos = 0) const noexcept {
    ((void)0);
    return std::__str_find_first_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_last_of(basic_string_view __s, size_type __pos = npos) const noexcept {
    ((void)0);
    return std::__str_find_last_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_last_of(_CharT __c, size_type __pos = npos) const noexcept {
    return rfind(__c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_last_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept {
    ((void)0);
    return std::__str_find_last_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_last_of(const _CharT* __s, size_type __pos = npos) const noexcept {
    ((void)0);
    return std::__str_find_last_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_first_not_of(basic_string_view __s, size_type __pos = 0) const noexcept {
    ((void)0);

    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept {
    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept {
    ((void)0);
    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_first_not_of(const _CharT* __s, size_type __pos = 0) const noexcept {
    ((void)0);
    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_last_not_of(basic_string_view __s, size_type __pos = npos) const noexcept {
    ((void)0);

    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept {
    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept {
    ((void)0);
    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_type
  find_last_not_of(const _CharT* __s, size_type __pos = npos) const noexcept {
    ((void)0);
    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool starts_with(basic_string_view __s) const noexcept {
    return size() >= __s.size() && compare(0, __s.size(), __s) == 0;
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool starts_with(value_type __c) const noexcept {
    return !empty() && _Traits::eq(front(), __c);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool starts_with(const value_type* __s) const noexcept {
    return starts_with(basic_string_view(__s));
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool ends_with(basic_string_view __s) const noexcept {
    return size() >= __s.size() && compare(size() - __s.size(), npos, __s) == 0;
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool ends_with(value_type __c) const noexcept {
    return !empty() && _Traits::eq(back(), __c);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool ends_with(const value_type* __s) const noexcept {
    return ends_with(basic_string_view(__s));
  }



  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool contains(basic_string_view __sv) const noexcept { return find(__sv) != npos; }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool contains(value_type __c) const noexcept { return find(__c) != npos; }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool contains(const value_type* __s) const { return find(__s) != npos; }


private:
  const value_type* __data_;
  size_type __size_;
};
template <class... _Tag> [[maybe_unused]] basic_string_view(typename _Tag::__allow_ctad...)->basic_string_view<_Tag...>;


template <class _CharT, class _Traits>
inline constexpr bool ranges::enable_view<basic_string_view<_CharT, _Traits>> = true;

template <class _CharT, class _Traits>
inline constexpr bool ranges::enable_borrowed_range<basic_string_view<_CharT, _Traits> > = true;





template <contiguous_iterator _It, sized_sentinel_for<_It> _End>
basic_string_view(_It, _End) -> basic_string_view<iter_value_t<_It>>;



template <ranges::contiguous_range _Range>
basic_string_view(_Range) -> basic_string_view<ranges::range_value_t<_Range>>;






template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool operator==(basic_string_view<_CharT, _Traits> __lhs,
                                                type_identity_t<basic_string_view<_CharT, _Traits>> __rhs) noexcept {
  if (__lhs.size() != __rhs.size())
    return false;
  return __lhs.compare(__rhs) == 0;
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator<=>(basic_string_view<_CharT, _Traits> __lhs,
                                                 type_identity_t<basic_string_view<_CharT, _Traits>> __rhs) noexcept {
  if constexpr (requires { typename _Traits::comparison_category; }) {

    static_assert(
        __comparison_category<typename _Traits::comparison_category>, "return type is not a comparison category type");
    return static_cast<typename _Traits::comparison_category>(__lhs.compare(__rhs) <=> 0);
  } else {
    return static_cast<weak_ordering>(__lhs.compare(__rhs) <=> 0);
  }
}
# 873 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string_view" 3
template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, basic_string_view<_CharT, _Traits> __str);


template <class _CharT>
struct __string_view_hash : public __unary_function<basic_string_view<_CharT, char_traits<_CharT> >, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) size_t operator()(const basic_string_view<_CharT, char_traits<_CharT> > __val) const noexcept {
    return std::__do_string_hash(__val.data(), __val.data() + __val.size());
  }
};

template <>
struct hash<basic_string_view<char, char_traits<char> > > : __string_view_hash<char> {};


template <>
struct hash<basic_string_view<char8_t, char_traits<char8_t> > > : __string_view_hash<char8_t> {};


template <>
struct hash<basic_string_view<char16_t, char_traits<char16_t> > > : __string_view_hash<char16_t> {};

template <>
struct hash<basic_string_view<char32_t, char_traits<char32_t> > > : __string_view_hash<char32_t> {};


template <>
struct hash<basic_string_view<wchar_t, char_traits<wchar_t> > > : __string_view_hash<wchar_t> {};



inline namespace literals {
inline namespace string_view_literals {
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string_view<char>
operator""sv(const char* __str, size_t __len) noexcept {
  return basic_string_view<char>(__str, __len);
}


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string_view<wchar_t>
operator""sv(const wchar_t* __str, size_t __len) noexcept {
  return basic_string_view<wchar_t>(__str, __len);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string_view<char8_t>
operator""sv(const char8_t* __str, size_t __len) noexcept {
  return basic_string_view<char8_t>(__str, __len);
}


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string_view<char16_t>
operator""sv(const char16_t* __str, size_t __len) noexcept {
  return basic_string_view<char16_t>(__str, __len);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string_view<char32_t>
operator""sv(const char32_t* __str, size_t __len) noexcept {
  return basic_string_view<char32_t>(__str, __len);
}
}
}

}}
# 628 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3
# 649 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3



# 1 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/__undef_macros" 1 3
# 653 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 2 3
# 666 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __ndk1 {



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const basic_string<_CharT, _Traits, _Allocator>& __y);

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT, _Traits, _Allocator>& __y);

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT, _Traits, _Allocator>& __y);

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

extern template __attribute__((__visibility__("default"))) string operator+
    <char, char_traits<char>, allocator<char> >(char const*, string const&);

template <class _Iter>
struct __string_is_trivial_iterator : public false_type {};

template <class _Tp>
struct __string_is_trivial_iterator<_Tp*> : public is_arithmetic<_Tp> {};

template <class _Iter>
struct __string_is_trivial_iterator<__wrap_iter<_Iter> > : public __string_is_trivial_iterator<_Iter> {};

template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view
    : public _BoolConstant< is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&
                            !is_convertible<const _Tp&, const _CharT*>::value > {};

struct __uninitialized_size_tag {};
struct __init_with_sentinel_tag {};

template <class _CharT, class _Traits, class _Allocator>
class basic_string {
private:
  using __default_allocator_type = allocator<_CharT>;

public:
  typedef basic_string __self;
  typedef basic_string_view<_CharT, _Traits> __self_view;
  typedef _Traits traits_type;
  typedef _CharT value_type;
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
# 738 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
  using __trivially_relocatable = __conditional_t<
      __libcpp_is_trivially_relocatable<allocator_type>::value && __libcpp_is_trivially_relocatable<pointer>::value,
      basic_string,
      void>;

  static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
  static_assert((is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
  static_assert((is_trivial<value_type>::value), "Character type of basic_string must be trivial");
  static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                "traits_type::char_type must be the same type as CharT");
  static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                "Allocator::value_type must be same type as value_type");

  static_assert(is_same<allocator_type, __rebind_alloc<__alloc_traits, value_type> >::value,
                "[allocator.requirements] states that rebinding an allocator to the same type should result in the "
                "original allocator");


  typedef __wrap_iter<pointer> iterator;
  typedef __wrap_iter<const_pointer> const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

private:
  static_assert(8 == 8, "This implementation assumes that one byte contains 8 bits");
# 806 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
  static const size_type __endian_factor = 2;






  struct __long {
    struct __attribute__((__packed__)) {
      size_type __is_long_ : 1;
      size_type __cap_ : sizeof(size_type) * 8 - 1;
    };
    size_type __size_;
    pointer __data_;
  };

  enum { __min_cap = (sizeof(__long) - 1) / sizeof(value_type) > 2 ? (sizeof(__long) - 1) / sizeof(value_type) : 2 };

  struct __short {
    struct __attribute__((__packed__)) {
      unsigned char __is_long_ : 1;
      unsigned char __size_ : 7;
    };
    char __padding_[sizeof(value_type) - 1];
    value_type __data_[__min_cap];
  };



  static_assert(sizeof(__short) == (sizeof(value_type) * (__min_cap + 1)), "__short has an unexpected size.");

  union __ulx {
    __long __lx;
    __short __lxx;
  };

  enum { __n_words = sizeof(__ulx) / sizeof(size_type) };

  struct __raw {
    size_type __words[__n_words];
  };

  struct __rep {
    union {
      __short __s;
      __long __l;
      __raw __r;
    };
  };

  __compressed_pair<__rep, allocator_type> __r_;




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit basic_string(
      __uninitialized_size_tag, size_type __size, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    if (__size > max_size())
      __throw_length_error();
    if (__fits_in_sso(__size)) {
      __r_.first() = __rep();
      __set_short_size(__size);
    } else {
      auto __capacity = __recommend(__size) + 1;
      auto __allocation = __alloc_traits::allocate(__alloc(), __capacity);
      __begin_lifetime(__allocation, __capacity);
      __set_long_cap(__capacity);
      __set_long_pointer(__allocation);
      __set_long_size(__size);
    }
    __annotate_new(__size);
  }

  template <class _Iter, class _Sent>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  basic_string(__init_with_sentinel_tag, _Iter __first, _Sent __last, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    __init_with_sentinel(std::move(__first), std::move(__last));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator __make_iterator(pointer __p) { return iterator(__p); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator __make_const_iterator(const_pointer __p) const {
    return const_iterator(__p);
  }

public:
  __attribute__((__visibility__("default"))) static const size_type npos = -1;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string()
      noexcept(is_nothrow_default_constructible<allocator_type>::value)
      : __r_(__value_init_tag(), __default_init_tag()) {
    __annotate_new(0);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr explicit basic_string(const allocator_type& __a)



      noexcept

      : __r_(__value_init_tag(), __a) {
    __annotate_new(0);
  }

  constexpr basic_string(const basic_string& __str)
      : __r_(__default_init_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc())) {
    if (!__str.__is_long()) {
      __r_.first() = __str.__r_.first();
      __annotate_new(__get_short_size());
    } else
      __init_copy_ctor_external(std::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
  }

  constexpr
  basic_string(const basic_string& __str, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    if (!__str.__is_long()) {
      __r_.first() = __str.__r_.first();
      __annotate_new(__get_short_size());
    } else
      __init_copy_ctor_external(std::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(basic_string&& __str)



      noexcept




      : __r_([](basic_string& __s) -> decltype(__s.__r_)&& {
          if (!__s.__is_long())
            __s.__annotate_delete();
          return std::move(__s.__r_);
        }(__str)) {
    __str.__r_.first() = __rep();
    __str.__annotate_new(0);
    if (!__is_long())
      __annotate_new(size());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(basic_string&& __str, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    if (__str.__is_long() && __a != __str.__alloc())
      __init(std::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
    else {
      if (__libcpp_is_constant_evaluated())
        __r_.first() = __rep();
      if (!__str.__is_long())
        __str.__annotate_delete();
      __r_.first() = __str.__r_.first();
      __str.__r_.first() = __rep();
      __str.__annotate_new(0);
      if (!__is_long() && this != &__str)
        __annotate_new(size());
    }
  }


  template <__enable_if_t<__is_allocator<_Allocator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(const _CharT* __s)
      : __r_(__default_init_tag(), __default_init_tag()) {
    ((void)0);
    __init(__s, traits_type::length(__s));
  }

  template <__enable_if_t<__is_allocator<_Allocator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(const _CharT* __s, const _Allocator& __a)
      : __r_(__default_init_tag(), __a) {
    ((void)0);
    __init(__s, traits_type::length(__s));
  }


  basic_string(nullptr_t) = delete;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(const _CharT* __s, size_type __n)
      : __r_(__default_init_tag(), __default_init_tag()) {
    ((void)0);
    __init(__s, __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)
      : __r_(__default_init_tag(), __a) {
    ((void)0);
    __init(__s, __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(size_type __n, _CharT __c)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __init(__n, __c);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(
      basic_string&& __str, size_type __pos, const _Allocator& __alloc = _Allocator())
      : basic_string(std::move(__str), __pos, npos, __alloc) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(
      basic_string&& __str, size_type __pos, size_type __n, const _Allocator& __alloc = _Allocator())
      : __r_(__default_init_tag(), __alloc) {
    if (__pos > __str.size())
      __throw_out_of_range();

    auto __len = std::min<size_type>(__n, __str.size() - __pos);
    if (__alloc_traits::is_always_equal::value || __alloc == __str.__alloc()) {
      __move_assign(std::move(__str), __pos, __len);
    } else {

      __init(__str.data() + __pos, __len);
    }
  }


  template <__enable_if_t<__is_allocator<_Allocator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(size_type __n, _CharT __c, const _Allocator& __a)
      : __r_(__default_init_tag(), __a) {
    __init(__n, __c);
  }

  constexpr
  basic_string(const basic_string& __str, size_type __pos, size_type __n, const _Allocator& __a = _Allocator())
      : __r_(__default_init_tag(), __a) {
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
      __throw_out_of_range();
    __init(__str.data() + __pos, std::min(__n, __str_sz - __pos));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  basic_string(const basic_string& __str, size_type __pos, const _Allocator& __a = _Allocator())
      : __r_(__default_init_tag(), __a) {
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
      __throw_out_of_range();
    __init(__str.data() + __pos, __str_sz - __pos);
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr
  basic_string(const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a = allocator_type())
      : __r_(__default_init_tag(), __a) {
    __self_view __sv0 = __t;
    __self_view __sv = __sv0.substr(__pos, __n);
    __init(__sv.data(), __sv.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr explicit basic_string(const _Tp& __t)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr explicit basic_string(
      const _Tp& __t, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());
  }

  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(_InputIterator __first, _InputIterator __last)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __init(__first, __last);
  }

  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr
  basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    __init(__first, __last);
  }


  template <_ContainerCompatibleRange<_CharT> _Range>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(
      from_range_t, _Range&& __range, const allocator_type& __a = allocator_type())
      : __r_(__default_init_tag(), __a) {
    if constexpr (ranges::forward_range<_Range> || ranges::sized_range<_Range>) {
      __init_with_size(ranges::begin(__range), ranges::end(__range), ranges::distance(__range));
    } else {
      __init_with_sentinel(ranges::begin(__range), ranges::end(__range));
    }
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(initializer_list<_CharT> __il)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __init(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string(initializer_list<_CharT> __il, const _Allocator& __a)
      : __r_(__default_init_tag(), __a) {
    __init(__il.begin(), __il.end());
  }


  inline constexpr ~basic_string() {
    __annotate_delete();
    if (__is_long())
      __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr operator __self_view() const noexcept {
    return __self_view(data(), size());
  }

  constexpr basic_string&
  operator=(const basic_string& __str);

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  constexpr basic_string& operator=(const _Tp& __t) {
    __self_view __sv = __t;
    return assign(__sv);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& operator=(basic_string&& __str)
      noexcept(__noexcept_move_assign_container<_Allocator, __alloc_traits>::value) {
    __move_assign(__str, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& operator=(initializer_list<value_type> __il) {
    return assign(__il.begin(), __il.size());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& operator=(const value_type* __s) {
    return assign(__s);
  }

  basic_string& operator=(nullptr_t) = delete;

  constexpr basic_string& operator=(value_type __c);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator begin() noexcept {
    return __make_iterator(__get_pointer());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator begin() const noexcept {
    return __make_const_iterator(__get_pointer());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator end() noexcept {
    return __make_iterator(__get_pointer() + size());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator end() const noexcept {
    return __make_const_iterator(__get_pointer() + size());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reverse_iterator crend() const noexcept { return rend(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type size() const noexcept {
    return __is_long() ? __get_long_size() : __get_short_size();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type length() const noexcept { return size(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type max_size() const noexcept {
    size_type __m = __alloc_traits::max_size(__alloc());
    if (__m <= std::numeric_limits<size_type>::max() / 2) {
      return __m - __alignment;
    } else {
      bool __uses_lsb = __endian_factor == 2;
      return __uses_lsb ? __m - __alignment : (__m / 2) - __alignment;
    }
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type capacity() const noexcept {
    return (__is_long() ? __get_long_cap() : static_cast<size_type>(__min_cap)) - 1;
  }

  constexpr void resize(size_type __n, value_type __c);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void resize(size_type __n) { resize(__n, value_type()); }

  constexpr void reserve(size_type __requested_capacity);


  template <class _Op>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void resize_and_overwrite(size_type __n, _Op __op) {
    __resize_default_init(__n);
    __erase_to_end(std::move(__op)(data(), static_cast<::std::__decay_t<decltype((__n))> >(__n)));
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __resize_default_init(size_type __n);


  __attribute__((__deprecated__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void reserve() noexcept { shrink_to_fit(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void shrink_to_fit() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void clear() noexcept;

  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool empty() const noexcept {
    return size() == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference operator[](size_type __pos) const noexcept {
    ((void)0);
    if (__builtin_constant_p(__pos) && !__fits_in_sso(__pos)) {
      return *(__get_long_pointer() + __pos);
    }
    return *(data() + __pos);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference operator[](size_type __pos) noexcept {
    ((void)0);
    if (__builtin_constant_p(__pos) && !__fits_in_sso(__pos)) {
      return *(__get_long_pointer() + __pos);
    }
    return *(__get_pointer() + __pos);
  }

  constexpr const_reference at(size_type __n) const;
  constexpr reference at(size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& operator+=(const basic_string& __str) {
    return append(__str);
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string >::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  operator+=(const _Tp& __t) {
    __self_view __sv = __t;
    return append(__sv);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& operator+=(const value_type* __s) {
    return append(__s);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& operator+=(value_type __c) {
    push_back(__c);
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& operator+=(initializer_list<value_type> __il) {
    return append(__il);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& append(const basic_string& __str) {
    return append(__str.data(), __str.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  append(const _Tp& __t) {
    __self_view __sv = __t;
    return append(__sv.data(), __sv.size());
  }

  constexpr basic_string& append(const basic_string& __str, size_type __pos, size_type __n = npos);

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr

      basic_string&
      append(const _Tp& __t, size_type __pos, size_type __n = npos);

  constexpr basic_string& append(const value_type* __s, size_type __n);
  constexpr basic_string& append(const value_type* __s);
  constexpr basic_string& append(size_type __n, value_type __c);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __append_default_init(size_type __n);

  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string&
  append(_InputIterator __first, _InputIterator __last) {
    const basic_string __temp(__first, __last, __alloc());
    append(__temp.data(), __temp.size());
    return *this;
  }

  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string&
  append(_ForwardIterator __first, _ForwardIterator __last);


  template <_ContainerCompatibleRange<_CharT> _Range>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& append_range(_Range&& __range) {
    insert_range(end(), std::forward<_Range>(__range));
    return *this;
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& append(initializer_list<value_type> __il) {
    return append(__il.begin(), __il.size());
  }


  constexpr void push_back(value_type __c);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void pop_back();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference front() noexcept {
    ((void)0);
    return *__get_pointer();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference front() const noexcept {
    ((void)0);
    return *data();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr reference back() noexcept {
    ((void)0);
    return *(__get_pointer() + size() - 1);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_reference back() const noexcept {
    ((void)0);
    return *(data() + size() - 1);
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  assign(const _Tp& __t) {
    __self_view __sv = __t;
    return assign(__sv.data(), __sv.size());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __move_assign(basic_string&& __str, size_type __pos, size_type __len) {

    ((void)0);
    size_type __old_sz = __str.size();
    if (!__str.__is_long())
      __str.__annotate_delete();
    __r_.first() = __str.__r_.first();
    __str.__r_.first() = __rep();
    __str.__annotate_new(0);

    _Traits::move(data(), data() + __pos, __len);
    __set_size(__len);
    _Traits::assign(data()[__len], value_type());

    if (!__is_long()) {
      __annotate_new(__len);
    } else if (__old_sz > __len) {
      __annotate_shrink(__old_sz);
    }
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& assign(const basic_string& __str) {
    return *this = __str;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& assign(basic_string&& __str)
      noexcept(__noexcept_move_assign_container<_Allocator, __alloc_traits>::value) {
    *this = std::move(__str);
    return *this;
  }

  constexpr basic_string& assign(const basic_string& __str, size_type __pos, size_type __n = npos);

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  assign(const _Tp& __t, size_type __pos, size_type __n = npos);

  constexpr basic_string& assign(const value_type* __s, size_type __n);
  constexpr basic_string& assign(const value_type* __s);
  constexpr basic_string& assign(size_type __n, value_type __c);
  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  assign(_InputIterator __first, _InputIterator __last);

  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  assign(_ForwardIterator __first, _ForwardIterator __last);


  template <_ContainerCompatibleRange<_CharT> _Range>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& assign_range(_Range&& __range) {
    if constexpr (__string_is_trivial_iterator<ranges::iterator_t<_Range>>::value &&
                  (ranges::forward_range<_Range> || ranges::sized_range<_Range>)) {
      size_type __n = static_cast<size_type>(ranges::distance(__range));
      __assign_trivial(ranges::begin(__range), ranges::end(__range), __n);

    } else {
      __assign_with_sentinel(ranges::begin(__range), ranges::end(__range));
    }

    return *this;
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string& assign(initializer_list<value_type> __il) {
    return assign(__il.begin(), __il.size());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string&
  insert(size_type __pos1, const basic_string& __str) {
    return insert(__pos1, __str.data(), __str.size());
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  insert(size_type __pos1, const _Tp& __t) {
    __self_view __sv = __t;
    return insert(__pos1, __sv.data(), __sv.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n = npos);

  constexpr basic_string&
  insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n = npos);
  constexpr basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
  constexpr basic_string& insert(size_type __pos, const value_type* __s);
  constexpr basic_string& insert(size_type __pos, size_type __n, value_type __c);
  constexpr iterator insert(const_iterator __pos, value_type __c);


  template <_ContainerCompatibleRange<_CharT> _Range>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator insert_range(const_iterator __position, _Range&& __range) {
    if constexpr (ranges::forward_range<_Range> || ranges::sized_range<_Range>) {
      auto __n = static_cast<size_type>(ranges::distance(__range));
      return __insert_with_size(__position, ranges::begin(__range), ranges::end(__range), __n);

    } else {
      basic_string __temp(from_range, std::forward<_Range>(__range), __alloc());
      return insert(__position, __temp.data(), __temp.data() + __temp.size());
    }
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator
  insert(const_iterator __pos, size_type __n, value_type __c) {
    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
  }

  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr iterator
  insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);

  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr iterator
  insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator
  insert(const_iterator __pos, initializer_list<value_type> __il) {
    return insert(__pos, __il.begin(), __il.end());
  }


  constexpr basic_string& erase(size_type __pos = 0, size_type __n = npos);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator erase(const_iterator __pos);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator erase(const_iterator __first, const_iterator __last);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string&
  replace(size_type __pos1, size_type __n1, const basic_string& __str) {
    return replace(__pos1, __n1, __str.data(), __str.size());
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  replace(size_type __pos1, size_type __n1, const _Tp& __t) {
    __self_view __sv = __t;
    return replace(__pos1, __n1, __sv.data(), __sv.size());
  }

  constexpr basic_string&
  replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2 = npos);

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2 = npos);

  constexpr basic_string&
  replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
  constexpr basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
  constexpr basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, const basic_string& __str) {
    return replace(
        static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __str.data(), __str.size());
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, const _Tp& __t) {
    __self_view __sv = __t;
    return replace(__i1 - begin(), __i2 - __i1, __sv);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n) {
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, const value_type* __s) {
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c) {
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
  }

  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);


  template <_ContainerCompatibleRange<_CharT> _Range>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string&
  replace_with_range(const_iterator __i1, const_iterator __i2, _Range&& __range) {
    basic_string __temp(from_range, std::forward<_Range>(__range), __alloc());
    return replace(__i1, __i2, __temp);
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string&
  replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il) {
    return replace(__i1, __i2, __il.begin(), __il.end());
  }


  constexpr size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string substr(size_type __pos = 0, size_type __n = npos) const& {
    return basic_string(*this, __pos, __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string substr(size_type __pos = 0, size_type __n = npos) && {
    return basic_string(std::move(*this), __pos, __n);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void swap(basic_string& __str)

      noexcept;




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const value_type* c_str() const noexcept { return data(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const value_type* data() const noexcept {
    return std::__to_address(__get_pointer());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr value_type* data() noexcept {
    return std::__to_address(__get_pointer());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr allocator_type get_allocator() const noexcept {
    return __alloc();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find(const basic_string& __str, size_type __pos = 0) const noexcept;

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr size_type
  find(const _Tp& __t, size_type __pos = 0) const noexcept;

  constexpr size_type find(const value_type* __s, size_type __pos, size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find(const value_type* __s, size_type __pos = 0) const noexcept;
  constexpr size_type find(value_type __c, size_type __pos = 0) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  rfind(const basic_string& __str, size_type __pos = npos) const noexcept;

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr size_type
  rfind(const _Tp& __t, size_type __pos = npos) const noexcept;

  constexpr size_type rfind(const value_type* __s, size_type __pos, size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  rfind(const value_type* __s, size_type __pos = npos) const noexcept;
  constexpr size_type rfind(value_type __c, size_type __pos = npos) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_first_of(const basic_string& __str, size_type __pos = 0) const noexcept;

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr size_type
  find_first_of(const _Tp& __t, size_type __pos = 0) const noexcept;

  constexpr size_type
  find_first_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_first_of(const value_type* __s, size_type __pos = 0) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_first_of(value_type __c, size_type __pos = 0) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_last_of(const basic_string& __str, size_type __pos = npos) const noexcept;

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr size_type
  find_last_of(const _Tp& __t, size_type __pos = npos) const noexcept;

  constexpr size_type
  find_last_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_last_of(const value_type* __s, size_type __pos = npos) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_last_of(value_type __c, size_type __pos = npos) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_first_not_of(const basic_string& __str, size_type __pos = 0) const noexcept;

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr size_type
  find_first_not_of(const _Tp& __t, size_type __pos = 0) const noexcept;

  constexpr size_type
  find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_first_not_of(const value_type* __s, size_type __pos = 0) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_first_not_of(value_type __c, size_type __pos = 0) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_last_not_of(const basic_string& __str, size_type __pos = npos) const noexcept;

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr size_type
  find_last_not_of(const _Tp& __t, size_type __pos = npos) const noexcept;

  constexpr size_type
  find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_last_not_of(const value_type* __s, size_type __pos = npos) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  find_last_not_of(value_type __c, size_type __pos = npos) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int compare(const basic_string& __str) const noexcept;

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr int
  compare(const _Tp& __t) const noexcept;

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) constexpr int
  compare(size_type __pos1, size_type __n1, const _Tp& __t) const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int
  compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
  constexpr int
  compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2 = npos) const;

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr int
  compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2 = npos) const;

  constexpr int compare(const value_type* __s) const noexcept;
  constexpr int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
  constexpr int
  compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;


  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool starts_with(__self_view __sv) const noexcept {
    return __self_view(data(), size()).starts_with(__sv);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool starts_with(value_type __c) const noexcept {
    return !empty() && _Traits::eq(front(), __c);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool starts_with(const value_type* __s) const noexcept {
    return starts_with(__self_view(__s));
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool ends_with(__self_view __sv) const noexcept {
    return __self_view(data(), size()).ends_with(__sv);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool ends_with(value_type __c) const noexcept {
    return !empty() && _Traits::eq(back(), __c);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool ends_with(const value_type* __s) const noexcept {
    return ends_with(__self_view(__s));
  }



  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool contains(__self_view __sv) const noexcept {
    return __self_view(data(), size()).contains(__sv);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool contains(value_type __c) const noexcept {
    return __self_view(data(), size()).contains(__c);
  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool contains(const value_type* __s) const {
    return __self_view(data(), size()).contains(__s);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __invariants() const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __clear_and_shrink() noexcept;

private:
  template <class _Alloc>
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool friend
  operator==(const basic_string<char, char_traits<char>, _Alloc>& __lhs,
             const basic_string<char, char_traits<char>, _Alloc>& __rhs) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __shrink_or_extend(size_type __target_capacity);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool
  __is_long() const noexcept {
    if (__libcpp_is_constant_evaluated() && __builtin_constant_p(__r_.first().__l.__is_long_)) {
      return __r_.first().__l.__is_long_;
    }
    return __r_.first().__s.__is_long_;
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __begin_lifetime(pointer __begin, size_type __n) {

    if (__libcpp_is_constant_evaluated()) {
      for (size_type __i = 0; __i != __n; ++__i)
        std::construct_at(std::addressof(__begin[__i]));
    }




  }

  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) static bool __fits_in_sso(size_type __sz) { return __sz < __min_cap; }

  template <class _Iterator, class _Sentinel>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void
  __assign_trivial(_Iterator __first, _Sentinel __last, size_type __n);

  template <class _Iterator, class _Sentinel>
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __assign_with_sentinel(_Iterator __first, _Sentinel __last);

  template <class _ForwardIterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr iterator
  __insert_from_safe_copy(size_type __n, size_type __ip, _ForwardIterator __first, _Sentinel __last) {
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz >= __n) {
      __annotate_increase(__n);
      __p = std::__to_address(__get_pointer());
      size_type __n_move = __sz - __ip;
      if (__n_move != 0)
        traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
    } else {
      __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
      __p = std::__to_address(__get_long_pointer());
    }
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
    for (__p += __ip; __first != __last; ++__p, ++__first)
      traits_type::assign(*__p, *__first);

    return begin() + __ip;
  }

  template <class _Iterator, class _Sentinel>
  constexpr iterator
  __insert_with_size(const_iterator __pos, _Iterator __first, _Sentinel __last, size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr allocator_type& __alloc() noexcept { return __r_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const allocator_type& __alloc() const noexcept { return __r_.second(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
  __set_short_size(size_type __s) noexcept {
    ((void)0);
    __r_.first().__s.__size_ = __s;
    __r_.first().__s.__is_long_ = false;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type
  __get_short_size() const noexcept {
    ((void)0);
    return __r_.first().__s.__size_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __set_long_size(size_type __s) noexcept {
    __r_.first().__l.__size_ = __s;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type __get_long_size() const noexcept {
    return __r_.first().__l.__size_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __set_size(size_type __s) noexcept {
    if (__is_long())
      __set_long_size(__s);
    else
      __set_short_size(__s);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __set_long_cap(size_type __s) noexcept {
    __r_.first().__l.__cap_ = __s / __endian_factor;
    __r_.first().__l.__is_long_ = true;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type __get_long_cap() const noexcept {
    return __r_.first().__l.__cap_ * __endian_factor;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __set_long_pointer(pointer __p) noexcept {
    __r_.first().__l.__data_ = __p;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer __get_long_pointer() noexcept {
    return __r_.first().__l.__data_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_pointer __get_long_pointer() const noexcept {
    return __r_.first().__l.__data_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer __get_short_pointer() noexcept {
    return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_pointer __get_short_pointer() const noexcept {
    return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr pointer __get_pointer() noexcept {
    return __is_long() ? __get_long_pointer() : __get_short_pointer();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr const_pointer __get_pointer() const noexcept {
    return __is_long() ? __get_long_pointer() : __get_short_pointer();
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
  __annotate_contiguous_container(const void* __old_mid, const void* __new_mid) const {
    (void)__old_mid;
    (void)__new_mid;






  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __asan_short_string_is_annotated() const noexcept {
    return false && !__libcpp_is_constant_evaluated();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __annotate_new(size_type __current_size) const noexcept {
    (void)__current_size;




  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __annotate_delete() const noexcept {




  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __annotate_increase(size_type __n) const noexcept {
    (void)__n;




  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __annotate_shrink(size_type __old_size) const noexcept {
    (void)__old_size;




  }

  template <size_type __a>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type __align_it(size_type __s) noexcept {
    return (__s + (__a - 1)) & ~(__a - 1);
  }
  enum { __alignment = 8 };
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr size_type __recommend(size_type __s) noexcept {
    if (__s < __min_cap) {
      return static_cast<size_type>(__min_cap) - 1;
    }
    const size_type __boundary = sizeof(value_type) < __alignment ? __alignment / sizeof(value_type) : 1;
    size_type __guess = __align_it<__boundary>(__s + 1) - 1;
    if (__guess == __min_cap)
      ++__guess;
    return __guess;
  }

  inline constexpr void __init(const value_type* __s, size_type __sz, size_type __reserve);
  inline constexpr void __init(const value_type* __s, size_type __sz);
  inline constexpr void __init(size_type __n, value_type __c);
# 1983 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
  constexpr __attribute__((__noinline__)) void __init_copy_ctor_external(const value_type* __s, size_type __sz);

  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  inline constexpr void __init(_InputIterator __first, _InputIterator __last);

  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  inline constexpr void __init(_ForwardIterator __first, _ForwardIterator __last);

  template <class _InputIterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
  __init_with_sentinel(_InputIterator __first, _Sentinel __last);
  template <class _InputIterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
  __init_with_size(_InputIterator __first, _Sentinel __last, size_type __sz);

  constexpr



          __attribute__((__deprecated__("use __grow_by_without_replace"))) void __grow_by(
              size_type __old_cap,
              size_type __delta_cap,
              size_type __old_sz,
              size_type __n_copy,
              size_type __n_del,
              size_type __n_add = 0);
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __grow_by_without_replace(
      size_type __old_cap,
      size_type __delta_cap,
      size_type __old_sz,
      size_type __n_copy,
      size_type __n_del,
      size_type __n_add = 0);
  constexpr void __grow_by_and_replace(
      size_type __old_cap,
      size_type __delta_cap,
      size_type __old_sz,
      size_type __n_copy,
      size_type __n_del,
      size_type __n_add,
      const value_type* __p_new_stuff);




  template <bool __is_short>
  constexpr __attribute__((__noinline__)) basic_string& __assign_no_alias(const value_type* __s, size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __erase_to_end(size_type __pos) {
    __null_terminate_at(std::__to_address(__get_pointer()), __pos);
  }



  constexpr __attribute__((__noinline__)) void __erase_external_with_move(size_type __pos, size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __copy_assign_alloc(const basic_string& __str) {
    __copy_assign_alloc(
        __str, integral_constant<bool, __alloc_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __copy_assign_alloc(const basic_string& __str, true_type) {
    if (__alloc() == __str.__alloc())
      __alloc() = __str.__alloc();
    else {
      if (!__str.__is_long()) {
        __clear_and_shrink();
        __alloc() = __str.__alloc();
      } else {
        __annotate_delete();
        allocator_type __a = __str.__alloc();
        auto __allocation = std::__allocate_at_least(__a, __str.__get_long_cap());
        __begin_lifetime(__allocation.ptr, __allocation.count);
        if (__is_long())
          __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        __alloc() = std::move(__a);
        __set_long_pointer(__allocation.ptr);
        __set_long_cap(__allocation.count);
        __set_long_size(__str.size());
        __annotate_new(__get_long_size());
      }
    }
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
  __copy_assign_alloc(const basic_string&, false_type) noexcept {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __move_assign(basic_string& __str, false_type)
      noexcept(__alloc_traits::is_always_equal::value);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
  __move_assign(basic_string& __str, true_type)

      noexcept;





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __move_assign_alloc(basic_string& __str)
      noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value) {

    __move_assign_alloc(
        __str, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __move_assign_alloc(basic_string& __c, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value) {
    __alloc() = std::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void __move_assign_alloc(basic_string&, false_type) noexcept {}

  constexpr __attribute__((__noinline__)) basic_string& __assign_external(const value_type* __s);
  constexpr __attribute__((__noinline__)) basic_string& __assign_external(const value_type* __s, size_type __n);


  inline constexpr basic_string& __assign_short(const value_type* __s, size_type __n) {
    size_type __old_size = size();
    if (__n > __old_size)
      __annotate_increase(__n - __old_size);
    pointer __p =
        __is_long() ? (__set_long_size(__n), __get_long_pointer()) : (__set_short_size(__n), __get_short_pointer());
    traits_type::move(std::__to_address(__p), __s, __n);
    traits_type::assign(__p[__n], value_type());
    if (__old_size > __n)
      __annotate_shrink(__old_size);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string&
  __null_terminate_at(value_type* __p, size_type __newsz) {
    size_type __old_size = size();
    if (__newsz > __old_size)
      __annotate_increase(__newsz - __old_size);
    __set_size(__newsz);
    traits_type::assign(__p[__newsz], value_type());
    if (__old_size > __newsz)
      __annotate_shrink(__old_size);
    return *this;
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr bool __addr_in_range(const _Tp& __v) const {
    return std::__is_pointer_in_range(data(), data() + size() + 1, std::addressof(__v));
  }

  [[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_length_error() const {
    std::__throw_length_error("basic_string");
  }

  [[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void __throw_out_of_range() const {
    std::__throw_out_of_range("basic_string");
  }

  friend constexpr basic_string operator+ <>(const basic_string&, const basic_string&);
  friend constexpr basic_string operator+ <>(const value_type*, const basic_string&);
  friend constexpr basic_string operator+ <>(value_type, const basic_string&);
  friend constexpr basic_string operator+ <>(const basic_string&, const value_type*);
  friend constexpr basic_string operator+ <>(const basic_string&, value_type);
};
# 2154 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&, allocator<char> const&); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>::~basic_string(); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::operator=(value_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) const char& basic_string<char>::at(size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::reserve(size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::copy(value_type*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&, size_type, size_type, allocator<char> const&); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<char>::__init(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<char>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) void basic_string<char>::push_back(value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) const basic_string<char>::size_type basic_string<char>::npos; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::erase(size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(value_type const*) const; extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*) const; extern template __attribute__((__visibility__("default"))) char& basic_string<char>::at(size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::operator=(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::iterator basic_string<char>::insert(basic_string::const_iterator, value_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::resize(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, basic_string const&, size_type, size_type);

extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&, allocator<wchar_t> const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::~basic_string(); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::operator=(value_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) const wchar_t& basic_string<wchar_t>::at(size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::reserve(size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::copy(value_type*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&, size_type, size_type, allocator<wchar_t> const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__init(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::push_back(value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) const basic_string<wchar_t>::size_type basic_string<wchar_t>::npos; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::erase(size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(value_type const*) const; extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*) const; extern template __attribute__((__visibility__("default"))) wchar_t& basic_string<wchar_t>::at(size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::operator=(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::iterator basic_string<wchar_t>::insert(basic_string::const_iterator, value_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::resize(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, basic_string const&, size_type, size_type);





template <class _InputIterator,
          class _CharT = __iter_value_type<_InputIterator>,
          class _Allocator = allocator<_CharT>,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
          class = enable_if_t<__is_allocator<_Allocator>::value> >
basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
    -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;

template <class _CharT,
          class _Traits,
          class _Allocator = allocator<_CharT>,
          class = enable_if_t<__is_allocator<_Allocator>::value> >
explicit basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())
    -> basic_string<_CharT, _Traits, _Allocator>;

template <class _CharT,
          class _Traits,
          class _Allocator = allocator<_CharT>,
          class = enable_if_t<__is_allocator<_Allocator>::value>,
          class _Sz = typename allocator_traits<_Allocator>::size_type >
basic_string(basic_string_view<_CharT, _Traits>, _Sz, _Sz, const _Allocator& = _Allocator())
    -> basic_string<_CharT, _Traits, _Allocator>;



template <ranges::input_range _Range,
          class _Allocator = allocator<ranges::range_value_t<_Range>>,
          class = enable_if_t<__is_allocator<_Allocator>::value> >
basic_string(from_range_t, _Range&&, _Allocator = _Allocator())
    -> basic_string<ranges::range_value_t<_Range>, char_traits<ranges::range_value_t<_Range>>, _Allocator>;


template <class _CharT, class _Traits, class _Allocator>
constexpr void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve) {
  if (__libcpp_is_constant_evaluated())
    __r_.first() = __rep();
  if (__reserve > max_size())
    __throw_length_error();
  pointer __p;
  if (__fits_in_sso(__reserve)) {
    __set_short_size(__sz);
    __p = __get_short_pointer();
  } else {
    auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__reserve) + 1);
    __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__to_address(__p), __s, __sz);
  traits_type::assign(__p[__sz], value_type());
  __annotate_new(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz) {
  if (__libcpp_is_constant_evaluated())
    __r_.first() = __rep();
  if (__sz > max_size())
    __throw_length_error();
  pointer __p;
  if (__fits_in_sso(__sz)) {
    __set_short_size(__sz);
    __p = __get_short_pointer();
  } else {
    auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
    __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__to_address(__p), __s, __sz);
  traits_type::assign(__p[__sz], value_type());
  __annotate_new(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr __attribute__((__noinline__)) void
basic_string<_CharT, _Traits, _Allocator>::__init_copy_ctor_external(const value_type* __s, size_type __sz) {
  if (__libcpp_is_constant_evaluated())
    __r_.first() = __rep();

  pointer __p;
  if (__fits_in_sso(__sz)) {
    __p = __get_short_pointer();
    __set_short_size(__sz);
  } else {
    if (__sz > max_size())
      __throw_length_error();
    auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
    __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__to_address(__p), __s, __sz + 1);
  __annotate_new(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr void basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c) {
  if (__libcpp_is_constant_evaluated())
    __r_.first() = __rep();

  if (__n > max_size())
    __throw_length_error();
  pointer __p;
  if (__fits_in_sso(__n)) {
    __set_short_size(__n);
    __p = __get_short_pointer();
  } else {
    auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__n) + 1);
    __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __set_long_size(__n);
  }
  traits_type::assign(std::__to_address(__p), __n, __c);
  traits_type::assign(__p[__n], value_type());
  __annotate_new(__n);
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
constexpr void
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last) {
  __init_with_sentinel(std::move(__first), std::move(__last));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
basic_string<_CharT, _Traits, _Allocator>::__init_with_sentinel(_InputIterator __first, _Sentinel __last) {
  __r_.first() = __rep();
  __annotate_new(0);


  try {

    for (; __first != __last; ++__first)
      push_back(*__first);

  } catch (...) {
    __annotate_delete();
    if (__is_long())
      __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
    throw;
  }

}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr void
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last) {
  size_type __sz = static_cast<size_type>(std::distance(__first, __last));
  __init_with_size(__first, __last, __sz);
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
basic_string<_CharT, _Traits, _Allocator>::__init_with_size(_InputIterator __first, _Sentinel __last, size_type __sz) {
  if (__libcpp_is_constant_evaluated())
    __r_.first() = __rep();

  if (__sz > max_size())
    __throw_length_error();

  pointer __p;
  if (__fits_in_sso(__sz)) {
    __set_short_size(__sz);
    __p = __get_short_pointer();

  } else {
    auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
    __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __set_long_size(__sz);
  }


  try {

    for (; __first != __last; ++__first, (void)++__p)
      traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());

  } catch (...) {
    if (__is_long())
      __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
    throw;
  }

  __annotate_new(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr void basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace(
    size_type __old_cap,
    size_type __delta_cap,
    size_type __old_sz,
    size_type __n_copy,
    size_type __n_del,
    size_type __n_add,
    const value_type* __p_new_stuff) {
  size_type __ms = max_size();
  if (__delta_cap > __ms - __old_cap - 1)
    __throw_length_error();
  pointer __old_p = __get_pointer();
  size_type __cap =
      __old_cap < __ms / 2 - __alignment ? __recommend(std::max(__old_cap + __delta_cap, 2 * __old_cap)) : __ms - 1;
  __annotate_delete();
  auto __allocation = std::__allocate_at_least(__alloc(), __cap + 1);
  pointer __p = __allocation.ptr;
  __begin_lifetime(__p, __allocation.count);
  if (__n_copy != 0)
    traits_type::copy(std::__to_address(__p), std::__to_address(__old_p), __n_copy);
  if (__n_add != 0)
    traits_type::copy(std::__to_address(__p) + __n_copy, __p_new_stuff, __n_add);
  size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
  if (__sec_cp_sz != 0)
    traits_type::copy(
        std::__to_address(__p) + __n_copy + __n_add, std::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
  if (__old_cap + 1 != __min_cap)
    __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
  __set_long_pointer(__p);
  __set_long_cap(__allocation.count);
  __old_sz = __n_copy + __n_add + __sec_cp_sz;
  __set_long_size(__old_sz);
  traits_type::assign(__p[__old_sz], value_type());
  __annotate_new(__old_sz);
}




template <class _CharT, class _Traits, class _Allocator>
void constexpr



    __attribute__((__deprecated__("use __grow_by_without_replace"))) basic_string<_CharT, _Traits, _Allocator>::__grow_by(
        size_type __old_cap,
        size_type __delta_cap,
        size_type __old_sz,
        size_type __n_copy,
        size_type __n_del,
        size_type __n_add) {
  size_type __ms = max_size();
  if (__delta_cap > __ms - __old_cap)
    __throw_length_error();
  pointer __old_p = __get_pointer();
  size_type __cap =
      __old_cap < __ms / 2 - __alignment ? __recommend(std::max(__old_cap + __delta_cap, 2 * __old_cap)) : __ms - 1;
  __annotate_delete();
  auto __allocation = std::__allocate_at_least(__alloc(), __cap + 1);
  pointer __p = __allocation.ptr;
  __begin_lifetime(__p, __allocation.count);
  if (__n_copy != 0)
    traits_type::copy(std::__to_address(__p), std::__to_address(__old_p), __n_copy);
  size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
  if (__sec_cp_sz != 0)
    traits_type::copy(
        std::__to_address(__p) + __n_copy + __n_add, std::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
  if (__old_cap + 1 != __min_cap)
    __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
  __set_long_pointer(__p);
  __set_long_cap(__allocation.count);
}

template <class _CharT, class _Traits, class _Allocator>
void constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000")))
basic_string<_CharT, _Traits, _Allocator>::__grow_by_without_replace(
    size_type __old_cap,
    size_type __delta_cap,
    size_type __old_sz,
    size_type __n_copy,
    size_type __n_del,
    size_type __n_add) {
#pragma GCC diagnostic push
# 2450 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 2450 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  __grow_by(__old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add);
#pragma GCC diagnostic pop
  __set_long_size(__old_sz - __n_del + __n_add);
  __annotate_new(__old_sz - __n_del + __n_add);
}



template <class _CharT, class _Traits, class _Allocator>
template <bool __is_short>
constexpr __attribute__((__noinline__)) basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_no_alias(const value_type* __s, size_type __n) {
  size_type __cap = __is_short ? static_cast<size_type>(__min_cap) : __get_long_cap();
  if (__n < __cap) {
    size_type __old_size = __is_short ? __get_short_size() : __get_long_size();
    if (__n > __old_size)
      __annotate_increase(__n - __old_size);
    pointer __p = __is_short ? __get_short_pointer() : __get_long_pointer();
    __is_short ? __set_short_size(__n) : __set_long_size(__n);
    traits_type::copy(std::__to_address(__p), __s, __n);
    traits_type::assign(__p[__n], value_type());
    if (__old_size > __n)
      __annotate_shrink(__old_size);
  } else {
    size_type __sz = __is_short ? __get_short_size() : __get_long_size();
    __grow_by_and_replace(__cap - 1, __n - __cap + 1, __sz, 0, __sz, __n, __s);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr __attribute__((__noinline__)) basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(const value_type* __s, size_type __n) {
  size_type __cap = capacity();
  if (__cap >= __n) {
    size_type __old_size = size();
    if (__n > __old_size)
      __annotate_increase(__n - __old_size);
    value_type* __p = std::__to_address(__get_pointer());
    traits_type::move(__p, __s, __n);
    return __null_terminate_at(__p, __n);
  } else {
    size_type __sz = size();
    __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
    return *this;
  }
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n) {
  ((void)0);
  return (__builtin_constant_p(__n) && __fits_in_sso(__n)) ? __assign_short(__s, __n) : __assign_external(__s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c) {
  size_type __cap = capacity();
  size_type __old_size = size();
  if (__cap < __n) {
    size_type __sz = size();
    __grow_by_without_replace(__cap, __n - __cap, __sz, 0, __sz);
    __annotate_increase(__n);
  } else if (__n > __old_size)
    __annotate_increase(__n - __old_size);
  value_type* __p = std::__to_address(__get_pointer());
  traits_type::assign(__p, __n, __c);
  return __null_terminate_at(__p, __n);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c) {
  pointer __p;
  size_type __old_size = size();
  if (__old_size == 0)
    __annotate_increase(1);
  if (__is_long()) {
    __p = __get_long_pointer();
    __set_long_size(1);
  } else {
    __p = __get_short_pointer();
    __set_short_size(1);
  }
  traits_type::assign(*__p, __c);
  traits_type::assign(*++__p, value_type());
  if (__old_size > 1)
    __annotate_shrink(__old_size);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str) {
  if (this != std::addressof(__str)) {
    __copy_assign_alloc(__str);
    if (!__is_long()) {
      if (!__str.__is_long()) {
        size_type __old_size = __get_short_size();
        if (__get_short_size() < __str.__get_short_size())
          __annotate_increase(__str.__get_short_size() - __get_short_size());
        __r_.first() = __str.__r_.first();
        if (__old_size > __get_short_size())
          __annotate_shrink(__old_size);
      } else {
        return __assign_no_alias<true>(__str.data(), __str.size());
      }
    } else {
      return __assign_no_alias<false>(__str.data(), __str.size());
    }
  }
  return *this;
}



template <class _CharT, class _Traits, class _Allocator>
inline constexpr void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)
    noexcept(__alloc_traits::is_always_equal::value) {
  if (__alloc() != __str.__alloc())
    assign(__str);
  else
    __move_assign(__str, true_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)

    noexcept



{
  __annotate_delete();
  if (__is_long()) {
    __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());







  }
  size_type __str_old_size = __str.size();
  bool __str_was_short = !__str.__is_long();

  __move_assign_alloc(__str);
  __r_.first() = __str.__r_.first();
  __str.__set_short_size(0);
  traits_type::assign(__str.__get_short_pointer()[0], value_type());

  if (__str_was_short && this != &__str)
    __str.__annotate_shrink(__str_old_size);
  else


    __str.__annotate_new(0);
# 2620 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
  if (!__is_long() && &__str != this)

    __annotate_new(__get_short_size());
}



template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last) {
  __assign_with_sentinel(__first, __last);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr void
basic_string<_CharT, _Traits, _Allocator>::__assign_with_sentinel(_InputIterator __first, _Sentinel __last) {
  const basic_string __temp(__init_with_sentinel_tag(), std::move(__first), std::move(__last), __alloc());
  assign(__temp.data(), __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last) {
  if (__string_is_trivial_iterator<_ForwardIterator>::value) {
    size_type __n = static_cast<size_type>(std::distance(__first, __last));
    __assign_trivial(__first, __last, __n);
  } else {
    __assign_with_sentinel(__first, __last);
  }

  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Iterator, class _Sentinel>
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) void
basic_string<_CharT, _Traits, _Allocator>::__assign_trivial(_Iterator __first, _Sentinel __last, size_type __n) {
  ((void)0);


  size_type __old_size = size();
  size_type __cap = capacity();
  if (__cap < __n) {






    size_type __sz = size();
    __grow_by_without_replace(__cap, __n - __cap, __sz, 0, __sz);
    __annotate_increase(__n);
  } else if (__n > __old_size)
    __annotate_increase(__n - __old_size);
  pointer __p = __get_pointer();
  for (; __first != __last; ++__p, (void)++__first)
    traits_type::assign(*__p, *__first);
  traits_type::assign(*__p, value_type());
  __set_size(__n);
  if (__n < __old_size)
    __annotate_shrink(__old_size);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n) {
  size_type __sz = __str.size();
  if (__pos > __sz)
    __throw_out_of_range();
  return assign(__str.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp& __t, size_type __pos, size_type __n) {
  __self_view __sv = __t;
  size_type __sz = __sv.size();
  if (__pos > __sz)
    __throw_out_of_range();
  return assign(__sv.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr __attribute__((__noinline__)) basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(const value_type* __s) {
  return __assign_external(__s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s) {
  ((void)0);
  return __builtin_constant_p(*__s)
           ? (__fits_in_sso(traits_type::length(__s)) ? __assign_short(__s, traits_type::length(__s))
                                                      : __assign_external(__s, traits_type::length(__s)))
           : __assign_external(__s);
}


template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n) {
  ((void)0);
  size_type __cap = capacity();
  size_type __sz = size();
  if (__cap - __sz >= __n) {
    if (__n) {
      __annotate_increase(__n);
      value_type* __p = std::__to_address(__get_pointer());
      traits_type::copy(__p + __sz, __s, __n);
      __sz += __n;
      __set_size(__sz);
      traits_type::assign(__p[__sz], value_type());
    }
  } else
    __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c) {
  if (__n) {
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz < __n)
      __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __sz, 0);
    __annotate_increase(__n);
    pointer __p = __get_pointer();
    traits_type::assign(std::__to_address(__p) + __sz, __n, __c);
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr inline void
basic_string<_CharT, _Traits, _Allocator>::__append_default_init(size_type __n) {
  if (__n) {
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz < __n)
      __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __sz, 0);
    __annotate_increase(__n);
    pointer __p = __get_pointer();
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
}

template <class _CharT, class _Traits, class _Allocator>
constexpr void basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c) {
  bool __is_short = !__is_long();
  size_type __cap;
  size_type __sz;
  if (__is_short) {
    __cap = __min_cap - 1;
    __sz = __get_short_size();
  } else {
    __cap = __get_long_cap() - 1;
    __sz = __get_long_size();
  }
  if (__sz == __cap) {
    __grow_by_without_replace(__cap, 1, __sz, __sz, 0);
    __annotate_increase(1);
    __is_short = false;
  } else
    __annotate_increase(1);
  pointer __p = __get_pointer();
  if (__is_short) {
    __p = __get_short_pointer() + __sz;
    __set_short_size(__sz + 1);
  } else {
    __p = __get_long_pointer() + __sz;
    __set_long_size(__sz + 1);
  }
  traits_type::assign(*__p, __c);
  traits_type::assign(*++__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last) {
  size_type __sz = size();
  size_type __cap = capacity();
  size_type __n = static_cast<size_type>(std::distance(__first, __last));
  if (__n) {
    if (__string_is_trivial_iterator<_ForwardIterator>::value && !__addr_in_range(*__first)) {
      if (__cap - __sz < __n)
        __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __sz, 0);
      __annotate_increase(__n);
      pointer __p = __get_pointer() + __sz;
      for (; __first != __last; ++__p, (void)++__first)
        traits_type::assign(*__p, *__first);
      traits_type::assign(*__p, value_type());
      __set_size(__sz + __n);
    } else {
      const basic_string __temp(__first, __last, __alloc());
      append(__temp.data(), __temp.size());
    }
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n) {
  size_type __sz = __str.size();
  if (__pos > __sz)
    __throw_out_of_range();
  return append(__str.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const _Tp& __t, size_type __pos, size_type __n) {
  __self_view __sv = __t;
  size_type __sz = __sv.size();
  if (__pos > __sz)
    __throw_out_of_range();
  return append(__sv.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s) {
  ((void)0);
  return append(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n) {
  ((void)0);
  size_type __sz = size();
  if (__pos > __sz)
    __throw_out_of_range();
  size_type __cap = capacity();
  if (__cap - __sz >= __n) {
    if (__n) {
      __annotate_increase(__n);
      value_type* __p = std::__to_address(__get_pointer());
      size_type __n_move = __sz - __pos;
      if (__n_move != 0) {
        if (std::__is_pointer_in_range(__p + __pos, __p + __sz, __s))
          __s += __n;
        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
      }
      traits_type::move(__p + __pos, __s, __n);
      __sz += __n;
      __set_size(__sz);
      traits_type::assign(__p[__sz], value_type());
    }
  } else
    __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c) {
  size_type __sz = size();
  if (__pos > __sz)
    __throw_out_of_range();
  if (__n) {
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz >= __n) {
      __annotate_increase(__n);
      __p = std::__to_address(__get_pointer());
      size_type __n_move = __sz - __pos;
      if (__n_move != 0)
        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
    } else {
      __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
      __p = std::__to_address(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n, __c);
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last) {
  const basic_string __temp(__first, __last, __alloc());
  return insert(__pos, __temp.data(), __temp.data() + __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(
    const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last) {
  auto __n = static_cast<size_type>(std::distance(__first, __last));
  return __insert_with_size(__pos, __first, __last, __n);
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Iterator, class _Sentinel>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::__insert_with_size(
    const_iterator __pos, _Iterator __first, _Sentinel __last, size_type __n) {
  size_type __ip = static_cast<size_type>(__pos - begin());
  if (__n == 0)
    return begin() + __ip;

  if (__string_is_trivial_iterator<_Iterator>::value && !__addr_in_range(*__first)) {
    return __insert_from_safe_copy(__n, __ip, __first, __last);
  } else {
    const basic_string __temp(__init_with_sentinel_tag(), __first, __last, __alloc());
    return __insert_from_safe_copy(__n, __ip, __temp.begin(), __temp.end());
  }
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(
    size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n) {
  size_type __str_sz = __str.size();
  if (__pos2 > __str_sz)
    __throw_out_of_range();
  return insert(__pos1, __str.data() + __pos2, std::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n) {
  __self_view __sv = __t;
  size_type __str_sz = __sv.size();
  if (__pos2 > __str_sz)
    __throw_out_of_range();
  return insert(__pos1, __sv.data() + __pos2, std::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s) {
  ((void)0);
  return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c) {
  size_type __ip = static_cast<size_type>(__pos - begin());
  size_type __sz = size();
  size_type __cap = capacity();
  value_type* __p;
  if (__cap == __sz) {
    __grow_by_without_replace(__cap, 1, __sz, __ip, 0, 1);
    __p = std::__to_address(__get_long_pointer());
  } else {
    __annotate_increase(1);
    __p = std::__to_address(__get_pointer());
    size_type __n_move = __sz - __ip;
    if (__n_move != 0)
      traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
  }
  traits_type::assign(__p[__ip], __c);
  traits_type::assign(__p[++__sz], value_type());
  __set_size(__sz);
  return begin() + static_cast<difference_type>(__ip);
}



template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(
    size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
    __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
  ((void)0);
  size_type __sz = size();
  if (__pos > __sz)
    __throw_out_of_range();
  __n1 = std::min(__n1, __sz - __pos);
  size_type __cap = capacity();
  if (__cap - __sz + __n1 >= __n2) {
    value_type* __p = std::__to_address(__get_pointer());
    if (__n1 != __n2) {
      if (__n2 > __n1)
        __annotate_increase(__n2 - __n1);
      size_type __n_move = __sz - __pos - __n1;
      if (__n_move != 0) {
        if (__n1 > __n2) {
          traits_type::move(__p + __pos, __s, __n2);
          traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
          return __null_terminate_at(__p, __sz + (__n2 - __n1));
        }
        if (std::__is_pointer_in_range(__p + __pos + 1, __p + __sz, __s)) {
          if (__p + __pos + __n1 <= __s)
            __s += __n2 - __n1;
          else
          {
            traits_type::move(__p + __pos, __s, __n1);
            __pos += __n1;
            __s += __n2;
            __n2 -= __n1;
            __n1 = 0;
          }
        }
        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
      }
    }
    traits_type::move(__p + __pos, __s, __n2);
    return __null_terminate_at(__p, __sz + (__n2 - __n1));
  } else
    __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c) {
  size_type __sz = size();
  if (__pos > __sz)
    __throw_out_of_range();
  __n1 = std::min(__n1, __sz - __pos);
  size_type __cap = capacity();
  value_type* __p;
  if (__cap - __sz + __n1 >= __n2) {
    __p = std::__to_address(__get_pointer());
    if (__n1 != __n2) {
      if (__n2 > __n1)
        __annotate_increase(__n2 - __n1);
      size_type __n_move = __sz - __pos - __n1;
      if (__n_move != 0)
        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
    }
  } else {
    __grow_by_without_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
    __p = std::__to_address(__get_long_pointer());
  }
  traits_type::assign(__p + __pos, __n2, __c);
  return __null_terminate_at(__p, __sz - (__n1 - __n2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(
    const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2) {
  const basic_string __temp(__j1, __j2, __alloc());
  return replace(__i1, __i2, __temp);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(
    size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2) {
  size_type __str_sz = __str.size();
  if (__pos2 > __str_sz)
    __throw_out_of_range();
  return replace(__pos1, __n1, __str.data() + __pos2, std::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(
    size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2) {
  __self_view __sv = __t;
  size_type __str_sz = __sv.size();
  if (__pos2 > __str_sz)
    __throw_out_of_range();
  return replace(__pos1, __n1, __sv.data() + __pos2, std::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s) {
  ((void)0);
  return replace(__pos, __n1, __s, traits_type::length(__s));
}





template <class _CharT, class _Traits, class _Allocator>
constexpr __attribute__((__noinline__)) void
basic_string<_CharT, _Traits, _Allocator>::__erase_external_with_move(size_type __pos, size_type __n) {
  if (__n) {
    size_type __sz = size();
    value_type* __p = std::__to_address(__get_pointer());
    __n = std::min(__n, __sz - __pos);
    size_type __n_move = __sz - __pos - __n;
    if (__n_move != 0)
      traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
    __null_terminate_at(__p, __sz - __n);
  }
}

template <class _CharT, class _Traits, class _Allocator>
constexpr basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n) {
  if (__pos > size())
    __throw_out_of_range();
  if (__n == npos) {
    __erase_to_end(__pos);
  } else {
    __erase_external_with_move(__pos, __n);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos) {
  ((void)0);

  iterator __b = begin();
  size_type __r = static_cast<size_type>(__pos - __b);
  erase(__r, 1);
  return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last) {
  ((void)0);
  iterator __b = begin();
  size_type __r = static_cast<size_type>(__first - __b);
  erase(__r, static_cast<size_type>(__last - __first));
  return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr void basic_string<_CharT, _Traits, _Allocator>::pop_back() {
  ((void)0);
  __erase_to_end(size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr void basic_string<_CharT, _Traits, _Allocator>::clear() noexcept {
  size_type __old_size = size();
  if (__is_long()) {
    traits_type::assign(*__get_long_pointer(), value_type());
    __set_long_size(0);
  } else {
    traits_type::assign(*__get_short_pointer(), value_type());
    __set_short_size(0);
  }
  __annotate_shrink(__old_size);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr void basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c) {
  size_type __sz = size();
  if (__n > __sz)
    append(__n - __sz, __c);
  else
    __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr inline void
basic_string<_CharT, _Traits, _Allocator>::__resize_default_init(size_type __n) {
  size_type __sz = size();
  if (__n > __sz) {
    __append_default_init(__n - __sz);
  } else
    __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr void basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __requested_capacity) {
  if (__requested_capacity > max_size())
    __throw_length_error();




  if (__requested_capacity <= capacity())
    return;

  size_type __target_capacity = std::max(__requested_capacity, size());
  __target_capacity = __recommend(__target_capacity);
  if (__target_capacity == capacity())
    return;

  __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr void basic_string<_CharT, _Traits, _Allocator>::shrink_to_fit() noexcept {
  size_type __target_capacity = __recommend(size());
  if (__target_capacity == capacity())
    return;

  __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr void
basic_string<_CharT, _Traits, _Allocator>::__shrink_or_extend(size_type __target_capacity) {
  __annotate_delete();
  size_type __cap = capacity();
  size_type __sz = size();

  pointer __new_data, __p;
  bool __was_long, __now_long;
  if (__fits_in_sso(__target_capacity)) {
    __was_long = true;
    __now_long = false;
    __new_data = __get_short_pointer();
    __p = __get_long_pointer();
  } else {
    if (__target_capacity > __cap) {
      auto __allocation = std::__allocate_at_least(__alloc(), __target_capacity + 1);
      __new_data = __allocation.ptr;
      __target_capacity = __allocation.count - 1;
    } else {

      try {

        auto __allocation = std::__allocate_at_least(__alloc(), __target_capacity + 1);
        __new_data = __allocation.ptr;
        __target_capacity = __allocation.count - 1;

      } catch (...) {
        return;
      }




    }
    __begin_lifetime(__new_data, __target_capacity + 1);
    __now_long = true;
    __was_long = __is_long();
    __p = __get_pointer();
  }
  traits_type::copy(std::__to_address(__new_data), std::__to_address(__p), size() + 1);
  if (__was_long)
    __alloc_traits::deallocate(__alloc(), __p, __cap + 1);
  if (__now_long) {
    __set_long_cap(__target_capacity + 1);
    __set_long_size(__sz);
    __set_long_pointer(__new_data);
  } else
    __set_short_size(__sz);
  __annotate_new(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const {
  if (__n >= size())
    __throw_out_of_range();
  return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) {
  if (__n >= size())
    __throw_out_of_range();
  return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const {
  size_type __sz = size();
  if (__pos > __sz)
    __throw_out_of_range();
  size_type __rlen = std::min(__n, __sz - __pos);
  traits_type::copy(__s, data() + __pos, __rlen);
  return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr void basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)

    noexcept



{
  ((void)0);



  if (!__is_long())
    __annotate_delete();
  if (this != &__str && !__str.__is_long())
    __str.__annotate_delete();
  std::swap(__r_.first(), __str.__r_.first());
  std::__swap_allocator(__alloc(), __str.__alloc());
  if (!__is_long())
    __annotate_new(__get_short_size());
  if (this != &__str && !__str.__is_long())
    __str.__annotate_new(__str.__get_short_size());
}



template <class _Traits>
struct __attribute__((__visibility__("hidden"))) __traits_eq {
  typedef typename _Traits::char_type char_type;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool operator()(const char_type& __x, const char_type& __y) noexcept {
    return _Traits::eq(__x, __y);
  }
};

template <class _CharT, class _Traits, class _Allocator>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s, size_type __pos, size_type __n) const noexcept {
  ((void)0);
  return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str, size_type __pos) const noexcept {
  return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const _Tp& __t, size_type __pos) const noexcept {
  __self_view __sv = __t;
  return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s, size_type __pos) const noexcept {
  ((void)0);
  return std::__str_find<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c, size_type __pos) const noexcept {
  return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(
    const value_type* __s, size_type __pos, size_type __n) const noexcept {
  ((void)0);
  return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str, size_type __pos) const noexcept {
  return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const _Tp& __t, size_type __pos) const noexcept {
  __self_view __sv = __t;
  return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s, size_type __pos) const noexcept {
  ((void)0);
  return std::__str_rfind<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c, size_type __pos) const noexcept {
  return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(
    const value_type* __s, size_type __pos, size_type __n) const noexcept {
  ((void)0);
  return std::__str_find_first_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str, size_type __pos) const noexcept {
  return std::__str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const _Tp& __t, size_type __pos) const noexcept {
  __self_view __sv = __t;
  return std::__str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s, size_type __pos) const noexcept {
  ((void)0);
  return std::__str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c, size_type __pos) const noexcept {
  return find(__c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(
    const value_type* __s, size_type __pos, size_type __n) const noexcept {
  ((void)0);
  return std::__str_find_last_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str, size_type __pos) const noexcept {
  return std::__str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const _Tp& __t, size_type __pos) const noexcept {
  __self_view __sv = __t;
  return std::__str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s, size_type __pos) const noexcept {
  ((void)0);
  return std::__str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c, size_type __pos) const noexcept {
  return rfind(__c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
    const value_type* __s, size_type __pos, size_type __n) const noexcept {
  ((void)0);
  return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
    const basic_string& __str, size_type __pos) const noexcept {
  return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const _Tp& __t, size_type __pos) const noexcept {
  __self_view __sv = __t;
  return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s, size_type __pos) const noexcept {
  ((void)0);
  return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c, size_type __pos) const noexcept {
  return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
    const value_type* __s, size_type __pos, size_type __n) const noexcept {
  ((void)0);
  return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
    const basic_string& __str, size_type __pos) const noexcept {
  return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const _Tp& __t, size_type __pos) const noexcept {
  __self_view __sv = __t;
  return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s, size_type __pos) const noexcept {
  ((void)0);
  return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c, size_type __pos) const noexcept {
  return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr int basic_string<_CharT, _Traits, _Allocator>::compare(const _Tp& __t) const noexcept {
  __self_view __sv = __t;
  size_t __lhs_sz = size();
  size_t __rhs_sz = __sv.size();
  int __result = traits_type::compare(data(), __sv.data(), std::min(__lhs_sz, __rhs_sz));
  if (__result != 0)
    return __result;
  if (__lhs_sz < __rhs_sz)
    return -1;
  if (__lhs_sz > __rhs_sz)
    return 1;
  return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const noexcept {
  return compare(__self_view(__str));
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const {
  ((void)0);
  size_type __sz = size();
  if (__pos1 > __sz || __n2 == npos)
    __throw_out_of_range();
  size_type __rlen = std::min(__n1, __sz - __pos1);
  int __r = traits_type::compare(data() + __pos1, __s, std::min(__rlen, __n2));
  if (__r == 0) {
    if (__rlen < __n2)
      __r = -1;
    else if (__rlen > __n2)
      __r = 1;
  }
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
constexpr int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1, size_type __n1, const _Tp& __t) const {
  __self_view __sv = __t;
  return compare(__pos1, __n1, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1, size_type __n1, const basic_string& __str) const {
  return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
constexpr int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2) const {
  __self_view __sv = __t;
  return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2) const {
  return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
}

template <class _CharT, class _Traits, class _Allocator>
constexpr int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const noexcept {
  ((void)0);
  return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
constexpr int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1, size_type __n1, const value_type* __s) const {
  ((void)0);
  return compare(__pos1, __n1, __s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
inline constexpr bool basic_string<_CharT, _Traits, _Allocator>::__invariants() const {
  if (size() > capacity())
    return false;
  if (capacity() < __min_cap - 1)
    return false;
  if (data() == nullptr)
    return false;
  if (!_Traits::eq(data()[size()], value_type()))
    return false;
  return true;
}



template <class _CharT, class _Traits, class _Allocator>
inline constexpr void basic_string<_CharT, _Traits, _Allocator>::__clear_and_shrink() noexcept {
  clear();
  if (__is_long()) {
    __annotate_delete();
    __alloc_traits::deallocate(__alloc(), __get_long_pointer(), capacity() + 1);
    __r_.first() = __rep();
  }
}



template <class _CharT, class _Traits, class _Allocator>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept {

  return basic_string_view<_CharT, _Traits>(__lhs) == basic_string_view<_CharT, _Traits>(__rhs);




}

template <class _Allocator>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) noexcept {
  size_t __lhs_sz = __lhs.size();
  if (__lhs_sz != __rhs.size())
    return false;
  const char* __lp = __lhs.data();
  const char* __rp = __rhs.data();
  if (__lhs.__is_long())
    return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
  for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
    if (*__lp != *__rp)
      return false;
  return true;
}
# 3749 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
inline constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs) noexcept {

  return basic_string_view<_CharT, _Traits>(__lhs) == basic_string_view<_CharT, _Traits>(__rhs);
# 3762 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
}



template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto operator<=>(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
                                                 const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept {
  return basic_string_view<_CharT, _Traits>(__lhs) <=> basic_string_view<_CharT, _Traits>(__rhs);
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr auto
operator<=>(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs) {
  return basic_string_view<_CharT, _Traits>(__lhs) <=> basic_string_view<_CharT, _Traits>(__rhs);
}
# 3881 "/data/data/com.termux/files/usr/bin/../../usr/include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs) {
  using _String = basic_string<_CharT, _Traits, _Allocator>;
  auto __lhs_sz = __lhs.size();
  auto __rhs_sz = __rhs.size();
  _String __r(__uninitialized_size_tag(),
              __lhs_sz + __rhs_sz,
              _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
  auto __ptr = std::__to_address(__r.__get_pointer());
  _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
  _Traits::copy(__ptr + __lhs_sz, __rhs.data(), __rhs_sz);
  _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) {
  using _String = basic_string<_CharT, _Traits, _Allocator>;
  auto __lhs_sz = _Traits::length(__lhs);
  auto __rhs_sz = __rhs.size();
  _String __r(__uninitialized_size_tag(),
              __lhs_sz + __rhs_sz,
              _String::__alloc_traits::select_on_container_copy_construction(__rhs.get_allocator()));
  auto __ptr = std::__to_address(__r.__get_pointer());
  _Traits::copy(__ptr, __lhs, __lhs_sz);
  _Traits::copy(__ptr + __lhs_sz, __rhs.data(), __rhs_sz);
  _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) {
  using _String = basic_string<_CharT, _Traits, _Allocator>;
  typename _String::size_type __rhs_sz = __rhs.size();
  _String __r(__uninitialized_size_tag(),
              __rhs_sz + 1,
              _String::__alloc_traits::select_on_container_copy_construction(__rhs.get_allocator()));
  auto __ptr = std::__to_address(__r.__get_pointer());
  _Traits::assign(__ptr, 1, __lhs);
  _Traits::copy(__ptr + 1, __rhs.data(), __rhs_sz);
  _Traits::assign(__ptr + 1 + __rhs_sz, 1, _CharT());
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
inline constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs) {
  using _String = basic_string<_CharT, _Traits, _Allocator>;
  typename _String::size_type __lhs_sz = __lhs.size();
  typename _String::size_type __rhs_sz = _Traits::length(__rhs);
  _String __r(__uninitialized_size_tag(),
              __lhs_sz + __rhs_sz,
              _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
  auto __ptr = std::__to_address(__r.__get_pointer());
  _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
  _Traits::copy(__ptr + __lhs_sz, __rhs, __rhs_sz);
  _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs) {
  using _String = basic_string<_CharT, _Traits, _Allocator>;
  typename _String::size_type __lhs_sz = __lhs.size();
  _String __r(__uninitialized_size_tag(),
              __lhs_sz + 1,
              _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
  auto __ptr = std::__to_address(__r.__get_pointer());
  _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
  _Traits::assign(__ptr + __lhs_sz, 1, __rhs);
  _Traits::assign(__ptr + 1 + __lhs_sz, 1, _CharT());
  return __r;
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) {
  return std::move(__lhs.append(__rhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs) {
  return std::move(__rhs.insert(0, __lhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs) {
  return std::move(__lhs.append(__rhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190000"))) constexpr basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs) {
  return std::move(__