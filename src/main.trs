// use std::cmp::{Eq, PartialEq};
mod pg_plane;
use crate::pg_plane::{coincident, ProjectivePlanePrimitive};

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
struct PArch {}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
struct LArch {}

impl PArch {
    #[inline]
    fn new() -> Self {
        Self {}
    }
}

impl LArch {
    #[inline]
    fn new() -> Self {
        Self {}
    }
}

// impl PartialEq for PArch {
//     fn eq(&self, _rhs: &Self) -> bool {
//         false
//     }
// }
// impl Eq for PArch {}

impl ProjectivePlanePrimitive<LArch> for PArch {
    #[inline]
    fn incident(&self, _rhs: &LArch) -> bool {
        true
    }
    #[inline]
    fn interact(&self, _rhs: &Self) -> LArch {
        LArch::new()
    }
}

// impl PartialEq for LArch {
//     fn eq(&self, _rhs: &Self) -> bool {
//         false
//     }
// }
// impl Eq for LArch {}

impl ProjectivePlanePrimitive<PArch> for LArch {
    #[inline]
    fn incident(&self, _rhs: &PArch) -> bool {
        true
    }
    #[inline]
    fn interact(&self, _rhs: &Self) -> PArch {
        PArch::new()
    }
}

fn main() {
    let pt_p = PArch::new();
    let pt_q = PArch::new();
    let pt_r = PArch::new();
    let ln_l = &LArch::new();
    println!("{}", pt_p == pt_q);
    println!("{}", pt_p.incident(ln_l));
    println!("{}", coincident(&pt_p, &pt_q, &pt_r));
}
